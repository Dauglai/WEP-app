(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taiga-ui/cdk/classes')) :
    typeof define === 'function' && define.amd ? define('@taiga-ui/cdk/utils/math', ['exports', '@taiga-ui/cdk/classes'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global["taiga-ui"] = global["taiga-ui"] || {}, global["taiga-ui"].cdk = global["taiga-ui"].cdk || {}, global["taiga-ui"].cdk.utils = global["taiga-ui"].cdk.utils || {}, global["taiga-ui"].cdk.utils.math = {}), global["taiga-ui"].cdk.classes));
})(this, (function (exports, classes) { 'use strict';

    /**
     * Clamps a value between two inclusive limits
     *
     * @param value
     * @param min lower limit
     * @param max upper limit
     */
    function tuiClamp(value, min, max) {
        ngDevMode && classes.tuiAssert.assert(!Number.isNaN(value));
        ngDevMode && classes.tuiAssert.assert(!Number.isNaN(min));
        ngDevMode && classes.tuiAssert.assert(!Number.isNaN(max));
        ngDevMode && classes.tuiAssert.assert(max >= min);
        return Math.min(max, Math.max(min, value));
    }

    function tuiInRange(value, fromInclude, toExclude) {
        ngDevMode && classes.tuiAssert.assert(!Number.isNaN(value));
        ngDevMode && classes.tuiAssert.assert(!Number.isNaN(fromInclude));
        ngDevMode && classes.tuiAssert.assert(!Number.isNaN(toExclude));
        ngDevMode && classes.tuiAssert.assert(fromInclude < toExclude);
        return value >= fromInclude && value < toExclude;
    }

    /**
     * Normalizes any number to an integer within inclusive range
     *
     * @param value
     * @param min lower inclusive integer
     * @param max upper inclusive integer
     * @return an integer between min and max inclusive
     */
    function tuiNormalizeToIntNumber(value, min, max) {
        ngDevMode && classes.tuiAssert.assert(Number.isInteger(min));
        ngDevMode && classes.tuiAssert.assert(Number.isInteger(max));
        ngDevMode && classes.tuiAssert.assert(min <= max);
        if (Number.isNaN(value) || value <= min) {
            return min;
        }
        if (value >= max) {
            return max;
        }
        return Math.round(value);
    }

    /**
     * Rounds a number to the closest value in a fixed discrete series
     *
     * @param value
     * @param quantum series step
     */
    function tuiQuantize(value, quantum) {
        ngDevMode && classes.tuiAssert.assert(Number.isFinite(value));
        ngDevMode && classes.tuiAssert.assert(Number.isFinite(quantum));
        ngDevMode && classes.tuiAssert.assert(quantum > 0);
        var remainder = value % quantum;
        return remainder < quantum / 2 ? value - remainder : value + quantum - remainder;
    }

    var MAX_PRECISION = 292;
    function tuiRound(value, precision) {
        if (precision === void 0) { precision = 0; }
        return calculate(value, precision, Math.round);
    }
    function tuiCeil(value, precision) {
        if (precision === void 0) { precision = 0; }
        return calculate(value, precision, Math.ceil);
    }
    function tuiFloor(value, precision) {
        if (precision === void 0) { precision = 0; }
        return calculate(value, precision, Math.floor);
    }
    /**
     * Rounding number to the set precision
     *
     * @param value
     * @param precision number of digits in a float part
     * @param func rounding function (round, floor, ceil)
     */
    function calculate(value, precision, func) {
        if (value === Infinity) {
            return value;
        }
        ngDevMode && classes.tuiAssert.assert(!Number.isNaN(value), "Value must be number");
        ngDevMode &&
            classes.tuiAssert.assert(Number.isInteger(precision), "Precision must be integer");
        precision = Math.min(precision, MAX_PRECISION);
        var pair = (value + "e").split("e");
        var tempValue = func(Number(pair[0] + "e" + (Number(pair[1]) + precision)));
        var processedPair = (tempValue + "e").split("e");
        return Number(processedPair[0] + "e" + (Number(processedPair[1]) - precision));
    }

    /**
     * Calculates sum of any number of passed arguments
     */
    function tuiSum() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return args.reduce(function (a, b) { return a + b; }, 0);
    }

    function tuiToInt(bool) {
        return bool ? 1 : 0;
    }

    function tuiToInteger(value) {
        return parseInt(value, 10);
    }

    /**
     * Converts angle in degrees to radians
     */
    function tuiToRadians(deg) {
        return (deg * Math.PI) / 180;
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.tuiCeil = tuiCeil;
    exports.tuiClamp = tuiClamp;
    exports.tuiFloor = tuiFloor;
    exports.tuiInRange = tuiInRange;
    exports.tuiNormalizeToIntNumber = tuiNormalizeToIntNumber;
    exports.tuiQuantize = tuiQuantize;
    exports.tuiRound = tuiRound;
    exports.tuiSum = tuiSum;
    exports.tuiToInt = tuiToInt;
    exports.tuiToInteger = tuiToInteger;
    exports.tuiToRadians = tuiToRadians;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=taiga-ui-cdk-utils-math.umd.js.map
