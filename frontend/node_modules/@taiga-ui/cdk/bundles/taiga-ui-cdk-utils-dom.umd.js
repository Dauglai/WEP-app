(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taiga-ui/cdk/utils/math'), require('@taiga-ui/cdk/utils/miscellaneous'), require('@taiga-ui/cdk/classes')) :
    typeof define === 'function' && define.amd ? define('@taiga-ui/cdk/utils/dom', ['exports', '@taiga-ui/cdk/utils/math', '@taiga-ui/cdk/utils/miscellaneous', '@taiga-ui/cdk/classes'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global["taiga-ui"] = global["taiga-ui"] || {}, global["taiga-ui"].cdk = global["taiga-ui"].cdk || {}, global["taiga-ui"].cdk.utils = global["taiga-ui"].cdk.utils || {}, global["taiga-ui"].cdk.utils.dom = {}), global["taiga-ui"].cdk.utils.math, global["taiga-ui"].cdk.utils.miscellaneous, global["taiga-ui"].cdk.classes));
})(this, (function (exports, math, miscellaneous, classes) { 'use strict';

    function tuiCanScroll(element, rootElement, vertical, scrollEnd) {
        return vertical
            ? canScrollVertical(element, rootElement, scrollEnd)
            : canScrollHorizontal(element, rootElement, scrollEnd);
    }
    function canScrollVertical(element, rootElement, scrollEnd) {
        var currentElement = element;
        while (currentElement !== rootElement.parentElement) {
            if ((Math.floor(currentElement.scrollTop) > 0 && !scrollEnd) ||
                (Math.ceil(currentElement.scrollTop + currentElement.clientHeight) <
                    currentElement.scrollHeight &&
                    scrollEnd)) {
                return true;
            }
            if (currentElement.parentElement) {
                currentElement = currentElement.parentElement;
            }
            else {
                return false;
            }
        }
        return false;
    }
    function canScrollHorizontal(element, rootElement, scrollEnd) {
        var currentElement = element;
        while (currentElement !== rootElement.parentElement) {
            if ((Math.floor(currentElement.scrollLeft) > 0 && !scrollEnd) ||
                (Math.ceil(currentElement.scrollLeft + currentElement.clientWidth) <
                    currentElement.scrollWidth &&
                    scrollEnd)) {
                return true;
            }
            if (currentElement.parentElement) {
                currentElement = currentElement.parentElement;
            }
            else {
                return false;
            }
        }
        return false;
    }

    function tuiContainsOrAfter(current, node) {
        try {
            return (current.contains(node) ||
                !!(node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING));
        }
        catch (_a) {
            return false;
        }
    }

    function tuiIsInput(element) {
        return element.matches("input");
    }
    function tuiIsTextarea(element) {
        return element.matches("textarea");
    }
    function tuiIsTextfield(element) {
        return tuiIsInput(element) || tuiIsTextarea(element);
    }
    function tuiIsElement(node) {
        return !!node && "nodeType" in node && node.nodeType === Node.ELEMENT_NODE;
    }
    function tuiIsHTMLElement(node) {
        // TODO: iframe warning
        return node instanceof HTMLElement;
    }
    function tuiIsTextNode(node) {
        return node.nodeType === Node.TEXT_NODE;
    }

    /**
     * Gets actual target from open Shadow DOM if event happened within it
     */
    function tuiGetActualTarget(event) {
        return event.composedPath()[0];
    }

    var DEFAULT_FORMAT = "text/plain";
    /**
     * Gets text from data of clipboardEvent, it also works in IE and Edge browsers
     */
    function tuiGetClipboardDataText(event, format) {
        if (format === void 0) { format = DEFAULT_FORMAT; }
        return "clipboardData" in event && event.clipboardData !== null
            ? event.clipboardData.getData(format) ||
                event.clipboardData.getData(DEFAULT_FORMAT)
            : event.target.ownerDocument.defaultView.clipboardData.getData("text");
    }

    function tuiGetDocumentOrShadowRoot(node) {
        return "getRootNode" in node && node.isConnected
            ? node.getRootNode()
            : node.ownerDocument;
    }

    /**
     * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible
     *
     * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered
     * TODO: v4.0 change function signature to
     * ```ts
     * function tuiGetElementObscures(element: Element): readonly [Element, Element, Element, Element] | [] | null
     * ```
     */
    function tuiGetElementObscures(element) {
        var ownerDocument = element.ownerDocument;
        if (!(ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.defaultView) || !element.getBoundingClientRect) {
            return null;
        }
        var _a = ownerDocument.defaultView, innerWidth = _a.innerWidth, innerHeight = _a.innerHeight;
        var doc = tuiGetDocumentOrShadowRoot(element);
        var rect = element.getBoundingClientRect();
        var left = math.tuiClamp(Math.round(rect.left) + 2, 0, innerWidth);
        var top = math.tuiClamp(Math.round(rect.top) + 2, 0, innerHeight);
        var right = math.tuiClamp(Math.round(rect.right) - 2, 0, innerWidth);
        var bottom = math.tuiClamp(Math.round(rect.bottom) - 2, 0, innerHeight);
        var horizontalMiddle = math.tuiClamp(Math.round(rect.left + rect.width / 2), 0, innerWidth);
        var verticalMiddle = math.tuiClamp(Math.round(rect.top + rect.height / 2), 0, innerHeight);
        var elements = [
            doc.elementFromPoint(horizontalMiddle, top),
            doc.elementFromPoint(horizontalMiddle, bottom),
            doc.elementFromPoint(left, verticalMiddle),
            doc.elementFromPoint(right, verticalMiddle),
        ];
        var nonNull = elements.filter(miscellaneous.tuiIsPresent);
        if (!nonNull.length) {
            return nonNull;
        }
        var filtered = nonNull.filter(function (el) { return !element.contains(el); });
        return filtered.length === 4 ? filtered : null;
    }

    /**
     * Calculates offset for an element relative to it's parent several levels above
     *
     * @param host parent element
     * @param element
     * @return object with offsetTop and offsetLeft number properties
     */
    function tuiGetElementOffset(host, element) {
        ngDevMode && classes.tuiAssert.assert(host.contains(element), "Host must contain element");
        var offsetTop = element.offsetTop, offsetLeft = element.offsetLeft, offsetParent = element.offsetParent;
        while (tuiIsHTMLElement(offsetParent) && offsetParent !== host) {
            offsetTop += offsetParent.offsetTop;
            offsetLeft += offsetParent.offsetLeft;
            offsetParent = offsetParent.offsetParent;
        }
        return { offsetTop: offsetTop, offsetLeft: offsetLeft };
    }

    /**
     * Finds the nearest parent with scroll in it
     *
     * @param element initial element
     * @param vertical flag for orientation of scroll
     */
    function tuiGetScrollParent(element, vertical) {
        if (vertical === void 0) { vertical = true; }
        if (element === null) {
            return null;
        }
        if (vertical && element.scrollHeight > element.clientHeight) {
            return element;
        }
        if (!vertical && element.scrollWidth > element.clientWidth) {
            return element;
        }
        return tuiGetScrollParent(element.parentElement, vertical);
    }

    /**
     * @description:
     * cross browser way to get selected text
     *
     * History:
     * BUG - window.getSelection() fails when text selected in a form field
     * https://bugzilla.mozilla.org/show_bug.cgi?id=85686
     */
    function tuiGetSelectedText(_b) {
        var getSelection = _b.getSelection, document = _b.document;
        var _a;
        return document.activeElement && tuiIsTextfield(document.activeElement)
            ? document.activeElement.value.slice(document.activeElement.selectionStart || 0, document.activeElement.selectionEnd || 0)
            : ((_a = getSelection()) === null || _a === void 0 ? void 0 : _a.toString()) || null;
    }

    function tuiIsCurrentTarget(_a) {
        var target = _a.target, currentTarget = _a.currentTarget;
        return target === currentTarget;
    }

    function tuiIsElementEditable(element) {
        return (tuiIsTextfield(element) && !element.readOnly) || element.isContentEditable;
    }

    /**
     * Checks if an app is running inside <iframe /> tag
     */
    function tuiIsInsideIframe(win) {
        return win.parent !== win;
    }

    /**
     * Checks if node is inside a specific selector
     *
     * @param node
     * @param selector
     * @return true if node is inside a particular selector
     */
    function tuiIsNodeIn(node, selector) {
        var _a;
        return tuiIsTextNode(node)
            ? !!((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.closest(selector))
            : tuiIsElement(node) && !!node.closest(selector);
    }

    function tuiPointToClientRect(x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        var rect = {
            x: x,
            y: y,
            left: x,
            right: x,
            top: y,
            bottom: y,
            width: 0,
            height: 0,
        };
        return Object.assign(Object.assign({}, rect), { toJSON: function () {
                return rect;
            } });
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.tuiCanScroll = tuiCanScroll;
    exports.tuiContainsOrAfter = tuiContainsOrAfter;
    exports.tuiGetActualTarget = tuiGetActualTarget;
    exports.tuiGetClipboardDataText = tuiGetClipboardDataText;
    exports.tuiGetDocumentOrShadowRoot = tuiGetDocumentOrShadowRoot;
    exports.tuiGetElementObscures = tuiGetElementObscures;
    exports.tuiGetElementOffset = tuiGetElementOffset;
    exports.tuiGetScrollParent = tuiGetScrollParent;
    exports.tuiGetSelectedText = tuiGetSelectedText;
    exports.tuiIsCurrentTarget = tuiIsCurrentTarget;
    exports.tuiIsElement = tuiIsElement;
    exports.tuiIsElementEditable = tuiIsElementEditable;
    exports.tuiIsHTMLElement = tuiIsHTMLElement;
    exports.tuiIsInput = tuiIsInput;
    exports.tuiIsInsideIframe = tuiIsInsideIframe;
    exports.tuiIsNodeIn = tuiIsNodeIn;
    exports.tuiIsTextNode = tuiIsTextNode;
    exports.tuiIsTextarea = tuiIsTextarea;
    exports.tuiIsTextfield = tuiIsTextfield;
    exports.tuiPointToClientRect = tuiPointToClientRect;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=taiga-ui-cdk-utils-dom.umd.js.map
