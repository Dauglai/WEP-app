(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taiga-ui/cdk/exceptions'), require('rxjs'), require('rxjs/operators'), require('@taiga-ui/cdk/utils/miscellaneous'), require('@taiga-ui/cdk/constants'), require('@taiga-ui/cdk/utils'), require('@taiga-ui/cdk/utils/focus')) :
    typeof define === 'function' && define.amd ? define('@taiga-ui/cdk/observables', ['exports', '@taiga-ui/cdk/exceptions', 'rxjs', 'rxjs/operators', '@taiga-ui/cdk/utils/miscellaneous', '@taiga-ui/cdk/constants', '@taiga-ui/cdk/utils', '@taiga-ui/cdk/utils/focus'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global["taiga-ui"] = global["taiga-ui"] || {}, global["taiga-ui"].cdk = global["taiga-ui"].cdk || {}, global["taiga-ui"].cdk.observables = {}), global["taiga-ui"].cdk.exceptions, global.rxjs, global.rxjs.operators, global["taiga-ui"].cdk.utils.miscellaneous, global["taiga-ui"].cdk.constants, global["taiga-ui"].cdk.utils, global["taiga-ui"].cdk.utils.focus));
})(this, (function (exports, exceptions, rxjs, operators, miscellaneous, constants, utils, focus) { 'use strict';

    /**
     * Turns AbstractControl/Abstract-control-directive valueChanges into ReplaySubject(1)
     */
    function tuiControlValue(control) {
        return new rxjs.Observable(function (subscriber) {
            if (!control.valueChanges) {
                throw new exceptions.TuiValueChangesException();
            }
            control.valueChanges.pipe(operators.startWith(control.value)).subscribe(subscriber);
        });
    }

    function tuiTypedFromEvent(target, event, options) {
        if (options === void 0) { options = {}; }
        /**
         * @note:
         * in RxJS 7 type signature `TuiTypedEventTarget<E>` !== `HasEventTargetAddRemove<E>`
         */
        return rxjs.fromEvent(target, event, options);
    }

    /**
     * Letting go of the mouse after it was pressed
     * @param target
     */
    function tuiMouseDragFinishFrom(target) {
        return rxjs.merge(tuiTypedFromEvent(target, "mouseup"), tuiTypedFromEvent(target, "dragend"));
    }

    exports.TuiDragStage = void 0;
    (function (TuiDragStage) {
        TuiDragStage[TuiDragStage["Start"] = 0] = "Start";
        TuiDragStage[TuiDragStage["Continues"] = 1] = "Continues";
        TuiDragStage[TuiDragStage["End"] = 2] = "End";
    })(exports.TuiDragStage || (exports.TuiDragStage = {}));
    var TuiDragState = /** @class */ (function () {
        function TuiDragState(stage, event) {
            this.stage = stage;
            this.event = event;
        }
        return TuiDragState;
    }());
    function tuiDragAndDropFrom(element) {
        var ownerDocument = element.ownerDocument;
        if (!ownerDocument) {
            throw new exceptions.TuiOwnerDocumentException();
        }
        return rxjs.concat(tuiTypedFromEvent(element, "mousedown").pipe(operators.take(1), operators.map(function (event) { return new TuiDragState(0 /* Start */, event); })), rxjs.merge(tuiTypedFromEvent(ownerDocument, "mousemove").pipe(operators.map(function (event) { return new TuiDragState(1 /* Continues */, event); })), tuiMouseDragFinishFrom(ownerDocument).pipe(operators.take(1), operators.map(function (event) { return new TuiDragState(2 /* End */, event); }), operators.endWith(null))).pipe(operators.takeWhile(miscellaneous.tuiIsPresent))).pipe(operators.repeat());
    }

    /**
     * Operator to set lifespan after which current value is considered obsolete
     */
    function tuiIsAlive(lifespan) {
        if (lifespan === void 0) { lifespan = 0; }
        return rxjs.pipe(operators.switchMap(function () { return rxjs.timer(lifespan).pipe(operators.map(constants.ALWAYS_FALSE_HANDLER), operators.startWith(true)); }), operators.distinctUntilChanged());
    }

    var documentMouseUpIsAlive$;
    var documentMouseDownIsAlive$;
    function tuiFocusVisibleObservable(element) {
        var elementBlur$ = tuiTypedFromEvent(element, "blur");
        var ownerDocument = element.ownerDocument;
        if (!ownerDocument) {
            throw new exceptions.TuiOwnerDocumentException();
        }
        if (!documentMouseDownIsAlive$ || !documentMouseUpIsAlive$) {
            documentMouseUpIsAlive$ = tuiTypedFromEvent(ownerDocument, "mouseup", {
                capture: true,
            }).pipe(tuiIsAlive(), operators.startWith(false), operators.shareReplay({ bufferSize: 1, refCount: true }));
            documentMouseDownIsAlive$ = tuiTypedFromEvent(ownerDocument, "mousedown", {
                capture: true,
            }).pipe(tuiIsAlive(), operators.startWith(false), operators.shareReplay({ bufferSize: 1, refCount: true }));
        }
        return rxjs.merge(
        // focus events excluding ones that came right after mouse action
        rxjs.concat(tuiTypedFromEvent(element, "focus").pipe(operators.take(1)), 
        // filtering out blur events when element remains focused so that we ignore browser tab focus loss
        elementBlur$.pipe(operators.filter(function () { return !focus.tuiIsNativeFocused(element); }), operators.take(1), operators.ignoreElements())).pipe(operators.repeat(), operators.withLatestFrom(documentMouseDownIsAlive$, documentMouseUpIsAlive$, function (_event, elementActual, documentActual) { return elementActual || documentActual; }), operators.filter(utils.tuiIsFalsy))).pipe(operators.switchMap(function () { return elementBlur$.pipe(operators.map(constants.ALWAYS_FALSE_HANDLER), operators.take(1), operators.startWith(true)); }), operators.distinctUntilChanged());
    }

    function tuiIfMap(project, predicate) {
        if (predicate === void 0) { predicate = Boolean; }
        return rxjs.pipe(operators.switchMap(function (value) { return (predicate(value) ? project(value) : rxjs.EMPTY); }));
    }

    function tuiIsObserved(observable) {
        var _a, _b;
        return "observed" in observable
            ? observable.observed
            : !!((_b = (_a = observable) === null || _a === void 0 ? void 0 : _a.observers) === null || _b === void 0 ? void 0 : _b.length);
    }

    /**
     * Converts changes observable of a QueryList to an Observable of arrays
     */
    function tuiQueryListChanges(queryList) {
        return queryList.changes.pipe(operators.startWith(null), operators.map(function () { return miscellaneous.tuiGetOriginalArrayFromQueryList(queryList); }));
    }
    /**
     * @deprecated An alias, use {@link tuiQueryListChanges} instead
     */
    var tuiItemsQueryListObservable = tuiQueryListChanges;

    function tuiMustBePresent() {
        return operators.map(function (value) {
            if (!miscellaneous.tuiIsPresent(value)) {
                throw new exceptions.TuiValuePresentException();
            }
            return value;
        });
    }

    function tuiPressedObservable(element, _a) {
        var _b = _a === void 0 ? { onlyTrusted: true } : _a, onlyTrusted = _b.onlyTrusted;
        var ownerDocument = element.ownerDocument;
        if (!ownerDocument) {
            throw new exceptions.TuiOwnerDocumentException();
        }
        return tuiTypedFromEvent(element, "mousedown").pipe(operators.filter(function (_a) {
            var isTrusted = _a.isTrusted;
            return isTrusted || !onlyTrusted;
        }), operators.switchMap(function () { return tuiMouseDragFinishFrom(ownerDocument).pipe(operators.map(constants.ALWAYS_FALSE_HANDLER), operators.take(1), operators.startWith(true)); }));
    }

    function tuiPreventDefault() {
        return operators.tap(function (event) { return event.preventDefault(); });
    }

    function tuiStopPropagation() {
        return operators.tap(function (e) {
            e.stopPropagation();
        });
    }

    function tuiWatch(cdr) {
        return operators.tap(function () {
            cdr.markForCheck();
        });
    }

    function tuiZonefull(ngZone) {
        return function (source) { return new rxjs.Observable(function (subscriber) { return source.subscribe({
            next: function (value) { return ngZone.run(function () { return subscriber.next(value); }); },
            error: function (error) { return ngZone.run(function () { return subscriber.error(error); }); },
            complete: function () { return ngZone.run(function () { return subscriber.complete(); }); },
        }); }); };
    }
    function tuiZonefree(ngZone) {
        return function (source) { return new rxjs.Observable(function (subscriber) { return ngZone.runOutsideAngular(function () { return source.subscribe(subscriber); }); }); };
    }
    function tuiZoneOptimized(ngZone) {
        return rxjs.pipe(tuiZonefree(ngZone), tuiZonefull(ngZone));
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.TuiDragState = TuiDragState;
    exports.tuiControlValue = tuiControlValue;
    exports.tuiDragAndDropFrom = tuiDragAndDropFrom;
    exports.tuiFocusVisibleObservable = tuiFocusVisibleObservable;
    exports.tuiIfMap = tuiIfMap;
    exports.tuiIsAlive = tuiIsAlive;
    exports.tuiIsObserved = tuiIsObserved;
    exports.tuiItemsQueryListObservable = tuiItemsQueryListObservable;
    exports.tuiMouseDragFinishFrom = tuiMouseDragFinishFrom;
    exports.tuiMustBePresent = tuiMustBePresent;
    exports.tuiPressedObservable = tuiPressedObservable;
    exports.tuiPreventDefault = tuiPreventDefault;
    exports.tuiQueryListChanges = tuiQueryListChanges;
    exports.tuiStopPropagation = tuiStopPropagation;
    exports.tuiTypedFromEvent = tuiTypedFromEvent;
    exports.tuiWatch = tuiWatch;
    exports.tuiZoneOptimized = tuiZoneOptimized;
    exports.tuiZonefree = tuiZonefree;
    exports.tuiZonefull = tuiZonefull;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=taiga-ui-cdk-observables.umd.js.map
