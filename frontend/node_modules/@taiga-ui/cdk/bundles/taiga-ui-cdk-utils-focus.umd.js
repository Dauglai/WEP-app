(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taiga-ui/cdk/utils/dom'), require('@taiga-ui/cdk/constants')) :
    typeof define === 'function' && define.amd ? define('@taiga-ui/cdk/utils/focus', ['exports', '@taiga-ui/cdk/utils/dom', '@taiga-ui/cdk/constants'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global["taiga-ui"] = global["taiga-ui"] || {}, global["taiga-ui"].cdk = global["taiga-ui"].cdk || {}, global["taiga-ui"].cdk.utils = global["taiga-ui"].cdk.utils || {}, global["taiga-ui"].cdk.utils.focus = {}), global["taiga-ui"].cdk.utils.dom, global["taiga-ui"].cdk.constants));
})(this, (function (exports, dom, constants) { 'use strict';

    /**
     * Returns current active element, including shadow dom
     *
     * @return element or null
     */
    function tuiGetNativeFocused(doc) {
        var _a;
        if (!((_a = doc.activeElement) === null || _a === void 0 ? void 0 : _a.shadowRoot)) {
            return doc.activeElement;
        }
        var element = doc.activeElement.shadowRoot.activeElement;
        while (element === null || element === void 0 ? void 0 : element.shadowRoot) {
            element = element.shadowRoot.activeElement;
        }
        return element;
    }

    /**
     * Finds and blurs current active element, including shadow DOM
     */
    function tuiBlurNativeFocused(doc) {
        var activeElement = tuiGetNativeFocused(doc);
        if (dom.tuiIsHTMLElement(activeElement)) {
            activeElement.blur();
        }
    }

    /**
     * Checks for signs that element can be focused with keyboard. tabIndex above 0 is ignored to
     * only target natural focus order. Not checking the possibility of an element to
     * be focused, for example element can have display: none applied to it or any other
     * circumstances could prevent actual focus.
     */
    function tuiIsNativeKeyboardFocusable(element) {
        if (element.hasAttribute("disabled") || element.getAttribute("tabIndex") === "-1") {
            return false;
        }
        if ((dom.tuiIsHTMLElement(element) && element.isContentEditable) ||
            element.getAttribute("tabIndex") === "0") {
            return true;
        }
        switch (element.tagName) {
            case "BUTTON":
            case "SELECT":
            case "TEXTAREA":
                return true;
            case "VIDEO":
            case "AUDIO":
                return element.hasAttribute("controls");
            case "INPUT":
                return element.getAttribute("type") !== "hidden";
            case "A":
            case "LINK":
                return element.hasAttribute("href");
            default:
                return false;
        }
    }

    function tuiIsNativeMouseFocusable(element) {
        return (!element.hasAttribute("disabled") &&
            (element.getAttribute("tabIndex") === "-1" ||
                tuiIsNativeKeyboardFocusable(element)));
    }

    /**
     * @description:
     * Finds the closest element that can be focused with a keyboard or mouse in theory
     */
    function tuiGetClosestFocusable(_a) {
        var initial = _a.initial, root = _a.root, _b = _a.previous, previous = _b === void 0 ? false : _b, _c = _a.keyboard, keyboard = _c === void 0 ? true : _c;
        if (!root.ownerDocument) {
            return null;
        }
        var check = keyboard ? tuiIsNativeKeyboardFocusable : tuiIsNativeMouseFocusable;
        var treeWalker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, constants.svgNodeFilter);
        treeWalker.currentNode = initial;
        while (previous ? treeWalker.previousNode() : treeWalker.nextNode()) {
            if (dom.tuiIsHTMLElement(treeWalker.currentNode)) {
                initial = treeWalker.currentNode;
            }
            if (dom.tuiIsHTMLElement(initial) && check(initial)) {
                return initial;
            }
        }
        return null;
    }

    /**
     * Checks if element is focused.
     *
     * Could return true even after blur since element remains focused if you switch away from a browser tab.
     *
     * @param node or null (as a common return value of DOM nodes walking)
     * @return true if focused
     */
    function tuiIsNativeFocused(node) {
        return !!(node === null || node === void 0 ? void 0 : node.ownerDocument) && tuiGetNativeFocused(node.ownerDocument) === node;
    }

    /**
     * Checks if focused element is within given element.
     *
     * @param node
     * @return true if focused node is contained within element
     */
    function tuiIsNativeFocusedIn(node) {
        // !node.contains - check for IE11
        if (!node.ownerDocument || !node.contains) {
            return false;
        }
        var nativeFocused = tuiGetNativeFocused(node.ownerDocument);
        return nativeFocused !== null && node.contains(nativeFocused);
    }

    /**
     * Utility method for moving focus in a list of elements
     *
     * @param currentIndex currently focused index
     * @param elements array of focusable elements
     * @param step a step to move focus by, typically -1 or 1
     */
    function tuiMoveFocus(currentIndex, elements, step) {
        currentIndex += step;
        while (currentIndex >= 0 && currentIndex < elements.length) {
            elements[currentIndex].focus();
            if (tuiIsNativeFocused(elements[currentIndex])) {
                return;
            }
            currentIndex += step;
        }
    }

    /**
     * Focuses or blurs element with mouse action imitation (to spoof {@link TuiFocusVisibleService})
     *
     * @param element
     * @param focused desired focused state
     * @param preventScroll optionally prevent native browser scroll after focus
     */
    function tuiSetNativeMouseFocused(element, focused, preventScroll) {
        if (focused === void 0) { focused = true; }
        if (preventScroll === void 0) { preventScroll = false; }
        if (!element.ownerDocument) {
            return;
        }
        if (typeof Event === "function") {
            element.dispatchEvent(new Event("mousedown", { bubbles: true, cancelable: true }));
        }
        else {
            var event = element.ownerDocument.createEvent("Event");
            event.initEvent("mousedown", true, true);
            element.dispatchEvent(event);
        }
        if (focused) {
            element.focus({ preventScroll: preventScroll });
        }
        else {
            element.blur();
        }
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.tuiBlurNativeFocused = tuiBlurNativeFocused;
    exports.tuiGetClosestFocusable = tuiGetClosestFocusable;
    exports.tuiGetNativeFocused = tuiGetNativeFocused;
    exports.tuiIsNativeFocused = tuiIsNativeFocused;
    exports.tuiIsNativeFocusedIn = tuiIsNativeFocusedIn;
    exports.tuiIsNativeKeyboardFocusable = tuiIsNativeKeyboardFocusable;
    exports.tuiIsNativeMouseFocusable = tuiIsNativeMouseFocusable;
    exports.tuiMoveFocus = tuiMoveFocus;
    exports.tuiSetNativeMouseFocused = tuiSetNativeMouseFocused;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=taiga-ui-cdk-utils-focus.umd.js.map
