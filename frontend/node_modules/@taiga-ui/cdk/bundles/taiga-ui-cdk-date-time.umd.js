(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taiga-ui/cdk/constants'), require('@angular/core'), require('@taiga-ui/cdk/classes'), require('@taiga-ui/cdk/exceptions'), require('@taiga-ui/cdk/utils/math')) :
    typeof define === 'function' && define.amd ? define('@taiga-ui/cdk/date-time', ['exports', '@taiga-ui/cdk/constants', '@angular/core', '@taiga-ui/cdk/classes', '@taiga-ui/cdk/exceptions', '@taiga-ui/cdk/utils/math'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global["taiga-ui"] = global["taiga-ui"] || {}, global["taiga-ui"].cdk = global["taiga-ui"].cdk || {}, global["taiga-ui"].cdk["date-time"] = {}), global["taiga-ui"].cdk.constants, global.ng.core, global["taiga-ui"].cdk.classes, global["taiga-ui"].cdk.exceptions, global["taiga-ui"].cdk.utils.math));
})(this, (function (exports, constants, core, classes, exceptions, math) { 'use strict';

    var DAYS_IN_WEEK = 7;
    var DAYS_IN_NORMAL_YEAR = 365;
    var DAYS_IN_LEAP_YEAR = 366;
    var MONTHS_IN_YEAR = 12;
    var MIN_DAY = 1;
    var MIN_MONTH = 0;
    var MAX_MONTH = 11;
    var MIN_YEAR = 0;
    var MAX_YEAR = 9999;
    var RANGE_SEPARATOR_CHAR = "" + constants.CHAR_NO_BREAK_SPACE + constants.CHAR_EN_DASH + constants.CHAR_NO_BREAK_SPACE;
    var MILLISECONDS_IN_SECOND = 1000;
    var SECONDS_IN_MINUTE = 60;
    var MINUTES_IN_HOUR = 60;
    var HOURS_IN_DAY = 24;
    var MILLISECONDS_IN_MINUTE = MILLISECONDS_IN_SECOND * SECONDS_IN_MINUTE;
    var MILLISECONDS_IN_HOUR = MILLISECONDS_IN_MINUTE * MINUTES_IN_HOUR;
    var MILLISECONDS_IN_DAY = MILLISECONDS_IN_HOUR * HOURS_IN_DAY;

    /**
     * @internal 'dd.mm.yyyy'.length
     * Used in:
     * - {@link TuiInputDateComponent}
     * - {@link TuiInputDateRangeComponent}
     * - {@link TuiInputDateTimeComponent}
     */
    var DATE_FILLER_LENGTH = 10;
    /**
     * @internal
     * Used in {@link TuiInputDateRangeComponent}
     */
    var DATE_RANGE_FILLER_LENGTH = 2 * DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length;

    /**
     * Active date format for Taiga UI
     */
    var TUI_DATE_FORMAT = new core.InjectionToken("[TUI_DATE_FORMAT]", {
        factory: function () { return "DMY"; },
    });

    /**
     * Date separator for Taiga UI components
     */
    var TUI_DATE_SEPARATOR = new core.InjectionToken("[TUI_DATE_SEPARATOR]", {
        factory: function () { return "."; },
    });
    var changeDateSeparator = function (dateString, newDateSeparator) { return dateString.replace(/[^0-9A-Za-zА-Яа-я]/gi, newDateSeparator); };

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || from);
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    /**
     * Immutable year object
     * @nosideeffects
     */
    var TuiYear = /** @class */ (function () {
        function TuiYear(year) {
            this.year = year;
            ngDevMode && classes.tuiAssert.assert(TuiYear.isValidYear(year));
        }
        /**
         * Checks year for validity
         */
        TuiYear.isValidYear = function (year) {
            return Number.isInteger(year) && math.tuiInRange(year, MIN_YEAR, MAX_YEAR + 1);
        };
        /**
         * Check if passed year is a leap year
         */
        TuiYear.isLeapYear = function (year) {
            ngDevMode && classes.tuiAssert.assert(TuiYear.isValidYear(year));
            return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
        };
        /**
         * Returns amount of leap years from year 0 to the passed one
         */
        TuiYear.getAbsoluteLeapYears = function (year) {
            ngDevMode && classes.tuiAssert.assert(TuiYear.isValidYear(year));
            return Math.ceil(year / 400) + (Math.ceil(year / 4) - Math.ceil(year / 100));
        };
        TuiYear.lengthBetween = function (from, to) {
            return to.year - from.year;
        };
        /**
         * Normalizes year by clamping it between min and max years
         */
        TuiYear.normalizeYearPart = function (year) {
            return math.tuiNormalizeToIntNumber(year, MIN_YEAR, MAX_YEAR);
        };
        Object.defineProperty(TuiYear.prototype, "formattedYear", {
            get: function () {
                return String(this.year).padStart(4, "0");
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TuiYear.prototype, "isLeapYear", {
            get: function () {
                return TuiYear.isLeapYear(this.year);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TuiYear.prototype, "absoluteLeapYears", {
            /**
             * Returns amount of leap years from year 0 to current
             */
            get: function () {
                return TuiYear.getAbsoluteLeapYears(this.year);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Passed year is after current
         */
        TuiYear.prototype.yearBefore = function (_a) {
            var year = _a.year;
            return this.year < year;
        };
        /**
         * Passed year is the same or after current
         */
        TuiYear.prototype.yearSameOrBefore = function (_a) {
            var year = _a.year;
            return this.year <= year;
        };
        /**
         * Passed year is the same as current
         */
        TuiYear.prototype.yearSame = function (_a) {
            var year = _a.year;
            return this.year === year;
        };
        /**
         * Passed year is either the same of before the current
         */
        TuiYear.prototype.yearSameOrAfter = function (_a) {
            var year = _a.year;
            return this.year >= year;
        };
        /**
         * Passed year is before current
         */
        TuiYear.prototype.yearAfter = function (_a) {
            var year = _a.year;
            return this.year > year;
        };
        /**
         * Immutably offsets year
         */
        TuiYear.prototype.append = function (_a) {
            var _b = _a.year, year = _b === void 0 ? 0 : _b;
            ngDevMode && classes.tuiAssert.assert(Number.isInteger(year));
            var resultYear = this.year + year;
            ngDevMode && classes.tuiAssert.assert(TuiYear.isValidYear(resultYear));
            return new TuiYear(resultYear);
        };
        TuiYear.prototype.toString = function () {
            return this.formattedYear;
        };
        TuiYear.prototype.valueOf = function () {
            return this.year;
        };
        /**
         * Returns the primitive value of the given Date object.
         * Depending on the argument, the method can return either a string or a number.
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/@@toPrimitive
         */
        TuiYear.prototype[Symbol.toPrimitive] = function (hint) {
            return Date.prototype[Symbol.toPrimitive].call(this, hint);
        };
        TuiYear.prototype.toJSON = function () {
            return this.formattedYear;
        };
        return TuiYear;
    }());

    /**
     * Immutable object consisting of year and month
     */
    var TuiMonth = /** @class */ (function (_super) {
        __extends(TuiMonth, _super);
        /**
         * @param year
         * @param month (starting with 0)
         */
        function TuiMonth(year, month) {
            var _this = _super.call(this, year) || this;
            _this.month = month;
            ngDevMode && classes.tuiAssert.assert(TuiMonth.isValidMonth(year, month));
            return _this;
        }
        /**
         * Tests month and year for validity
         */
        TuiMonth.isValidMonth = function (year, month) {
            return TuiYear.isValidYear(year) && TuiMonth.isValidMonthPart(month);
        };
        /**
         * Returns number of days in a month
         */
        TuiMonth.getMonthDaysCount = function (month, isLeapYear) {
            ngDevMode && classes.tuiAssert.assert(TuiMonth.isValidMonthPart(month));
            switch (month) {
                case 1 /* February */:
                    return isLeapYear ? 29 : 28;
                case 3 /* April */:
                case 5 /* June */:
                case 8 /* September */:
                case 10 /* November */:
                    return 30;
                default:
                    return 31;
            }
        };
        /**
         * Returns current month and year based on local time zone
         * @nosideeffects
         */
        TuiMonth.currentLocal = function () {
            var nativeDate = new Date();
            return new TuiMonth(nativeDate.getFullYear(), nativeDate.getMonth());
        };
        /**
         * Returns current month and year based on UTC
         */
        TuiMonth.currentUtc = function () {
            var nativeDate = new Date();
            return new TuiMonth(nativeDate.getUTCFullYear(), nativeDate.getUTCMonth());
        };
        TuiMonth.lengthBetween = function (from, to) {
            var absoluteFrom = from.month + from.year * 12;
            var absoluteTo = to.month + to.year * 12;
            return absoluteTo - absoluteFrom;
        };
        /**
         * Normalizes number by clamping it between min and max month
         */
        TuiMonth.normalizeMonthPart = function (month) {
            return math.tuiNormalizeToIntNumber(month, MIN_MONTH, MAX_MONTH);
        };
        /**
         * Tests month for validity
         */
        TuiMonth.isValidMonthPart = function (month) {
            return Number.isInteger(month) && math.tuiInRange(month, MIN_MONTH, MAX_MONTH + 1);
        };
        Object.defineProperty(TuiMonth.prototype, "formattedMonthPart", {
            get: function () {
                return String(this.month + 1).padStart(2, "0");
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TuiMonth.prototype, "daysCount", {
            /**
             * Returns days in a month
             */
            get: function () {
                return TuiMonth.getMonthDaysCount(this.month, this.isLeapYear);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Passed month and year are after current
         */
        TuiMonth.prototype.monthBefore = function (another) {
            return (this.yearBefore(another) ||
                (this.yearSame(another) && this.month < another.month));
        };
        /**
         * Passed month and year are after or the same as current
         */
        TuiMonth.prototype.monthSameOrBefore = function (another) {
            return (this.yearBefore(another) ||
                (this.yearSame(another) && this.month <= another.month));
        };
        /**
         * Passed month and year are the same as current
         */
        TuiMonth.prototype.monthSame = function (another) {
            return this.yearSame(another) && this.month === another.month;
        };
        /**
         * Passed month and year are either before or equal to current
         */
        TuiMonth.prototype.monthSameOrAfter = function (another) {
            return (this.yearAfter(another) ||
                (this.yearSame(another) && this.month >= another.month));
        };
        /**
         * Passed month and year are before current
         */
        TuiMonth.prototype.monthAfter = function (another) {
            return (this.yearAfter(another) ||
                (this.yearSame(another) && this.month > another.month));
        };
        /**
         * Immutably alters current month and year by passed offset
         *
         * @param offset
         * @return new month and year object as a result of offsetting current
         */
        TuiMonth.prototype.append = function (_a) {
            var _b = _a.year, year = _b === void 0 ? 0 : _b, _c = _a.month, month = _c === void 0 ? 0 : _c;
            var totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
            return new TuiMonth(Math.floor(totalMonths / MONTHS_IN_YEAR), totalMonths % MONTHS_IN_YEAR);
        };
        TuiMonth.prototype.toString = function () {
            return this.formattedMonthPart + "." + this.formattedYear;
        };
        TuiMonth.prototype.valueOf = function () {
            return this.toLocalNativeDate().valueOf();
        };
        TuiMonth.prototype.toJSON = function () {
            return _super.prototype.toJSON.call(this) + "-" + this.formattedMonthPart;
        };
        /**
         * Returns native {@link Date} based on local time zone
         */
        TuiMonth.prototype.toLocalNativeDate = function () {
            return new Date(this.year, this.month);
        };
        /**
         * Returns native {@link Date} based on UTC
         */
        TuiMonth.prototype.toUtcNativeDate = function () {
            return new Date(Date.UTC(this.year, this.month));
        };
        return TuiMonth;
    }(TuiYear));

    // TODO: Localized formatting
    /**
     * Immutable date object, consisting of day, month and year
     */
    var TuiDay = /** @class */ (function (_super) {
        __extends(TuiDay, _super);
        function TuiDay(year, month, day) {
            var _this = _super.call(this, year, month) || this;
            _this.day = day;
            ngDevMode && classes.tuiAssert.assert(TuiDay.isValidDay(year, month, day));
            return _this;
        }
        /**
         * Creates {@link TuiDay} from native {@link Date} based on local time zone
         */
        TuiDay.fromLocalNativeDate = function (date) {
            return new TuiDay(date.getFullYear(), date.getMonth(), date.getDate());
        };
        /**
         * Creates {@link TuiDay} from native {@link Date} using UTC
         */
        TuiDay.fromUtcNativeDate = function (date) {
            return new TuiDay(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
        };
        /**
         * Check validity of year, month and day
         *
         * @param year
         * @param month
         * @param day
         * @return boolean validity
         */
        TuiDay.isValidDay = function (year, month, day) {
            return (TuiMonth.isValidMonth(year, month) &&
                Number.isInteger(day) &&
                math.tuiInRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1));
        };
        /**
         * Current day based on local time zone
         */
        TuiDay.currentLocal = function () {
            var nativeDate = new Date();
            var year = nativeDate.getFullYear();
            var month = nativeDate.getMonth();
            var day = nativeDate.getDate();
            return new TuiDay(year, month, day);
        };
        /**
         * Returns current day based on UTC
         */
        TuiDay.currentUtc = function () {
            var nativeDate = new Date();
            var year = nativeDate.getUTCFullYear();
            var month = nativeDate.getUTCMonth();
            var day = nativeDate.getUTCDate();
            return new TuiDay(year, month, day);
        };
        /**
         * Calculates {@link TuiDay} normalizing year, month and day. {@link NaN} is turned into minimal value.
         *
         * @param year any year value, including invalid
         * @param month any month value, including invalid (months start with 0)
         * @param day any day value, including invalid
         * @return normalized date
         */
        TuiDay.normalizeOf = function (year, month, day) {
            var normalizedYear = TuiYear.normalizeYearPart(year);
            var normalizedMonth = TuiMonth.normalizeMonthPart(month);
            var normalizedDay = TuiDay.normalizeDayPart(day, normalizedMonth, normalizedYear);
            return new TuiDay(normalizedYear, normalizedMonth, normalizedDay);
        };
        TuiDay.lengthBetween = function (from, to) {
            return Math.round((to.toLocalNativeDate().getTime() - from.toLocalNativeDate().getTime()) /
                (1000 * 60 * 60 * 24));
        };
        TuiDay.parseRawDateString = function (date, dateMode) {
            if (dateMode === void 0) { dateMode = "DMY"; }
            ngDevMode &&
                classes.tuiAssert.assert(date.length === DATE_FILLER_LENGTH, "[parseRawDateString]: wrong date string length");
            switch (dateMode) {
                case "YMD":
                    return {
                        day: parseInt(date.slice(8, 10), 10),
                        month: parseInt(date.slice(5, 7), 10) - 1,
                        year: parseInt(date.slice(0, 4), 10),
                    };
                case "MDY":
                    return {
                        day: parseInt(date.slice(3, 5), 10),
                        month: parseInt(date.slice(0, 2), 10) - 1,
                        year: parseInt(date.slice(6, 10), 10),
                    };
                default:
                case "DMY":
                    return {
                        day: parseInt(date.slice(0, 2), 10),
                        month: parseInt(date.slice(3, 5), 10) - 1,
                        year: parseInt(date.slice(6, 10), 10),
                    };
            }
        };
        // TODO: Move month and year related code corresponding classes
        /**
         * Parsing a string with date with normalization
         *
         * @param rawDate date string
         * @param dateMode date format of the date string (DMY | MDY | YMD)
         * @return normalized date
         */
        TuiDay.normalizeParse = function (rawDate, dateMode) {
            if (dateMode === void 0) { dateMode = "DMY"; }
            var _a = this.parseRawDateString(rawDate, dateMode), day = _a.day, month = _a.month, year = _a.year;
            return TuiDay.normalizeOf(year, month, day);
        };
        /**
         * Parsing a date stringified in a toJSON format
         * @param yearMonthDayString date string in format of YYYY-MM-DD
         * @return date
         * @throws exceptions if any part of the date is invalid
         */
        TuiDay.jsonParse = function (yearMonthDayString) {
            var _a = this.parseRawDateString(yearMonthDayString, "YMD"), day = _a.day, month = _a.month, year = _a.year;
            if (!TuiYear.isValidYear(year)) {
                throw new exceptions.TuiInvalidYearException(year);
            }
            if (!TuiMonth.isValidMonth(year, month)) {
                throw new exceptions.TuiInvalidMonthException(month);
            }
            if (!Number.isInteger(day) ||
                !math.tuiInRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1)) {
                throw new exceptions.TuiInvalidDayException(day);
            }
            return new TuiDay(year, month, day);
        };
        TuiDay.normalizeDayPart = function (day, month, year) {
            ngDevMode && classes.tuiAssert.assert(TuiMonth.isValidMonth(year, month));
            var monthDaysCount = TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year));
            return math.tuiNormalizeToIntNumber(day, 1, monthDaysCount);
        };
        Object.defineProperty(TuiDay.prototype, "formattedDayPart", {
            get: function () {
                return String(this.day).padStart(2, "0");
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TuiDay.prototype, "isWeekend", {
            get: function () {
                var dayOfWeek = this.dayOfWeek(false);
                return dayOfWeek === 6 /* Saturday */ || dayOfWeek === 0 /* Sunday */;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns day of week
         *
         * @param startFromMonday whether week starts from Monday and not from Sunday
         * @return day of week (from 0 to 6)
         */
        TuiDay.prototype.dayOfWeek = function (startFromMonday) {
            if (startFromMonday === void 0) { startFromMonday = true; }
            var dayOfWeek = startFromMonday
                ? this.toLocalNativeDate().getDay() - 1
                : this.toLocalNativeDate().getDay();
            return dayOfWeek < 0 ? 6 : dayOfWeek;
        };
        /**
         * Passed date is after current
         */
        TuiDay.prototype.dayBefore = function (another) {
            return (this.monthBefore(another) ||
                (this.monthSame(another) && this.day < another.day));
        };
        /**
         * Passed date is after or equals to current
         */
        TuiDay.prototype.daySameOrBefore = function (another) {
            return (this.monthBefore(another) ||
                (this.monthSame(another) && this.day <= another.day));
        };
        /**
         * Passed date is the same as current
         */
        TuiDay.prototype.daySame = function (another) {
            return this.monthSame(another) && this.day === another.day;
        };
        /**
         * Passed date is either before or the same as current
         */
        TuiDay.prototype.daySameOrAfter = function (another) {
            return (this.monthAfter(another) ||
                (this.monthSame(another) && this.day >= another.day));
        };
        /**
         * Passed date is before current
         */
        TuiDay.prototype.dayAfter = function (another) {
            return (this.monthAfter(another) ||
                (this.monthSame(another) && this.day > another.day));
        };
        /**
         * Clamping date between two limits
         *
         * @param min
         * @param max
         * @return clamped date
         */
        TuiDay.prototype.dayLimit = function (min, max) {
            if (min !== null && this.dayBefore(min)) {
                return min;
            }
            if (max !== null && this.dayAfter(max)) {
                return max;
            }
            return this;
        };
        /**
         * Immutably alters current day by passed offset
         *
         * If resulting month has more days than original one, date is rounded to the maximum day
         * in the resulting month. Offset of days will be calculated based on the resulted year and month
         * to not interfere with parent classes methods
         *
         * @param offset
         * @return new date object as a result of offsetting current
         */
        TuiDay.prototype.append = function (_a) {
            var _b = _a.year, year = _b === void 0 ? 0 : _b, _c = _a.month, month = _c === void 0 ? 0 : _c, _d = _a.day, day = _d === void 0 ? 0 : _d;
            var totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
            var years = Math.floor(totalMonths / MONTHS_IN_YEAR);
            var months = totalMonths % MONTHS_IN_YEAR;
            var days = Math.min(this.day, TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) + day;
            while (days > TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) {
                days -= TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
                if (months === 11 /* December */) {
                    years++;
                    months = 0 /* January */;
                }
                else {
                    months++;
                }
            }
            while (days < MIN_DAY) {
                if (months === 0 /* January */) {
                    years--;
                    months = 11 /* December */;
                }
                else {
                    months--;
                }
                days += TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
            }
            return new TuiDay(years, months, days);
        };
        /**
         * Returns formatted whole date
         */
        TuiDay.prototype.getFormattedDay = function (dateFormat, separator) {
            ngDevMode &&
                classes.tuiAssert.assert(separator.length === 1, "Separator should consist of only 1 symbol");
            var dd = this.formattedDayPart;
            var mm = this.formattedMonthPart;
            var yyyy = this.formattedYear;
            switch (dateFormat) {
                case "YMD":
                    return "" + yyyy + separator + mm + separator + dd;
                case "MDY":
                    return "" + mm + separator + dd + separator + yyyy;
                case "DMY":
                default:
                    return "" + dd + separator + mm + separator + yyyy;
            }
        };
        TuiDay.prototype.toString = function (dateFormat, separator) {
            if (dateFormat === void 0) { dateFormat = "DMY"; }
            if (separator === void 0) { separator = "."; }
            return this.getFormattedDay(dateFormat, separator);
        };
        TuiDay.prototype.toJSON = function () {
            return _super.prototype.toJSON.call(this) + "-" + this.formattedDayPart;
        };
        /**
         * Returns native {@link Date} based on local time zone
         */
        TuiDay.prototype.toLocalNativeDate = function () {
            return new Date(this.year, this.month, this.day);
        };
        /**
         * Returns native {@link Date} based on UTC
         */
        TuiDay.prototype.toUtcNativeDate = function () {
            return new Date(Date.UTC(this.year, this.month, this.day));
        };
        return TuiDay;
    }(TuiMonth));

    /**
     * An immutable range of two {@link TuiMonth} objects
     */
    var TuiMonthRange = /** @class */ (function () {
        function TuiMonthRange(from, to) {
            this.from = from;
            this.to = to;
            ngDevMode && classes.tuiAssert.assert(from.monthSameOrBefore(to));
        }
        TuiMonthRange.sort = function (month1, month2) {
            return month1.monthSameOrBefore(month2)
                ? new TuiMonthRange(month1, month2)
                : new TuiMonthRange(month2, month1);
        };
        Object.defineProperty(TuiMonthRange.prototype, "isSingleMonth", {
            get: function () {
                return this.from.monthSame(this.to);
            },
            enumerable: false,
            configurable: true
        });
        TuiMonthRange.prototype.monthSame = function (another) {
            return this.from.monthSame(another.from) && this.to.monthSame(another.to);
        };
        TuiMonthRange.prototype.toString = function () {
            return "" + this.from + RANGE_SEPARATOR_CHAR + this.to;
        };
        return TuiMonthRange;
    }());

    /**
     * An immutable range of two {@link TuiDay} objects
     */
    var TuiDayRange = /** @class */ (function (_super) {
        __extends(TuiDayRange, _super);
        function TuiDayRange(from, to) {
            var _this = _super.call(this, from, to) || this;
            _this.from = from;
            _this.to = to;
            ngDevMode && classes.tuiAssert.assert(from.daySameOrBefore(to));
            return _this;
        }
        /**
         * Creates range from two days after sorting them
         *
         * @param day1
         * @param day2
         * @return new range with sorted days
         */
        TuiDayRange.sort = function (day1, day2) {
            return day1.daySameOrBefore(day2)
                ? new TuiDayRange(day1, day2)
                : new TuiDayRange(day2, day1);
        };
        /**
         * Parse and correct a day range in string format
         *
         * @param rangeString a string of dates in a format dd.mm.yyyy - dd.mm.yyyy
         * @param dateMode {@link TuiDateMode}
         * @return normalized day range object
         */
        TuiDayRange.normalizeParse = function (rangeString, dateMode) {
            if (dateMode === void 0) { dateMode = "DMY"; }
            var leftDay = TuiDay.normalizeParse(rangeString.slice(0, DATE_FILLER_LENGTH), dateMode);
            if (rangeString.length < DATE_RANGE_FILLER_LENGTH) {
                return new TuiDayRange(leftDay, leftDay);
            }
            return TuiDayRange.sort(leftDay, TuiDay.normalizeParse(rangeString.slice(DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length), dateMode));
        };
        Object.defineProperty(TuiDayRange.prototype, "isSingleDay", {
            get: function () {
                return this.from.daySame(this.to);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Tests ranges for identity
         *
         * @param another second range to test against current
         * @return `true` if days are identical
         */
        TuiDayRange.prototype.daySame = function (another) {
            return this.from.daySame(another.from) && this.to.daySame(another.to);
        };
        /**
         * Locks range between two days included, or limits from one side if the other is null
         *
         * @param min
         * @param max
         * @return range — clamped range
         */
        TuiDayRange.prototype.dayLimit = function (min, max) {
            return new TuiDayRange(this.from.dayLimit(min, max), this.to.dayLimit(min, max));
        };
        /**
         * Human readable format.
         */
        TuiDayRange.prototype.getFormattedDayRange = function (dateFormat, dateSeparator) {
            var from = this.from.getFormattedDay(dateFormat, dateSeparator);
            var to = this.to.getFormattedDay(dateFormat, dateSeparator);
            return "" + from + RANGE_SEPARATOR_CHAR + to;
        };
        TuiDayRange.prototype.toString = function (dateFormat, dateSeparator) {
            if (dateFormat === void 0) { dateFormat = "DMY"; }
            if (dateSeparator === void 0) { dateSeparator = "."; }
            var from = this.from.getFormattedDay(dateFormat, dateSeparator);
            var to = this.to.getFormattedDay(dateFormat, dateSeparator);
            return "" + from + RANGE_SEPARATOR_CHAR + to;
        };
        return TuiDayRange;
    }(TuiMonthRange));

    var TUI_FIRST_DAY = new TuiDay(MIN_YEAR, MIN_MONTH, MIN_DAY);
    var TUI_LAST_DAY = new TuiDay(MAX_YEAR, MAX_MONTH, 31);

    /**
     * Immutable time object with hours, minutes, seconds and ms
     */
    var TuiTime = /** @class */ (function () {
        function TuiTime(hours, minutes, seconds, ms) {
            if (seconds === void 0) { seconds = 0; }
            if (ms === void 0) { ms = 0; }
            this.hours = hours;
            this.minutes = minutes;
            this.seconds = seconds;
            this.ms = ms;
            ngDevMode &&
                classes.tuiAssert.assert(TuiTime.isValidTime(hours, minutes, seconds, ms), "Time must be real, but got:", hours, minutes, seconds, ms);
        }
        /**
         * Checks if time is valid
         */
        TuiTime.isValidTime = function (hours, minutes, seconds, ms) {
            if (seconds === void 0) { seconds = 0; }
            if (ms === void 0) { ms = 0; }
            return (Number.isInteger(hours) &&
                math.tuiInRange(hours, 0, HOURS_IN_DAY) &&
                Number.isInteger(minutes) &&
                math.tuiInRange(minutes, 0, MINUTES_IN_HOUR) &&
                Number.isInteger(seconds) &&
                math.tuiInRange(seconds, 0, SECONDS_IN_MINUTE) &&
                Number.isInteger(ms) &&
                math.tuiInRange(ms, 0, 1000));
        };
        /**
         * Current UTC time.
         */
        TuiTime.current = function () {
            return TuiTime.fromAbsoluteMilliseconds(Date.now() % MILLISECONDS_IN_DAY);
        };
        /**
         * Current time in local timezone
         */
        TuiTime.currentLocal = function () {
            var date = new Date();
            return TuiTime.fromAbsoluteMilliseconds((Date.now() - date.getTimezoneOffset() * MILLISECONDS_IN_MINUTE) %
                MILLISECONDS_IN_DAY);
        };
        /**
         * Calculates TuiTime from milliseconds
         */
        TuiTime.fromAbsoluteMilliseconds = function (milliseconds) {
            ngDevMode && classes.tuiAssert.assert(Number.isInteger(milliseconds));
            ngDevMode &&
                classes.tuiAssert.assert(math.tuiInRange(milliseconds, 0, MILLISECONDS_IN_DAY), "Milliseconds must be below " + MILLISECONDS_IN_DAY + " (milliseconds in a day).");
            var hours = Math.floor(milliseconds / MILLISECONDS_IN_HOUR);
            var minutes = Math.floor((milliseconds % MILLISECONDS_IN_HOUR) / MILLISECONDS_IN_MINUTE);
            var seconds = Math.floor(((milliseconds % MILLISECONDS_IN_HOUR) % MILLISECONDS_IN_MINUTE) / 1000) || 0;
            var ms = Math.floor(((milliseconds % MILLISECONDS_IN_HOUR) % MILLISECONDS_IN_MINUTE) % 1000) || 0;
            return new TuiTime(hours, minutes, seconds, ms);
        };
        /**
         * Parses string into TuiTime object
         */
        TuiTime.fromString = function (time) {
            var hours = Number(time.slice(0, 2));
            var minutes = Number(time.slice(3, 5));
            var seconds = Number(time.slice(6, 8)) || 0;
            var ms = Number(time.slice(9, 12)) || 0;
            return new TuiTime(hours, minutes, seconds, ms);
        };
        /**
         * Converts Date object into TuiTime
         * @param date
         */
        TuiTime.fromLocalNativeDate = function (date) {
            return new TuiTime(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        };
        /**
         * Shifts time by hours and minutes
         */
        TuiTime.prototype.shift = function (_a) {
            var _b = _a.hours, hours = _b === void 0 ? 0 : _b, _c = _a.minutes, minutes = _c === void 0 ? 0 : _c, _d = _a.seconds, seconds = _d === void 0 ? 0 : _d, _e = _a.ms, ms = _e === void 0 ? 0 : _e;
            var newMs = (1000 + this.ms + (ms % 1000)) % 1000;
            var secondsInMs = ms < 0 ? Math.ceil(ms / 1000) : Math.floor(ms / 1000);
            var secondsToAdd = secondsInMs + seconds;
            var newSeconds = (60 + this.seconds + (secondsToAdd % 60)) % 60;
            var minutesInSeconds = secondsToAdd < 0
                ? Math.ceil(secondsToAdd / 60)
                : Math.floor(secondsToAdd / 60);
            var minutesToAdd = minutesInSeconds + minutes;
            var newMinutes = (60 + this.minutes + (minutesToAdd % 60)) % 60;
            var hoursInMinutes = minutesToAdd < 0
                ? Math.ceil(minutesToAdd / 60)
                : Math.floor(minutesToAdd / 60);
            var hoursToAdd = hoursInMinutes + hours;
            var newHours = (24 + this.hours + (hoursToAdd % 24)) % 24;
            return new TuiTime(newHours, newMinutes, newSeconds, newMs);
        };
        /**
         * Converts TuiTime to string
         */
        TuiTime.prototype.toString = function (mode) {
            var needAddMs = mode === "HH:MM:SS.MSS" || (!mode && this.ms > 0);
            var needAddSeconds = needAddMs || mode === "HH:MM:SS" || (!mode && this.seconds > 0);
            return (this.formatTime(this.hours) + ":" + this.formatTime(this.minutes) +
                ("" + (needAddSeconds ? ":" + this.formatTime(this.seconds) : "")) +
                ("" + (needAddMs ? "." + this.formatTime(this.ms, 3) : "")));
        };
        TuiTime.prototype.valueOf = function () {
            return this.toAbsoluteMilliseconds();
        };
        /**
         * Returns the primitive value of the given Date object.
         * Depending on the argument, the method can return either a string or a number.
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/@@toPrimitive
         */
        TuiTime.prototype[Symbol.toPrimitive] = function (hint) {
            return Date.prototype[Symbol.toPrimitive].call(this, hint);
        };
        /**
         * Converts TuiTime to milliseconds
         */
        TuiTime.prototype.toAbsoluteMilliseconds = function () {
            return (this.hours * MILLISECONDS_IN_HOUR +
                this.minutes * MILLISECONDS_IN_MINUTE +
                this.seconds * 1000 +
                this.ms);
        };
        TuiTime.prototype.formatTime = function (time, digits) {
            if (digits === void 0) { digits = 2; }
            return String(time).padStart(digits, "0");
        };
        return TuiTime;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.DATE_FILLER_LENGTH = DATE_FILLER_LENGTH;
    exports.DATE_RANGE_FILLER_LENGTH = DATE_RANGE_FILLER_LENGTH;
    exports.DAYS_IN_LEAP_YEAR = DAYS_IN_LEAP_YEAR;
    exports.DAYS_IN_NORMAL_YEAR = DAYS_IN_NORMAL_YEAR;
    exports.DAYS_IN_WEEK = DAYS_IN_WEEK;
    exports.HOURS_IN_DAY = HOURS_IN_DAY;
    exports.MAX_MONTH = MAX_MONTH;
    exports.MAX_YEAR = MAX_YEAR;
    exports.MILLISECONDS_IN_DAY = MILLISECONDS_IN_DAY;
    exports.MILLISECONDS_IN_HOUR = MILLISECONDS_IN_HOUR;
    exports.MILLISECONDS_IN_MINUTE = MILLISECONDS_IN_MINUTE;
    exports.MILLISECONDS_IN_SECOND = MILLISECONDS_IN_SECOND;
    exports.MINUTES_IN_HOUR = MINUTES_IN_HOUR;
    exports.MIN_DAY = MIN_DAY;
    exports.MIN_MONTH = MIN_MONTH;
    exports.MIN_YEAR = MIN_YEAR;
    exports.MONTHS_IN_YEAR = MONTHS_IN_YEAR;
    exports.RANGE_SEPARATOR_CHAR = RANGE_SEPARATOR_CHAR;
    exports.SECONDS_IN_MINUTE = SECONDS_IN_MINUTE;
    exports.TUI_DATE_FORMAT = TUI_DATE_FORMAT;
    exports.TUI_DATE_SEPARATOR = TUI_DATE_SEPARATOR;
    exports.TUI_FIRST_DAY = TUI_FIRST_DAY;
    exports.TUI_LAST_DAY = TUI_LAST_DAY;
    exports.TuiDay = TuiDay;
    exports.TuiDayRange = TuiDayRange;
    exports.TuiMonth = TuiMonth;
    exports.TuiMonthRange = TuiMonthRange;
    exports.TuiTime = TuiTime;
    exports.TuiYear = TuiYear;
    exports.changeDateSeparator = changeDateSeparator;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=taiga-ui-cdk-date-time.umd.js.map
