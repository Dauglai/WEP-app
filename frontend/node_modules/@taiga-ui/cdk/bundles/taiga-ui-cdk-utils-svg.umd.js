(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taiga-ui/cdk/utils/miscellaneous')) :
    typeof define === 'function' && define.amd ? define('@taiga-ui/cdk/utils/svg', ['exports', '@taiga-ui/cdk/utils/miscellaneous'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global["taiga-ui"] = global["taiga-ui"] || {}, global["taiga-ui"].cdk = global["taiga-ui"].cdk || {}, global["taiga-ui"].cdk.utils = global["taiga-ui"].cdk.utils || {}, global["taiga-ui"].cdk.utils.svg = {}), global["taiga-ui"].cdk.utils.miscellaneous));
})(this, (function (exports, miscellaneous) { 'use strict';

    /**
     * @description:
     * Any ‘linearGradient’ attributes which are defined on the referenced
     * element which are not defined on this element are inherited by this element.
     * If this element has no defined gradient stops, and the referenced element does
     * (possibly due to its own ‘xlink:href’ attribute), then this element inherits
     * the gradient stop from the referenced element. Inheritance can be indirect
     * to an arbitrary level; thus, if the referenced element inherits attribute
     * or gradient stops due to its own ‘xlink:href’ attribute, then the current
     * element can inherit those attributes or gradient stops.
     *
     * Documentation: https://www.w3.org/TR/SVG11/pservers.html
     *
     */
    function tuiSvgLinearGradientProcessor(svg, salt) {
        if (miscellaneous.tuiIsString(svg)) {
            var uniqueIds = extractLinearGradientIdsFromSvg(svg);
            return uniqueIds.reduce(function (newSvg, previousId) {
                var escapedId = escapeRegExp(previousId);
                var newId = previousId + "_" + (salt || makeRandomSalt());
                return newSvg
                    .replace(new RegExp("\"" + escapedId + "\"", "g"), "\"" + newId + "\"")
                    .replace(new RegExp("'" + escapedId + "'", "g"), "'" + newId + "'")
                    .replace(new RegExp("url\\('#" + escapedId + "'\\)", "g"), "url('#" + newId + "')")
                    .replace(new RegExp("url\\(\"#" + escapedId + "\"\\)", "g"), "url(\"#" + newId + "\")")
                    .replace(new RegExp("url\\(#" + escapedId + "\\)", "g"), "url(#" + newId + ")");
            }, svg);
        }
        return svg;
    }
    function makeRandomSalt() {
        return Math.floor(Math.random() * Date.now());
    }
    function escapeRegExp(search) {
        return search.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
    function extractLinearGradientIdsFromSvg(svg) {
        var _a;
        var ids = ((_a = svg.match(/url\(("?)('*)#(.*?)('*)\)/g)) !== null && _a !== void 0 ? _a : []).map(function (url) { return url.slice(4, url.length - 1).replace(/['"#]+/g, ""); });
        return Array.from(new Set(ids));
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.tuiSvgLinearGradientProcessor = tuiSvgLinearGradientProcessor;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=taiga-ui-cdk-utils-svg.umd.js.map
