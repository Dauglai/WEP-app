"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dateTimeMigrations = void 0;
const ng_morph_1 = require("ng-morph");
const perf_hooks_1 = require("perf_hooks");
const colored_log_1 = require("../../../utils/colored-log");
const get_execution_time_1 = require("../../../utils/get-execution-time");
const get_named_import_references_1 = require("../../../utils/get-named-import-references");
const insert_todo_1 = require("../../../utils/insert-todo");
function dateTimeMigrations(options) {
    !options[`skip-logs`] &&
        colored_log_1.infoLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.REPLACE_SYMBOL} migrating taiga date/time...`);
    let start = perf_hooks_1.performance.now();
    migrateProperty({
        namedImport: `TuiDay`,
        moduleSpecifier: `@taiga-ui/cdk`,
        from: `formattedDay`,
        callback: node => node.replaceWithText(node.getText().replace(`formattedDay`, `getFormattedDay("DMY", ".")`)),
    });
    !options[`skip-logs`] &&
        colored_log_1.processLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.PROCESSING_SYMBOL}TuiDay.formattedDay ` +
            `(${get_execution_time_1.getExecutionTime(start, perf_hooks_1.performance.now())})`);
    start = perf_hooks_1.performance.now();
    migrateProperty({
        namedImport: `TuiDayRange`,
        moduleSpecifier: `@taiga-ui/cdk`,
        from: `formattedDayRange`,
        callback: node => node.replaceWithText(node
            .getText()
            .replace(`formattedDayRange`, `getFormattedDayRange("DMY", ".")`)),
    });
    !options[`skip-logs`] &&
        colored_log_1.processLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.PROCESSING_SYMBOL}TuiDayRange.formattedDayRange ` +
            `(${get_execution_time_1.getExecutionTime(start, perf_hooks_1.performance.now())})`);
    start = perf_hooks_1.performance.now();
    migrateProperty({
        namedImport: `TuiDayRange`,
        moduleSpecifier: `@taiga-ui/cdk`,
        from: `normalizeParse`,
        callback: node => {
            const parent = node.getParent();
            if (ng_morph_1.Node.isCallExpression(parent)) {
                changeNormalizeArgs(parent);
            }
        },
    });
    !options[`skip-logs`] &&
        colored_log_1.processLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.PROCESSING_SYMBOL}TuiDayRange.normalizeParse ` +
            `(${get_execution_time_1.getExecutionTime(start, perf_hooks_1.performance.now())})`);
    [
        {
            namedImport: `TuiMonthRange`,
            field: `formattedMonthRange`,
            message: `formattedMonthRange has been removed in 3.0. Please use TUI_MONTH_FORMATTER from @taiga-ui/kit`,
        },
        {
            namedImport: `TuiMonth`,
            field: `formattedMonth`,
            message: `formattedMonth has been removed in 3.0. Please use TUI_MONTH_FORMATTER from @taiga-ui/kit`,
        },
        {
            namedImport: `TuiDay`,
            field: `getDayFromMonthRowCol`,
            message: `getDayFromMonthRowCol has been removed in 3.0. If you need this utils check out this pipe https://github.com/Tinkoff/taiga-ui/tree/main/projects/core/pipes/calendar-sheet`,
        },
        {
            namedImport: `TuiMonth`,
            field: `monthStartDaysOffset`,
            message: `monthStartDaysOffset has been removed in 3.0. If you need this utils check out this pipe https://github.com/Tinkoff/taiga-ui/tree/main/projects/core/pipes/calendar-sheet`,
        },
        {
            namedImport: `TuiMonth`,
            field: `weeksRowsCount`,
            message: `weeksRowsCount has been removed in 3.0. If you need this utils check out this pipe https://github.com/Tinkoff/taiga-ui/tree/main/projects/core/pipes/calendar-sheet`,
        },
        {
            namedImport: `TuiYear`,
            field: `getYearStartDaysOffset`,
            message: `getYearStartDaysOffset has been removed in 3.0. If you need this utils check out this pipe https://github.com/Tinkoff/taiga-ui/tree/main/projects/core/pipes/calendar-sheet`,
        },
        {
            namedImport: `TuiYear`,
            field: `weeksRowsCount`,
            message: `weeksRowsCount has been removed in 3.0. If you need this utils check out this pipe https://github.com/Tinkoff/taiga-ui/tree/main/projects/core/pipes/calendar-sheet`,
        },
    ].forEach(({ namedImport, field, message }) => {
        start = perf_hooks_1.performance.now();
        migrateProperty({
            namedImport,
            moduleSpecifier: `@taiga-ui/cdk`,
            from: field,
            callback: node => insertTodoBeforeNode(node, message),
        });
        !options[`skip-logs`] &&
            colored_log_1.processLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.PROCESSING_SYMBOL}${namedImport}.${field} ` +
                `(${get_execution_time_1.getExecutionTime(start, perf_hooks_1.performance.now())})`);
    });
    !options[`skip-logs`] &&
        colored_log_1.successLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.SUCCESS_SYMBOL} date/time migrated \n`);
}
exports.dateTimeMigrations = dateTimeMigrations;
function migrateProperty({ namedImport, moduleSpecifier, from, callback, }) {
    const references = get_named_import_references_1.getNamedImportReferences(namedImport, moduleSpecifier);
    references.forEach(ref => {
        if (ref.wasForgotten()) {
            return;
        }
        const parent = ref.getParent();
        if (!parent) {
            return;
        }
        if (ng_morph_1.Node.isNewExpression(parent)) {
            const accessExpression = parent.getFirstAncestorByKind(ng_morph_1.SyntaxKind.PropertyAccessExpression);
            const searched = accessExpression === null || accessExpression === void 0 ? void 0 : accessExpression.getChildrenOfKind(ng_morph_1.SyntaxKind.Identifier).find(identifier => identifier.getText() === from);
            if (searched && accessExpression) {
                callback(accessExpression);
                return;
            }
        }
        if (ng_morph_1.Node.isPropertyAccessExpression(parent)) {
            const searched = parent
                .getChildrenOfKind(ng_morph_1.SyntaxKind.Identifier)
                .find(identifier => identifier.getText() === from);
            if (searched && !parent.wasForgotten()) {
                callback(parent);
                return;
            }
        }
        replaceIdentifier(parent, from, callback);
    });
}
function replaceIdentifier(node, from, callback) {
    const declaration = node.getFirstAncestorByKind(ng_morph_1.SyntaxKind.VariableDeclaration) ||
        node.getFirstAncestorByKind(ng_morph_1.SyntaxKind.PropertyDeclaration);
    const identifier = declaration === null || declaration === void 0 ? void 0 : declaration.getFirstDescendantByKind(ng_morph_1.SyntaxKind.Identifier);
    if (identifier) {
        replaceIdentifierReferences(identifier, from, callback);
    }
}
function replaceIdentifierReferences(identifier, from, callback) {
    identifier
        .findReferencesAsNodes()
        /**
         * `findReferencesAsNodes` has strange behavior.
         * Imagine schematics run on the following file:
         * ```
         * class Dummy {
         *  var = 5;
         *  method1() {
         *      const {var} = this; // (1)
         *      return var; // (2)
         *  }
         *  method2() {
         *      const {var} = this; // (3)
         *  }
         * }
         * ```
         * If `identifier` is equal to `var` from `method1` (1),
         * then `identifier.findReferencesAsNodes` will return array with 2 references: (2) and (3).
         */
        .filter(ref => !areBothObjectDestructuring(ref, identifier))
        .forEach(ref => {
        if (ref.wasForgotten()) {
            return;
        }
        let parent = ref.getParent();
        if ((parent === null || parent === void 0 ? void 0 : parent.getText()) === `this.${identifier.getText()}` ||
            (parent === null || parent === void 0 ? void 0 : parent.getText()) === identifier.getText()) {
            replaceIdentifier(parent, from, callback);
        }
        if (parent === null || parent === void 0 ? void 0 : parent.wasForgotten()) {
            return;
        }
        if (parent === null || parent === void 0 ? void 0 : parent.getText().startsWith(`this`)) {
            parent = parent === null || parent === void 0 ? void 0 : parent.getParent();
        }
        if (ng_morph_1.Node.isPropertyAccessExpression(parent)) {
            const searched = parent
                .getChildrenOfKind(ng_morph_1.SyntaxKind.Identifier)
                .find(identifier => identifier.getText() === from);
            if (searched) {
                callback(parent);
            }
        }
    });
}
function changeNormalizeArgs(node) {
    const args = node.getArguments();
    if (args.length > 2) {
        node.removeArgument(2);
        node.removeArgument(1);
        node.addArgument(`"DMY"`);
    }
    else if (args.length === 1) {
        node.addArgument(`"DMY"`);
    }
}
function insertTodoBeforeNode(node, message) {
    const identifier = node.getFirstDescendantByKind(ng_morph_1.SyntaxKind.Identifier);
    if (identifier) {
        insert_todo_1.insertTodo(identifier, message);
    }
}
function areBothObjectDestructuring(ref, identifier) {
    return Boolean(identifier.getFirstAncestorByKind(ng_morph_1.SyntaxKind.BindingElement) &&
        ref.getFirstAncestorByKind(ng_morph_1.SyntaxKind.BindingElement));
}
