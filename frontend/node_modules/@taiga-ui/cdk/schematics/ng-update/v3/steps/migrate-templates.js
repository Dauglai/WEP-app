"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateTemplates = void 0;
const ng_morph_1 = require("ng-morph");
const constants_1 = require("../../../constants");
const add_import_to_closest_module_1 = require("../../../utils/add-import-to-closest-module");
const add_unique_import_1 = require("../../../utils/add-unique-import");
const ng_component_1 = require("../../../utils/angular/ng-component");
const colored_log_1 = require("../../../utils/colored-log");
const insert_todo_1 = require("../../../utils/insert-todo");
const progress_1 = require("../../../utils/progress");
const replace_tag_1 = require("../../../utils/replace-tag");
const elements_1 = require("../../../utils/templates/elements");
const get_component_templates_1 = require("../../../utils/templates/get-component-templates");
const ng_component_input_manipulations_1 = require("../../../utils/templates/ng-component-input-manipulations");
const template_resource_1 = require("../../../utils/templates/template-resource");
const templates_1 = require("../constants/templates");
const migrate_polymorpheus_1 = require("./migrate-polymorpheus");
const migrate_textfield_controller_1 = require("./migrate-textfield-controller");
function migrateTemplates(fileSystem, options) {
    !options[`skip-logs`] &&
        colored_log_1.infoLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.REPLACE_SYMBOL} migrating templates...`);
    const componentWithTemplatesPaths = get_component_templates_1.getComponentTemplates(constants_1.ALL_TS_FILES);
    const actions = [
        replaceTags,
        replaceAttrs,
        replaceAttrsByDirective,
        replaceBreadcrumbs,
        replaceFieldError,
        addHTMLCommentTags,
        addEditorProviders,
        migrateTuiHideSelectedPipe,
        removeInputs,
        migrate_polymorpheus_1.migratePolymorpheus,
        migrate_textfield_controller_1.migrateTextfieldController,
        replaceInputValues,
        migrateBinaryAttributes,
        addWarningForFormatNumberPipe,
    ];
    const progressLog = progress_1.setupProgressLogger({
        total: componentWithTemplatesPaths.length,
    });
    componentWithTemplatesPaths.forEach(resource => {
        const path = fileSystem.resolve(template_resource_1.getPathFromTemplateResource(resource));
        const recorder = fileSystem.edit(path);
        actions.forEach((action, actionIndex) => {
            const isLastAction = actionIndex === actions.length - 1;
            !options[`skip-logs`] && progressLog(action.name, isLastAction);
            action({ resource, fileSystem, recorder });
        });
    });
    !options[`skip-logs`] &&
        colored_log_1.successLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.SUCCESS_SYMBOL} templates migrated \n`);
}
exports.migrateTemplates = migrateTemplates;
function replaceAttrsByDirective({ resource, fileSystem, }) {
    templates_1.ATTR_TO_DIRECTIVE.forEach(({ componentSelector, directiveModule, directive, inputProperty, filterFn }) => {
        ng_component_input_manipulations_1.replaceInputPropertyByDirective({
            componentSelector,
            directiveModule,
            directive,
            inputProperty,
            fileSystem,
            templateResource: resource,
            filterFn,
        });
    });
}
function replaceAttrs({ resource, recorder, fileSystem, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    templates_1.ATTRS_TO_REPLACE.forEach(({ from, to }) => {
        const offsets = [
            ...elements_1.findAttributeOnElementWithTag(template, from.attrName, from.withTagNames || [], from.filterFn),
            ...elements_1.findAttributeOnElementWithAttrs(template, from.attrName, from.withAttrsNames || [], from.filterFn),
        ];
        offsets.forEach(offset => {
            recorder.remove(offset + templateOffset, from.attrName.length);
            recorder.insertRight(offset + templateOffset, to.attrName);
        });
    });
}
function replaceTags({ resource, recorder, fileSystem, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    templates_1.TAGS_TO_REPLACE.forEach(({ from, to, addAttributes }) => {
        const elements = elements_1.findElementsByTagName(template, from);
        elements.forEach(({ sourceCodeLocation }) => {
            if (sourceCodeLocation) {
                replace_tag_1.replaceTag(recorder, sourceCodeLocation, from, to, templateOffset, addAttributes);
            }
        });
    });
}
function addHTMLCommentTags({ resource, recorder, fileSystem, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    templates_1.TEMPLATE_COMMENTS.forEach(({ comment, tag, withAttr }) => {
        const elementStartOffsets = [
            ...elements_1.findElementsWithAttribute(template, withAttr),
            ...elements_1.findElementsWithAttribute(template, `[${withAttr}]`),
        ]
            .filter(el => el.tagName === tag)
            .map(el => { var _a; return (((_a = el.sourceCodeLocation) === null || _a === void 0 ? void 0 : _a.startOffset) || 0) + templateOffset; });
        elementStartOffsets.forEach(offset => {
            recorder.insertRight(offset, `<!-- ${insert_todo_1.TODO_MARK} ${comment} -->\n`);
        });
    });
}
function replaceBreadcrumbs({ resource, recorder, fileSystem, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    const elements = elements_1.findElementsByTagName(template, `tui-breadcrumbs`);
    elements.forEach(element => {
        var _a, _b, _c;
        const itemsAttr = element.attrs.find(attr => attr.name === `[items]`);
        const itemsValue = itemsAttr === null || itemsAttr === void 0 ? void 0 : itemsAttr.value;
        const insertTo = (_a = element === null || element === void 0 ? void 0 : element.sourceCodeLocation) === null || _a === void 0 ? void 0 : _a.startTag.endOffset;
        if (!itemsValue || !insertTo) {
            return;
        }
        recorder.insertRight(insertTo + templateOffset, `
    <ng-container *ngFor="let item of ${itemsValue}">
        <a
            *tuiItem
            tuiLink
            [routerLink]="item.routerLink"
        >
            {{ item.caption }}
        </a>
    </ng-container>`);
        const { startOffset = 0, endOffset = 0 } = ((_c = (_b = element.sourceCodeLocation) === null || _b === void 0 ? void 0 : _b.attrs) === null || _c === void 0 ? void 0 : _c[`[items]`]) || {};
        recorder.remove(templateOffset + startOffset - 1, endOffset - startOffset + 1);
    });
}
function replaceFieldError({ resource, recorder, fileSystem, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    const elements = elements_1.findElementsByTagName(template, `tui-field-error`);
    elements.forEach(element => {
        var _a, _b;
        const orderAttr = element.attrs.find(attr => attr.name === `[order]`);
        const orderVal = orderAttr === null || orderAttr === void 0 ? void 0 : orderAttr.value;
        if (orderAttr) {
            const { startOffset = 0, endOffset = 0 } = ((_b = (_a = element.sourceCodeLocation) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b[`[order]`]) || {};
            recorder.remove(templateOffset + startOffset - 1, endOffset - startOffset + 1);
        }
        const input = `[error]="${orderVal !== null && orderVal !== void 0 ? orderVal : `[]`} | tuiFieldError | async"`;
        replace_tag_1.replaceTag(recorder, element.sourceCodeLocation, `tui-field-error`, `tui-error`, templateOffset, [input]);
    });
    if (elements.length) {
        add_import_to_closest_module_1.addImportToClosestModule(resource.componentPath, `TuiErrorModule`, `@taiga-ui/core`);
    }
}
function addEditorProviders({ resource, fileSystem, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const elements = elements_1.findElementsByTagName(template, `tui-editor`).filter(element => !elements_1.hasElementAttribute(element, `new`));
    if (elements.length) {
        const componentPath = resource.componentPath;
        const componentClass = ng_component_1.getNgComponents(componentPath);
        ng_morph_1.addProviderToComponent(componentClass[0], `{
            provide: TUI_EDITOR_EXTENSIONS,
            useValue: defaultEditorExtensions
        }`, { unique: true });
        add_unique_import_1.addUniqueImport(componentPath, `TUI_EDITOR_EXTENSIONS`, `@taiga-ui/addon-editor`);
        add_unique_import_1.addUniqueImport(componentPath, `defaultEditorExtensions`, `@taiga-ui/addon-editor`);
    }
}
// eslint-disable-next-line unicorn/no-unsafe-regex
const HIDE_SELECTED_PIPE_WITH_ARGS_REG = /\|\s*tuiHideSelected(\s*:\s*[^|'"]*)?/gi;
function migrateTuiHideSelectedPipe({ resource, fileSystem, recorder, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    const elementsWithPipe = elements_1.findElementsInTemplateByFn(template, el => { var _a; return (_a = el.attrs) === null || _a === void 0 ? void 0 : _a.some(attr => attr.value.match(HIDE_SELECTED_PIPE_WITH_ARGS_REG)); });
    elementsWithPipe.forEach(el => {
        var _a;
        const { name, value: oldValue } = el.attrs.find(attr => attr.value.match(HIDE_SELECTED_PIPE_WITH_ARGS_REG)) ||
            {};
        const attrLocations = (_a = el.sourceCodeLocation) === null || _a === void 0 ? void 0 : _a.attrs;
        if (!name || !oldValue || !attrLocations) {
            return;
        }
        const newValue = oldValue.replace(HIDE_SELECTED_PIPE_WITH_ARGS_REG, `| tuiHideSelected`);
        const { startOffset } = attrLocations[name];
        const valueOffset = templateOffset + startOffset + name.length + `="`.length;
        recorder.remove(valueOffset, oldValue.length);
        recorder.insertRight(valueOffset, newValue);
    });
}
function migrateBinaryAttributes({ resource, fileSystem, recorder, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    templates_1.TRUTHY_BOOLEAN_INPUT_TO_HTML_BINARY_ATTRIBUTE.forEach(attrName => {
        const elements = elements_1.findElementsInTemplateByFn(template, el => {
            var _a;
            return (_a = el.attrs) === null || _a === void 0 ? void 0 : _a.some(attr => attr.value === `true` && attr.name.includes(attrName.toLowerCase()));
        });
        elements.forEach(el => {
            var _a;
            const attrLocations = (_a = el.sourceCodeLocation) === null || _a === void 0 ? void 0 : _a.attrs;
            if (!attrLocations) {
                return;
            }
            const { startOffset, endOffset } = attrLocations[`[${attrName.toLowerCase()}]`] ||
                attrLocations[attrName.toLowerCase()];
            recorder.remove(templateOffset + startOffset, endOffset - startOffset);
            recorder.insertRight(templateOffset + startOffset, attrName);
        });
    });
}
function addWarningForFormatNumberPipe({ resource, fileSystem, recorder, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    if (template.match(/\|\s*tuiFormatNumber\s*:\s/gi)) {
        recorder.insertLeft(templateOffset && templateOffset + 1, `<!-- ${insert_todo_1.TODO_MARK} tuiFormatNumber pipe has new API. See https://taiga-ui.dev/pipes/format-number -->`);
    }
}
function replaceInputValues({ resource, recorder, fileSystem, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    // eslint-disable-next-line @typescript-eslint/naming-convention
    const ATTR_VALUES = [
        {
            attrName: `tuiHintDirection`,
            values: [
                { from: `bottom-middle`, to: `bottom` },
                { from: `top-middle`, to: `top` },
            ],
        },
    ];
    ATTR_VALUES.forEach(({ attrName, values }) => {
        const elements = [...elements_1.findElementsWithAttribute(template, attrName)];
        elements.forEach(element => {
            const { name, value } = element.attrs.find(attr => attr.name === attrName.toLowerCase()) || {};
            if (!name || !value) {
                return;
            }
            values.forEach(({ from, to }) => {
                var _a, _b;
                if (value === from) {
                    const { startOffset, endOffset } = ((_b = (_a = element.sourceCodeLocation) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b[name]) || { startOffset: 0, endOffset: 0 };
                    recorder.remove(templateOffset + startOffset, endOffset - startOffset);
                    recorder.insertRight(templateOffset + startOffset, `${attrName}="${to}"`);
                }
            });
        });
    });
}
function removeInputs({ resource, fileSystem, recorder, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    templates_1.INPUTS_TO_REMOVE.forEach(({ inputName, tags }) => {
        const offsets = [
            ...ng_component_input_manipulations_1.getInputPropertyOffsets(template, inputName, tags),
            ...ng_component_input_manipulations_1.getInputPropertyOffsets(template, `[${inputName}]`, tags),
        ];
        offsets.forEach(([start, end]) => {
            recorder.remove(start + templateOffset, end - start);
        });
    });
}
