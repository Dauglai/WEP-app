"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceFunctions = void 0;
const ng_morph_1 = require("ng-morph");
const colored_log_1 = require("../../../utils/colored-log");
const get_named_import_references_1 = require("../../../utils/get-named-import-references");
const import_manipulations_1 = require("../../../utils/import-manipulations");
const deprecated_functions_1 = require("../constants/deprecated-functions");
function replaceFunctions(options) {
    !options[`skip-logs`] &&
        colored_log_1.infoLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.REPLACE_SYMBOL} functions replacing...`);
    replacePadStart(get_named_import_references_1.getNamedImportReferences(`padStart`, `@taiga-ui/cdk`));
    replaceFallbackValue(get_named_import_references_1.getNamedImportReferences(`fallbackValue`, `@taiga-ui/cdk`));
    replaceCustomEvent(get_named_import_references_1.getNamedImportReferences(`tuiCustomEvent`, `@taiga-ui/cdk`));
    replaceClosestElement(get_named_import_references_1.getNamedImportReferences(`getClosestElement`, `@taiga-ui/cdk`));
    replaceNativeFocused([
        ...get_named_import_references_1.getNamedImportReferences(`tuiSetNativeFocused`, `@taiga-ui/cdk`),
        ...get_named_import_references_1.getNamedImportReferences(`setNativeFocused`, `@taiga-ui/cdk`),
    ]);
    replaceDeprecatedFunction();
    modifyFormatNumberArgs();
    modifyClosestFocusable();
    !options[`skip-logs`] &&
        colored_log_1.successLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.SUCCESS_SYMBOL} functions replaced \n`);
}
exports.replaceFunctions = replaceFunctions;
function replaceDeprecatedFunction() {
    deprecated_functions_1.DEPRECATED_FUNCTIONS.forEach(({ from, to, moduleSpecifier }) => {
        get_named_import_references_1.getNamedImportReferences(from, moduleSpecifier).forEach(ref => {
            if (ref.wasForgotten()) {
                return;
            }
            const parent = ref.getParent();
            if (ng_morph_1.Node.isImportSpecifier(parent) || ng_morph_1.Node.isCallExpression(parent)) {
                parent === null || parent === void 0 ? void 0 : parent.replaceWithText(parent === null || parent === void 0 ? void 0 : parent.getText({ includeJsDocComments: false }).trim().replace(from, to !== null && to !== void 0 ? to : from));
            }
        });
    });
}
function replacePadStart(references) {
    references.forEach(ref => {
        var _a;
        const parent = ref.getParent();
        if (ng_morph_1.Node.isImportSpecifier(parent)) {
            import_manipulations_1.removeImport(parent);
        }
        else if (ng_morph_1.Node.isCallExpression(parent)) {
            const [targetString, length, pad] = parent.getArguments();
            parent.replaceWithText(`${targetString.getText()}.padStart(${length.getText()}, ${(_a = pad === null || pad === void 0 ? void 0 : pad.getText()) !== null && _a !== void 0 ? _a : `" "`})`);
        }
    });
}
function replaceNativeFocused(references) {
    references.forEach(ref => {
        const parent = ref.getParent();
        if (ng_morph_1.Node.isImportSpecifier(parent)) {
            import_manipulations_1.removeImport(parent);
        }
        else if (ng_morph_1.Node.isCallExpression(parent)) {
            const [targetString, focusedArg, preventScroll] = parent.getArguments();
            const setFocused = !focusedArg || focusedArg.getText() === `true`;
            const focus = `${targetString.getText()}.focus(${(preventScroll === null || preventScroll === void 0 ? void 0 : preventScroll.getText()) ? `{preventScroll: true}` : ``})`;
            const blur = `${targetString.getText()}.blur()`;
            parent.replaceWithText(setFocused ? focus : blur);
        }
    });
}
function replaceClosestElement(references) {
    references.forEach(ref => {
        const parent = ref.getParent();
        if (ng_morph_1.Node.isImportSpecifier(parent)) {
            import_manipulations_1.removeImport(parent);
        }
        else if (ng_morph_1.Node.isCallExpression(parent)) {
            const [firstArg, secondArg] = parent.getArguments();
            const firstArgText = firstArg.getText();
            const element = firstArgText.includes(` as `) // e.g, `getClosestElement(el as Element, ...)`
                ? `(${firstArgText})`
                : firstArgText;
            parent.replaceWithText(`${element}.closest(${secondArg.getText()})`);
        }
    });
}
function replaceCustomEvent(references) {
    references.forEach(ref => {
        const parent = ref.getParent();
        if (ng_morph_1.Node.isImportSpecifier(parent)) {
            import_manipulations_1.removeImport(parent);
        }
        else if (ng_morph_1.Node.isCallExpression(parent)) {
            const [firstArg, secondArg] = parent.getArguments();
            parent.replaceWithText(`new CustomEvent(${firstArg.getText()}, ${secondArg.getText()})`);
        }
    });
}
function replaceFallbackValue(references) {
    references.forEach(ref => {
        const parent = ref.getParent();
        if (ng_morph_1.Node.isImportSpecifier(parent)) {
            import_manipulations_1.removeImport(parent);
        }
        else if (ng_morph_1.Node.isCallExpression(parent)) {
            const [firstArg, secondArg] = parent.getArguments();
            parent.replaceWithText(`${firstArg.getText()} ?? ${secondArg.getText()}`);
        }
    });
}
function modifyFormatNumberArgs() {
    [
        ...get_named_import_references_1.getNamedImportReferences(`formatNumber`, `@taiga-ui/core`),
        ...get_named_import_references_1.getNamedImportReferences(`tuiFormatNumber`, `@taiga-ui/core`),
    ]
        .map(ref => ref.getParent())
        .filter(ng_morph_1.Node.isCallExpression)
        .forEach(fn => {
        const args = fn.getArguments();
        if (args.length > 1) {
            const [value, decimalLimit = `Infinity`, decimalSeparator = `','`, thousandSeparator = `'\u00A0'`, zeroPadding = true,] = args.map(arg => arg.getText());
            const notNullDecimalLimit = decimalLimit === `null` ? `Infinity` : decimalLimit;
            const conditionalDecimalLimit = !Number.isNaN(Number(notNullDecimalLimit))
                ? notNullDecimalLimit
                : `${decimalLimit} === null ? Infinity : ${decimalLimit}`;
            fn.replaceWithText(`tuiFormatNumber(${value}, {decimalLimit: ${conditionalDecimalLimit}, decimalSeparator: ${decimalSeparator}, thousandSeparator: ${thousandSeparator}, zeroPadding: ${zeroPadding}})`);
        }
    });
}
function modifyClosestFocusable() {
    get_named_import_references_1.getNamedImportReferences(`tuiGetClosestFocusable`, `@taiga-ui/cdk`)
        .map(ref => ref.getParent())
        .filter(ng_morph_1.Node.isCallExpression)
        .forEach(fn => {
        const args = fn.getArguments();
        if (args.length > 1) {
            const [initial, prev = false, root, keyboard = true] = args.map(arg => arg.getText());
            fn.replaceWithText(`tuiGetClosestFocusable({initial: ${initial}, root: ${root}, previous: ${prev}, keyboard: ${keyboard}})`);
        }
    });
}
