"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.miscellaneousMigrations = void 0;
const ng_morph_1 = require("ng-morph");
const colored_log_1 = require("../../../utils/colored-log");
const get_named_import_references_1 = require("../../../utils/get-named-import-references");
const insert_todo_1 = require("../../../utils/insert-todo");
function miscellaneousMigrations(options) {
    !options[`skip-logs`] &&
        colored_log_1.infoLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.REPLACE_SYMBOL} miscellaneous migrating...`);
    replaceEnumProperty({
        enumName: `TuiCurrency`,
        from: `HongKong_dollar`,
        to: `HongKongDollar`,
    });
    replaceEnumProperty({
        enumName: `TuiCurrencyCode`,
        from: `HongKong_dollar`,
        to: `HongKongDollar`,
    });
    replaceEnumProperty({
        enumName: `TuiCreditCardAutofillName`,
        /**
         * Do not mark `mounth` as incorrect.
         * cspell:ignore mounth
         */
        from: `CcExp_mounth`,
        to: `CcExpMonth`,
    });
    replaceEnumProperty({
        enumName: `TuiCreditCardAutofillName`,
        from: `CcExp_year`,
        to: `CcExpYear`,
    });
    addWarningToMethod(`TuiDirectiveStylesService`, `addStyle`, `addStyle method has been removed. Use components approach`);
    !options[`skip-logs`] &&
        colored_log_1.successLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.SUCCESS_SYMBOL} miscellaneous migrated \n`);
}
exports.miscellaneousMigrations = miscellaneousMigrations;
function addWarningToMethod(className, method, message) {
    const references = get_named_import_references_1.getNamedImportReferences(className);
    references.forEach(ref => {
        const parent = ref.getParent();
        if (ng_morph_1.Node.isTypeReferenceNode(parent)) {
            checkMethod(parent, method, message);
        }
    });
}
function replaceEnumProperty({ enumName, from, to, }) {
    const references = get_named_import_references_1.getNamedImportReferences(enumName);
    references.forEach(ref => {
        const parent = ref.getParent();
        if (!ng_morph_1.Node.isPropertyAccessExpression(parent)) {
            return;
        }
        parent.getChildren().forEach(node => {
            if (node.getText() === from) {
                node.replaceWithText(to);
            }
        });
    });
}
function checkMethod(node, method, message) {
    const statement = node.getParent();
    const identifier = statement.getChildrenOfKind(ng_morph_1.SyntaxKind.Identifier)[0];
    identifier.findReferencesAsNodes().forEach(ref => {
        let parent = ref.getParent();
        if ((ng_morph_1.Node.isPropertyAccessExpression(parent) &&
            parent.getText().startsWith(`this.`)) ||
            ng_morph_1.Node.isCallExpression(parent)) {
            parent = parent.getParentIfKind(ng_morph_1.SyntaxKind.PropertyAccessExpression);
        }
        if (ng_morph_1.Node.isPropertyAccessExpression(parent)) {
            parent.getChildrenOfKind(ng_morph_1.SyntaxKind.Identifier).forEach(identifier => {
                if (identifier.getText() === method) {
                    insert_todo_1.insertTodo(identifier, message);
                }
            });
        }
    });
}
