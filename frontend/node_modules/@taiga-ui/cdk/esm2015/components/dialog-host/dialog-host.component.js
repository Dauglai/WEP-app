import { ChangeDetectionStrategy, Component, Inject, InjectionToken } from '@angular/core';
import { Title } from '@angular/platform-browser';
import { HISTORY } from '@ng-web-apis/common';
import { TUI_PARENT_ANIMATION } from '@taiga-ui/cdk/constants';
import { TUI_DIALOGS } from '@taiga-ui/cdk/tokens';
import { combineLatest, of } from 'rxjs';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@taiga-ui/cdk/directives/focus-trap";
import * as i3 from "@taiga-ui/cdk/directives/overscroll";
import * as i4 from "@tinkoff/ng-polymorpheus";
import * as i5 from "@taiga-ui/cdk/directives";
import * as i6 from "rxjs";
import * as i7 from "@angular/platform-browser";
/**
 * Is closing dialog on browser backward navigation enabled
 */
export const TUI_DIALOG_CLOSES_ON_BACK = new InjectionToken('[TUI_DIALOG_CLOSES_ON_BACK]', {
    factory: () => of(false),
});
const FAKE_HISTORY_STATE = { label: 'ignoreMe' };
const isFakeHistoryState = (historyState) => (historyState === null || historyState === void 0 ? void 0 : historyState.label) === FAKE_HISTORY_STATE.label;
export class TuiDialogHostComponent {
    constructor(isDialogClosesOnBack$, dialogsByType, historyRef, titleService) {
        this.isDialogClosesOnBack$ = isDialogClosesOnBack$;
        this.dialogsByType = dialogsByType;
        this.historyRef = historyRef;
        this.titleService = titleService;
        this.dialogs$ = combineLatest(this.dialogsByType).pipe(map(allTypesDialogs => new Array()
            .concat(...allTypesDialogs)
            .sort((a, b) => a.createdAt - b.createdAt)));
    }
    closeLast(dialogs, isDialogClosesOnBack) {
        if (!isDialogClosesOnBack) {
            return;
        }
        const [last] = dialogs.slice(-1);
        if (!last) {
            return;
        }
        if (dialogs.length > 1) {
            this.historyRef.pushState(FAKE_HISTORY_STATE, this.titleService.getTitle());
        }
        last.$implicit.complete();
    }
    onDialog({ propertyName }, popupOpened, isDialogClosesOnBack) {
        if (!isDialogClosesOnBack || propertyName !== 'letter-spacing') {
            return;
        }
        if (popupOpened) {
            this.historyRef.pushState(FAKE_HISTORY_STATE, this.titleService.getTitle());
        }
        else if (isFakeHistoryState(this.historyRef.state)) {
            this.historyRef.back();
        }
    }
}
TuiDialogHostComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDialogHostComponent, deps: [{ token: TUI_DIALOG_CLOSES_ON_BACK }, { token: TUI_DIALOGS }, { token: HISTORY }, { token: Title }], target: i0.ɵɵFactoryTarget.Component });
TuiDialogHostComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: TuiDialogHostComponent, selector: "tui-dialog-host", ngImport: i0, template: "<ng-container *ngIf=\"dialogs$ | async as dialogs\">\n    <section\n        *ngFor=\"let item of dialogs\"\n        tuiFocusTrap\n        tuiScrollRef\n        tuiOverscroll=\"all\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        class=\"t-dialog\"\n        @tuiParentAnimation\n        [attr.aria-labelledby]=\"item.id\"\n    >\n        <ng-container *polymorpheusOutlet=\"item.component; context: item\"></ng-container>\n    </section>\n    <div\n        *tuiLet=\"isDialogClosesOnBack$ | async as isDialogClosesOnBack\"\n        class=\"t-overlay\"\n        [class.t-overlay_visible]=\"dialogs.length\"\n        (window:popstate)=\"closeLast(dialogs, !!isDialogClosesOnBack)\"\n        (transitionend)=\"onDialog($event, !!dialogs.length, !!isDialogClosesOnBack)\"\n    ></div>\n</ng-container>\n", styles: [":host{position:fixed;left:0;bottom:0;width:100%;height:0}.t-overlay,.t-dialog{position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:flex-start;outline:none;overflow:auto;overflow:overlay}.t-dialog{bottom:auto;height:100%}.t-overlay{height:100%;pointer-events:none;touch-action:none;opacity:0;letter-spacing:normal;transition:opacity var(--tui-duration),letter-spacing .01s;background:rgba(0,0,0,.75);-webkit-backdrop-filter:var(--tui-backdrop, none);backdrop-filter:var(--tui-backdrop, none)}.t-overlay_visible{opacity:1;letter-spacing:1px}.t-dialog:last-of-type{z-index:1}\n"], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2.TuiFocusTrapDirective, selector: "[tuiFocusTrap]" }, { type: i3.TuiOverscrollDirective, selector: "[tuiOverscroll]", inputs: ["tuiOverscroll"] }, { type: i4.PolymorpheusOutletDirective, selector: "[polymorpheusOutlet]", inputs: ["polymorpheusOutlet", "polymorpheusOutletContext"] }, { type: i5.TuiLetDirective, selector: "[tuiLet]", inputs: ["tuiLet"] }], pipes: { "async": i1.AsyncPipe }, animations: [TUI_PARENT_ANIMATION], changeDetection: i0.ChangeDetectionStrategy.Default });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDialogHostComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'tui-dialog-host',
                    templateUrl: './dialog-host.template.html',
                    styleUrls: ['./dialog-host.style.less'],
                    // So that we do not force OnPush on custom dialogs
                    // eslint-disable-next-line @angular-eslint/prefer-on-push-component-change-detection
                    changeDetection: ChangeDetectionStrategy.Default,
                    animations: [TUI_PARENT_ANIMATION],
                }]
        }], ctorParameters: function () { return [{ type: i6.Observable, decorators: [{
                    type: Inject,
                    args: [TUI_DIALOG_CLOSES_ON_BACK]
                }] }, { type: Array, decorators: [{
                    type: Inject,
                    args: [TUI_DIALOGS]
                }] }, { type: History, decorators: [{
                    type: Inject,
                    args: [HISTORY]
                }] }, { type: i7.Title, decorators: [{
                    type: Inject,
                    args: [Title]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhbG9nLWhvc3QuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY2RrL2NvbXBvbmVudHMvZGlhbG9nLWhvc3QvZGlhbG9nLWhvc3QuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY2RrL2NvbXBvbmVudHMvZGlhbG9nLWhvc3QvZGlhbG9nLWhvc3QudGVtcGxhdGUuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxjQUFjLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDekYsT0FBTyxFQUFDLEtBQUssRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBQ2hELE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUM1QyxPQUFPLEVBQUMsb0JBQW9CLEVBQUMsTUFBTSx5QkFBeUIsQ0FBQztBQUM3RCxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFFakQsT0FBTyxFQUFDLGFBQWEsRUFBYyxFQUFFLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDbkQsT0FBTyxFQUFDLEdBQUcsRUFBQyxNQUFNLGdCQUFnQixDQUFDOzs7Ozs7Ozs7QUFFbkM7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSx5QkFBeUIsR0FBRyxJQUFJLGNBQWMsQ0FDdkQsNkJBQTZCLEVBQzdCO0lBQ0ksT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUM7Q0FDM0IsQ0FDSixDQUFDO0FBRUYsTUFBTSxrQkFBa0IsR0FBRyxFQUFDLEtBQUssRUFBRSxVQUFVLEVBQVUsQ0FBQztBQUN4RCxNQUFNLGtCQUFrQixHQUFHLENBQ3ZCLFlBQXFDLEVBQ0ksRUFBRSxDQUMzQyxDQUFBLFlBQVksYUFBWixZQUFZLHVCQUFaLFlBQVksQ0FBRSxLQUFLLE1BQUssa0JBQWtCLENBQUMsS0FBSyxDQUFDO0FBV3JELE1BQU0sT0FBTyxzQkFBc0I7SUFTL0IsWUFFYSxxQkFBMEMsRUFFbEMsYUFBOEMsRUFDN0IsVUFBbUIsRUFDckIsWUFBbUI7UUFKMUMsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUFxQjtRQUVsQyxrQkFBYSxHQUFiLGFBQWEsQ0FBaUM7UUFDN0IsZUFBVSxHQUFWLFVBQVUsQ0FBUztRQUNyQixpQkFBWSxHQUFaLFlBQVksQ0FBTztRQWQ5QyxhQUFRLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQ3RELEdBQUcsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUNsQixJQUFJLEtBQUssRUFBSzthQUNULE1BQU0sQ0FBQyxHQUFHLGVBQWUsQ0FBQzthQUMxQixJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FDakQsQ0FDSixDQUFDO0lBU0MsQ0FBQztJQUVKLFNBQVMsQ0FBQyxPQUFxQixFQUFFLG9CQUE2QjtRQUMxRCxJQUFJLENBQUMsb0JBQW9CLEVBQUU7WUFDdkIsT0FBTztTQUNWO1FBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVqQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1AsT0FBTztTQUNWO1FBRUQsSUFBSSxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNwQixJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDL0U7UUFFRCxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzlCLENBQUM7SUFFRCxRQUFRLENBQ0osRUFBQyxZQUFZLEVBQWtCLEVBQy9CLFdBQW9CLEVBQ3BCLG9CQUE2QjtRQUU3QixJQUFJLENBQUMsb0JBQW9CLElBQUksWUFBWSxLQUFLLGdCQUFnQixFQUFFO1lBQzVELE9BQU87U0FDVjtRQUVELElBQUksV0FBVyxFQUFFO1lBQ2IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1NBQy9FO2FBQU0sSUFBSSxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2xELElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDMUI7SUFDTCxDQUFDOztvSEFsRFEsc0JBQXNCLGtCQVVuQix5QkFBeUIsYUFFekIsV0FBVyxhQUVYLE9BQU8sYUFDUCxLQUFLO3dHQWZSLHNCQUFzQix1RENsQ25DLGd6QkFzQkEsb3NDRFVnQixDQUFDLG9CQUFvQixDQUFDOzRGQUV6QixzQkFBc0I7a0JBVGxDLFNBQVM7bUJBQUM7b0JBQ1AsUUFBUSxFQUFFLGlCQUFpQjtvQkFDM0IsV0FBVyxFQUFFLDZCQUE2QjtvQkFDMUMsU0FBUyxFQUFFLENBQUMsMEJBQTBCLENBQUM7b0JBQ3ZDLG1EQUFtRDtvQkFDbkQscUZBQXFGO29CQUNyRixlQUFlLEVBQUUsdUJBQXVCLENBQUMsT0FBTztvQkFDaEQsVUFBVSxFQUFFLENBQUMsb0JBQW9CLENBQUM7aUJBQ3JDOzswQkFXUSxNQUFNOzJCQUFDLHlCQUF5Qjs4QkFHRCxLQUFLOzBCQURwQyxNQUFNOzJCQUFDLFdBQVc7OEJBRTJCLE9BQU87MEJBQXBELE1BQU07MkJBQUMsT0FBTzs7MEJBQ2QsTUFBTTsyQkFBQyxLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBJbmplY3QsIEluamVjdGlvblRva2VufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7VGl0bGV9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHtISVNUT1JZfSBmcm9tICdAbmctd2ViLWFwaXMvY29tbW9uJztcbmltcG9ydCB7VFVJX1BBUkVOVF9BTklNQVRJT059IGZyb20gJ0B0YWlnYS11aS9jZGsvY29uc3RhbnRzJztcbmltcG9ydCB7VFVJX0RJQUxPR1N9IGZyb20gJ0B0YWlnYS11aS9jZGsvdG9rZW5zJztcbmltcG9ydCB7VHVpRGlhbG9nfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3R5cGVzJztcbmltcG9ydCB7Y29tYmluZUxhdGVzdCwgT2JzZXJ2YWJsZSwgb2Z9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHttYXB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBJcyBjbG9zaW5nIGRpYWxvZyBvbiBicm93c2VyIGJhY2t3YXJkIG5hdmlnYXRpb24gZW5hYmxlZFxuICovXG5leHBvcnQgY29uc3QgVFVJX0RJQUxPR19DTE9TRVNfT05fQkFDSyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxPYnNlcnZhYmxlPGJvb2xlYW4+PihcbiAgICAnW1RVSV9ESUFMT0dfQ0xPU0VTX09OX0JBQ0tdJyxcbiAgICB7XG4gICAgICAgIGZhY3Rvcnk6ICgpID0+IG9mKGZhbHNlKSxcbiAgICB9LFxuKTtcblxuY29uc3QgRkFLRV9ISVNUT1JZX1NUQVRFID0ge2xhYmVsOiAnaWdub3JlTWUnfSBhcyBjb25zdDtcbmNvbnN0IGlzRmFrZUhpc3RvcnlTdGF0ZSA9IChcbiAgICBoaXN0b3J5U3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuKTogaGlzdG9yeVN0YXRlIGlzIHR5cGVvZiBGQUtFX0hJU1RPUllfU1RBVEUgPT5cbiAgICBoaXN0b3J5U3RhdGU/LmxhYmVsID09PSBGQUtFX0hJU1RPUllfU1RBVEUubGFiZWw7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndHVpLWRpYWxvZy1ob3N0JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZGlhbG9nLWhvc3QudGVtcGxhdGUuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vZGlhbG9nLWhvc3Quc3R5bGUubGVzcyddLFxuICAgIC8vIFNvIHRoYXQgd2UgZG8gbm90IGZvcmNlIE9uUHVzaCBvbiBjdXN0b20gZGlhbG9nc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvcHJlZmVyLW9uLXB1c2gtY29tcG9uZW50LWNoYW5nZS1kZXRlY3Rpb25cbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsXG4gICAgYW5pbWF0aW9uczogW1RVSV9QQVJFTlRfQU5JTUFUSU9OXSxcbn0pXG5leHBvcnQgY2xhc3MgVHVpRGlhbG9nSG9zdENvbXBvbmVudDxUIGV4dGVuZHMgVHVpRGlhbG9nPHVua25vd24sIHVua25vd24+PiB7XG4gICAgcmVhZG9ubHkgZGlhbG9ncyQgPSBjb21iaW5lTGF0ZXN0KHRoaXMuZGlhbG9nc0J5VHlwZSkucGlwZShcbiAgICAgICAgbWFwKGFsbFR5cGVzRGlhbG9ncyA9PlxuICAgICAgICAgICAgbmV3IEFycmF5PFQ+KClcbiAgICAgICAgICAgICAgICAuY29uY2F0KC4uLmFsbFR5cGVzRGlhbG9ncylcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5jcmVhdGVkQXQgLSBiLmNyZWF0ZWRBdCksXG4gICAgICAgICksXG4gICAgKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KFRVSV9ESUFMT0dfQ0xPU0VTX09OX0JBQ0spXG4gICAgICAgIHJlYWRvbmx5IGlzRGlhbG9nQ2xvc2VzT25CYWNrJDogT2JzZXJ2YWJsZTxib29sZWFuPixcbiAgICAgICAgQEluamVjdChUVUlfRElBTE9HUylcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBkaWFsb2dzQnlUeXBlOiBBcnJheTxPYnNlcnZhYmxlPHJlYWRvbmx5IFRbXT4+LFxuICAgICAgICBASW5qZWN0KEhJU1RPUlkpIHByaXZhdGUgcmVhZG9ubHkgaGlzdG9yeVJlZjogSGlzdG9yeSxcbiAgICAgICAgQEluamVjdChUaXRsZSkgcHJpdmF0ZSByZWFkb25seSB0aXRsZVNlcnZpY2U6IFRpdGxlLFxuICAgICkge31cblxuICAgIGNsb3NlTGFzdChkaWFsb2dzOiByZWFkb25seSBUW10sIGlzRGlhbG9nQ2xvc2VzT25CYWNrOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGlmICghaXNEaWFsb2dDbG9zZXNPbkJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFtsYXN0XSA9IGRpYWxvZ3Muc2xpY2UoLTEpO1xuXG4gICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpYWxvZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5UmVmLnB1c2hTdGF0ZShGQUtFX0hJU1RPUllfU1RBVEUsIHRoaXMudGl0bGVTZXJ2aWNlLmdldFRpdGxlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdC4kaW1wbGljaXQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBvbkRpYWxvZyhcbiAgICAgICAge3Byb3BlcnR5TmFtZX06IFRyYW5zaXRpb25FdmVudCxcbiAgICAgICAgcG9wdXBPcGVuZWQ6IGJvb2xlYW4sXG4gICAgICAgIGlzRGlhbG9nQ2xvc2VzT25CYWNrOiBib29sZWFuLFxuICAgICk6IHZvaWQge1xuICAgICAgICBpZiAoIWlzRGlhbG9nQ2xvc2VzT25CYWNrIHx8IHByb3BlcnR5TmFtZSAhPT0gJ2xldHRlci1zcGFjaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvcHVwT3BlbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlSZWYucHVzaFN0YXRlKEZBS0VfSElTVE9SWV9TVEFURSwgdGhpcy50aXRsZVNlcnZpY2UuZ2V0VGl0bGUoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGYWtlSGlzdG9yeVN0YXRlKHRoaXMuaGlzdG9yeVJlZi5zdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeVJlZi5iYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCI8bmctY29udGFpbmVyICpuZ0lmPVwiZGlhbG9ncyQgfCBhc3luYyBhcyBkaWFsb2dzXCI+XG4gICAgPHNlY3Rpb25cbiAgICAgICAgKm5nRm9yPVwibGV0IGl0ZW0gb2YgZGlhbG9nc1wiXG4gICAgICAgIHR1aUZvY3VzVHJhcFxuICAgICAgICB0dWlTY3JvbGxSZWZcbiAgICAgICAgdHVpT3ZlcnNjcm9sbD1cImFsbFwiXG4gICAgICAgIHJvbGU9XCJkaWFsb2dcIlxuICAgICAgICBhcmlhLW1vZGFsPVwidHJ1ZVwiXG4gICAgICAgIGNsYXNzPVwidC1kaWFsb2dcIlxuICAgICAgICBAdHVpUGFyZW50QW5pbWF0aW9uXG4gICAgICAgIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJpdGVtLmlkXCJcbiAgICA+XG4gICAgICAgIDxuZy1jb250YWluZXIgKnBvbHltb3JwaGV1c091dGxldD1cIml0ZW0uY29tcG9uZW50OyBjb250ZXh0OiBpdGVtXCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9zZWN0aW9uPlxuICAgIDxkaXZcbiAgICAgICAgKnR1aUxldD1cImlzRGlhbG9nQ2xvc2VzT25CYWNrJCB8IGFzeW5jIGFzIGlzRGlhbG9nQ2xvc2VzT25CYWNrXCJcbiAgICAgICAgY2xhc3M9XCJ0LW92ZXJsYXlcIlxuICAgICAgICBbY2xhc3MudC1vdmVybGF5X3Zpc2libGVdPVwiZGlhbG9ncy5sZW5ndGhcIlxuICAgICAgICAod2luZG93OnBvcHN0YXRlKT1cImNsb3NlTGFzdChkaWFsb2dzLCAhIWlzRGlhbG9nQ2xvc2VzT25CYWNrKVwiXG4gICAgICAgICh0cmFuc2l0aW9uZW5kKT1cIm9uRGlhbG9nKCRldmVudCwgISFkaWFsb2dzLmxlbmd0aCwgISFpc0RpYWxvZ0Nsb3Nlc09uQmFjaylcIlxuICAgID48L2Rpdj5cbjwvbmctY29udGFpbmVyPlxuIl19