import { tuiAssert } from '@taiga-ui/cdk/classes';
import { TuiInvalidDayException, TuiInvalidMonthException, TuiInvalidYearException, } from '@taiga-ui/cdk/exceptions';
import { tuiInRange, tuiNormalizeToIntNumber } from '@taiga-ui/cdk/utils/math';
import { DATE_FILLER_LENGTH } from './date-fillers';
import { MIN_DAY, MONTHS_IN_YEAR } from './date-time';
import { TuiMonth } from './month';
import { TuiYear } from './year';
// TODO: Localized formatting
/**
 * Immutable date object, consisting of day, month and year
 */
export class TuiDay extends TuiMonth {
    constructor(year, month, day) {
        super(year, month);
        this.day = day;
        ngDevMode && tuiAssert.assert(TuiDay.isValidDay(year, month, day));
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} based on local time zone
     */
    static fromLocalNativeDate(date) {
        return new TuiDay(date.getFullYear(), date.getMonth(), date.getDate());
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} using UTC
     */
    static fromUtcNativeDate(date) {
        return new TuiDay(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    }
    /**
     * Check validity of year, month and day
     *
     * @param year
     * @param month
     * @param day
     * @return boolean validity
     */
    static isValidDay(year, month, day) {
        return (TuiMonth.isValidMonth(year, month) &&
            Number.isInteger(day) &&
            tuiInRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1));
    }
    /**
     * Current day based on local time zone
     */
    static currentLocal() {
        const nativeDate = new Date();
        const year = nativeDate.getFullYear();
        const month = nativeDate.getMonth();
        const day = nativeDate.getDate();
        return new TuiDay(year, month, day);
    }
    /**
     * Returns current day based on UTC
     */
    static currentUtc() {
        const nativeDate = new Date();
        const year = nativeDate.getUTCFullYear();
        const month = nativeDate.getUTCMonth();
        const day = nativeDate.getUTCDate();
        return new TuiDay(year, month, day);
    }
    /**
     * Calculates {@link TuiDay} normalizing year, month and day. {@link NaN} is turned into minimal value.
     *
     * @param year any year value, including invalid
     * @param month any month value, including invalid (months start with 0)
     * @param day any day value, including invalid
     * @return normalized date
     */
    static normalizeOf(year, month, day) {
        const normalizedYear = TuiYear.normalizeYearPart(year);
        const normalizedMonth = TuiMonth.normalizeMonthPart(month);
        const normalizedDay = TuiDay.normalizeDayPart(day, normalizedMonth, normalizedYear);
        return new TuiDay(normalizedYear, normalizedMonth, normalizedDay);
    }
    static lengthBetween(from, to) {
        return Math.round((to.toLocalNativeDate().getTime() - from.toLocalNativeDate().getTime()) /
            (1000 * 60 * 60 * 24));
    }
    static parseRawDateString(date, dateMode = `DMY`) {
        ngDevMode &&
            tuiAssert.assert(date.length === DATE_FILLER_LENGTH, `[parseRawDateString]: wrong date string length`);
        switch (dateMode) {
            case `YMD`:
                return {
                    day: parseInt(date.slice(8, 10), 10),
                    month: parseInt(date.slice(5, 7), 10) - 1,
                    year: parseInt(date.slice(0, 4), 10),
                };
            case `MDY`:
                return {
                    day: parseInt(date.slice(3, 5), 10),
                    month: parseInt(date.slice(0, 2), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
            default:
            case `DMY`:
                return {
                    day: parseInt(date.slice(0, 2), 10),
                    month: parseInt(date.slice(3, 5), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
        }
    }
    // TODO: Move month and year related code corresponding classes
    /**
     * Parsing a string with date with normalization
     *
     * @param rawDate date string
     * @param dateMode date format of the date string (DMY | MDY | YMD)
     * @return normalized date
     */
    static normalizeParse(rawDate, dateMode = `DMY`) {
        const { day, month, year } = this.parseRawDateString(rawDate, dateMode);
        return TuiDay.normalizeOf(year, month, day);
    }
    /**
     * Parsing a date stringified in a toJSON format
     * @param yearMonthDayString date string in format of YYYY-MM-DD
     * @return date
     * @throws exceptions if any part of the date is invalid
     */
    static jsonParse(yearMonthDayString) {
        const { day, month, year } = this.parseRawDateString(yearMonthDayString, `YMD`);
        if (!TuiYear.isValidYear(year)) {
            throw new TuiInvalidYearException(year);
        }
        if (!TuiMonth.isValidMonth(year, month)) {
            throw new TuiInvalidMonthException(month);
        }
        if (!Number.isInteger(day) ||
            !tuiInRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1)) {
            throw new TuiInvalidDayException(day);
        }
        return new TuiDay(year, month, day);
    }
    static normalizeDayPart(day, month, year) {
        ngDevMode && tuiAssert.assert(TuiMonth.isValidMonth(year, month));
        const monthDaysCount = TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year));
        return tuiNormalizeToIntNumber(day, 1, monthDaysCount);
    }
    get formattedDayPart() {
        return String(this.day).padStart(2, `0`);
    }
    get isWeekend() {
        const dayOfWeek = this.dayOfWeek(false);
        return dayOfWeek === 6 /* Saturday */ || dayOfWeek === 0 /* Sunday */;
    }
    /**
     * Returns day of week
     *
     * @param startFromMonday whether week starts from Monday and not from Sunday
     * @return day of week (from 0 to 6)
     */
    dayOfWeek(startFromMonday = true) {
        const dayOfWeek = startFromMonday
            ? this.toLocalNativeDate().getDay() - 1
            : this.toLocalNativeDate().getDay();
        return dayOfWeek < 0 ? 6 : dayOfWeek;
    }
    /**
     * Passed date is after current
     */
    dayBefore(another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day < another.day));
    }
    /**
     * Passed date is after or equals to current
     */
    daySameOrBefore(another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day <= another.day));
    }
    /**
     * Passed date is the same as current
     */
    daySame(another) {
        return this.monthSame(another) && this.day === another.day;
    }
    /**
     * Passed date is either before or the same as current
     */
    daySameOrAfter(another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day >= another.day));
    }
    /**
     * Passed date is before current
     */
    dayAfter(another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day > another.day));
    }
    /**
     * Clamping date between two limits
     *
     * @param min
     * @param max
     * @return clamped date
     */
    dayLimit(min, max) {
        if (min !== null && this.dayBefore(min)) {
            return min;
        }
        if (max !== null && this.dayAfter(max)) {
            return max;
        }
        return this;
    }
    /**
     * Immutably alters current day by passed offset
     *
     * If resulting month has more days than original one, date is rounded to the maximum day
     * in the resulting month. Offset of days will be calculated based on the resulted year and month
     * to not interfere with parent classes methods
     *
     * @param offset
     * @return new date object as a result of offsetting current
     */
    append({ year = 0, month = 0, day = 0 }) {
        const totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
        let years = Math.floor(totalMonths / MONTHS_IN_YEAR);
        let months = totalMonths % MONTHS_IN_YEAR;
        let days = Math.min(this.day, TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) + day;
        while (days > TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) {
            days -= TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
            if (months === 11 /* December */) {
                years++;
                months = 0 /* January */;
            }
            else {
                months++;
            }
        }
        while (days < MIN_DAY) {
            if (months === 0 /* January */) {
                years--;
                months = 11 /* December */;
            }
            else {
                months--;
            }
            days += TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
        }
        return new TuiDay(years, months, days);
    }
    /**
     * Returns formatted whole date
     */
    getFormattedDay(dateFormat, separator) {
        ngDevMode &&
            tuiAssert.assert(separator.length === 1, `Separator should consist of only 1 symbol`);
        const dd = this.formattedDayPart;
        const mm = this.formattedMonthPart;
        const yyyy = this.formattedYear;
        switch (dateFormat) {
            case `YMD`:
                return `${yyyy}${separator}${mm}${separator}${dd}`;
            case `MDY`:
                return `${mm}${separator}${dd}${separator}${yyyy}`;
            case `DMY`:
            default:
                return `${dd}${separator}${mm}${separator}${yyyy}`;
        }
    }
    toString(dateFormat = `DMY`, separator = `.`) {
        return this.getFormattedDay(dateFormat, separator);
    }
    toJSON() {
        return `${super.toJSON()}-${this.formattedDayPart}`;
    }
    /**
     * Returns native {@link Date} based on local time zone
     */
    toLocalNativeDate() {
        return new Date(this.year, this.month, this.day);
    }
    /**
     * Returns native {@link Date} based on UTC
     */
    toUtcNativeDate() {
        return new Date(Date.UTC(this.year, this.month, this.day));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvY2RrL2RhdGUtdGltZS9kYXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRWhELE9BQU8sRUFDSCxzQkFBc0IsRUFDdEIsd0JBQXdCLEVBQ3hCLHVCQUF1QixHQUMxQixNQUFNLDBCQUEwQixDQUFDO0FBR2xDLE9BQU8sRUFBQyxVQUFVLEVBQUUsdUJBQXVCLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUU3RSxPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRCxPQUFPLEVBQUMsT0FBTyxFQUFFLGNBQWMsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUNwRCxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBQ2pDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFFL0IsNkJBQTZCO0FBQzdCOztHQUVHO0FBQ0gsTUFBTSxPQUFPLE1BQU8sU0FBUSxRQUFRO0lBQ2hDLFlBQVksSUFBWSxFQUFFLEtBQWEsRUFBVyxHQUFXO1FBQ3pELEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFEMkIsUUFBRyxHQUFILEdBQUcsQ0FBUTtRQUV6RCxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsbUJBQW1CLENBQUMsSUFBVTtRQUNqQyxPQUFPLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVE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USxNQUFNO1FBQ1gsT0FBTyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztJQUN4RCxDQUFDO0lBRUQ7O09BRUc7SUFDTSxpQkFBaUI7UUFDdEIsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFRDs7T0FFRztJQUNNLGVBQWU7UUFDcEIsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMvRCxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3R1aUFzc2VydH0gZnJvbSAnQHRhaWdhLXVpL2Nkay9jbGFzc2VzJztcbmltcG9ydCB7VHVpRGF5T2ZXZWVrLCBUdWlNb250aE51bWJlcn0gZnJvbSAnQHRhaWdhLXVpL2Nkay9lbnVtcyc7XG5pbXBvcnQge1xuICAgIFR1aUludmFsaWREYXlFeGNlcHRpb24sXG4gICAgVHVpSW52YWxpZE1vbnRoRXhjZXB0aW9uLFxuICAgIFR1aUludmFsaWRZZWFyRXhjZXB0aW9uLFxufSBmcm9tICdAdGFpZ2EtdWkvY2RrL2V4Y2VwdGlvbnMnO1xuaW1wb3J0IHtUdWlEYXlMaWtlfSBmcm9tICdAdGFpZ2EtdWkvY2RrL2ludGVyZmFjZXMnO1xuaW1wb3J0IHtUdWlEYXRlTW9kZX0gZnJvbSAnQHRhaWdhLXVpL2Nkay90eXBlcyc7XG5pbXBvcnQge3R1aUluUmFuZ2UsIHR1aU5vcm1hbGl6ZVRvSW50TnVtYmVyfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3V0aWxzL21hdGgnO1xuXG5pbXBvcnQge0RBVEVfRklMTEVSX0xFTkdUSH0gZnJvbSAnLi9kYXRlLWZpbGxlcnMnO1xuaW1wb3J0IHtNSU5fREFZLCBNT05USFNfSU5fWUVBUn0gZnJvbSAnLi9kYXRlLXRpbWUnO1xuaW1wb3J0IHtUdWlNb250aH0gZnJvbSAnLi9tb250aCc7XG5pbXBvcnQge1R1aVllYXJ9IGZyb20gJy4veWVhcic7XG5cbi8vIFRPRE86IExvY2FsaXplZCBmb3JtYXR0aW5nXG4vKipcbiAqIEltbXV0YWJsZSBkYXRlIG9iamVjdCwgY29uc2lzdGluZyBvZiBkYXksIG1vbnRoIGFuZCB5ZWFyXG4gKi9cbmV4cG9ydCBjbGFzcyBUdWlEYXkgZXh0ZW5kcyBUdWlNb250aCB7XG4gICAgY29uc3RydWN0b3IoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCByZWFkb25seSBkYXk6IG51bWJlcikge1xuICAgICAgICBzdXBlcih5ZWFyLCBtb250aCk7XG4gICAgICAgIG5nRGV2TW9kZSAmJiB0dWlBc3NlcnQuYXNzZXJ0KFR1aURheS5pc1ZhbGlkRGF5KHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHtAbGluayBUdWlEYXl9IGZyb20gbmF0aXZlIHtAbGluayBEYXRlfSBiYXNlZCBvbiBsb2NhbCB0aW1lIHpvbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUxvY2FsTmF0aXZlRGF0ZShkYXRlOiBEYXRlKTogVHVpRGF5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHtAbGluayBUdWlEYXl9IGZyb20gbmF0aXZlIHtAbGluayBEYXRlfSB1c2luZyBVVENcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVV0Y05hdGl2ZURhdGUoZGF0ZTogRGF0ZSk6IFR1aURheSB7XG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgZGF0ZS5nZXRVVENNb250aCgpLCBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdmFsaWRpdHkgb2YgeWVhciwgbW9udGggYW5kIGRheVxuICAgICAqXG4gICAgICogQHBhcmFtIHllYXJcbiAgICAgKiBAcGFyYW0gbW9udGhcbiAgICAgKiBAcGFyYW0gZGF5XG4gICAgICogQHJldHVybiBib29sZWFuIHZhbGlkaXR5XG4gICAgICovXG4gICAgc3RhdGljIGlzVmFsaWREYXkoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgVHVpTW9udGguaXNWYWxpZE1vbnRoKHllYXIsIG1vbnRoKSAmJlxuICAgICAgICAgICAgTnVtYmVyLmlzSW50ZWdlcihkYXkpICYmXG4gICAgICAgICAgICB0dWlJblJhbmdlKFxuICAgICAgICAgICAgICAgIGRheSxcbiAgICAgICAgICAgICAgICBNSU5fREFZLFxuICAgICAgICAgICAgICAgIFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRoLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcikpICsgMSxcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGRheSBiYXNlZCBvbiBsb2NhbCB0aW1lIHpvbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgb3ZlcnJpZGUgY3VycmVudExvY2FsKCk6IFR1aURheSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZURhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB5ZWFyID0gbmF0aXZlRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICBjb25zdCBtb250aCA9IG5hdGl2ZURhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgY29uc3QgZGF5ID0gbmF0aXZlRGF0ZS5nZXREYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkoeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50IGRheSBiYXNlZCBvbiBVVENcbiAgICAgKi9cbiAgICBzdGF0aWMgb3ZlcnJpZGUgY3VycmVudFV0YygpOiBUdWlEYXkge1xuICAgICAgICBjb25zdCBuYXRpdmVEYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgeWVhciA9IG5hdGl2ZURhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBuYXRpdmVEYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgIGNvbnN0IGRheSA9IG5hdGl2ZURhdGUuZ2V0VVRDRGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMge0BsaW5rIFR1aURheX0gbm9ybWFsaXppbmcgeWVhciwgbW9udGggYW5kIGRheS4ge0BsaW5rIE5hTn0gaXMgdHVybmVkIGludG8gbWluaW1hbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB5ZWFyIGFueSB5ZWFyIHZhbHVlLCBpbmNsdWRpbmcgaW52YWxpZFxuICAgICAqIEBwYXJhbSBtb250aCBhbnkgbW9udGggdmFsdWUsIGluY2x1ZGluZyBpbnZhbGlkIChtb250aHMgc3RhcnQgd2l0aCAwKVxuICAgICAqIEBwYXJhbSBkYXkgYW55IGRheSB2YWx1ZSwgaW5jbHVkaW5nIGludmFsaWRcbiAgICAgKiBAcmV0dXJuIG5vcm1hbGl6ZWQgZGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBub3JtYWxpemVPZih5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyKTogVHVpRGF5IHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFllYXIgPSBUdWlZZWFyLm5vcm1hbGl6ZVllYXJQYXJ0KHllYXIpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTW9udGggPSBUdWlNb250aC5ub3JtYWxpemVNb250aFBhcnQobW9udGgpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkRGF5ID0gVHVpRGF5Lm5vcm1hbGl6ZURheVBhcnQoXG4gICAgICAgICAgICBkYXksXG4gICAgICAgICAgICBub3JtYWxpemVkTW9udGgsXG4gICAgICAgICAgICBub3JtYWxpemVkWWVhcixcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gbmV3IFR1aURheShub3JtYWxpemVkWWVhciwgbm9ybWFsaXplZE1vbnRoLCBub3JtYWxpemVkRGF5KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgb3ZlcnJpZGUgbGVuZ3RoQmV0d2Vlbihmcm9tOiBUdWlEYXksIHRvOiBUdWlEYXkpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChcbiAgICAgICAgICAgICh0by50b0xvY2FsTmF0aXZlRGF0ZSgpLmdldFRpbWUoKSAtIGZyb20udG9Mb2NhbE5hdGl2ZURhdGUoKS5nZXRUaW1lKCkpIC9cbiAgICAgICAgICAgICAgICAoMTAwMCAqIDYwICogNjAgKiAyNCksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlUmF3RGF0ZVN0cmluZyhcbiAgICAgICAgZGF0ZTogc3RyaW5nLFxuICAgICAgICBkYXRlTW9kZTogVHVpRGF0ZU1vZGUgPSBgRE1ZYCxcbiAgICApOiB7ZGF5OiBudW1iZXI7IG1vbnRoOiBudW1iZXI7IHllYXI6IG51bWJlcn0ge1xuICAgICAgICBuZ0Rldk1vZGUgJiZcbiAgICAgICAgICAgIHR1aUFzc2VydC5hc3NlcnQoXG4gICAgICAgICAgICAgICAgZGF0ZS5sZW5ndGggPT09IERBVEVfRklMTEVSX0xFTkdUSCxcbiAgICAgICAgICAgICAgICBgW3BhcnNlUmF3RGF0ZVN0cmluZ106IHdyb25nIGRhdGUgc3RyaW5nIGxlbmd0aGAsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHN3aXRjaCAoZGF0ZU1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgYFlNRGA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5OiBwYXJzZUludChkYXRlLnNsaWNlKDgsIDEwKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBtb250aDogcGFyc2VJbnQoZGF0ZS5zbGljZSg1LCA3KSwgMTApIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgeWVhcjogcGFyc2VJbnQoZGF0ZS5zbGljZSgwLCA0KSwgMTApLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNhc2UgYE1EWWA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5OiBwYXJzZUludChkYXRlLnNsaWNlKDMsIDUpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoOiBwYXJzZUludChkYXRlLnNsaWNlKDAsIDIpLCAxMCkgLSAxLFxuICAgICAgICAgICAgICAgICAgICB5ZWFyOiBwYXJzZUludChkYXRlLnNsaWNlKDYsIDEwKSwgMTApLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYXNlIGBETVlgOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRheTogcGFyc2VJbnQoZGF0ZS5zbGljZSgwLCAyKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBtb250aDogcGFyc2VJbnQoZGF0ZS5zbGljZSgzLCA1KSwgMTApIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgeWVhcjogcGFyc2VJbnQoZGF0ZS5zbGljZSg2LCAxMCksIDEwKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogTW92ZSBtb250aCBhbmQgeWVhciByZWxhdGVkIGNvZGUgY29ycmVzcG9uZGluZyBjbGFzc2VzXG4gICAgLyoqXG4gICAgICogUGFyc2luZyBhIHN0cmluZyB3aXRoIGRhdGUgd2l0aCBub3JtYWxpemF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmF3RGF0ZSBkYXRlIHN0cmluZ1xuICAgICAqIEBwYXJhbSBkYXRlTW9kZSBkYXRlIGZvcm1hdCBvZiB0aGUgZGF0ZSBzdHJpbmcgKERNWSB8IE1EWSB8IFlNRClcbiAgICAgKiBAcmV0dXJuIG5vcm1hbGl6ZWQgZGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBub3JtYWxpemVQYXJzZShyYXdEYXRlOiBzdHJpbmcsIGRhdGVNb2RlOiBUdWlEYXRlTW9kZSA9IGBETVlgKTogVHVpRGF5IHtcbiAgICAgICAgY29uc3Qge2RheSwgbW9udGgsIHllYXJ9ID0gdGhpcy5wYXJzZVJhd0RhdGVTdHJpbmcocmF3RGF0ZSwgZGF0ZU1vZGUpO1xuXG4gICAgICAgIHJldHVybiBUdWlEYXkubm9ybWFsaXplT2YoeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2luZyBhIGRhdGUgc3RyaW5naWZpZWQgaW4gYSB0b0pTT04gZm9ybWF0XG4gICAgICogQHBhcmFtIHllYXJNb250aERheVN0cmluZyBkYXRlIHN0cmluZyBpbiBmb3JtYXQgb2YgWVlZWS1NTS1ERFxuICAgICAqIEByZXR1cm4gZGF0ZVxuICAgICAqIEB0aHJvd3MgZXhjZXB0aW9ucyBpZiBhbnkgcGFydCBvZiB0aGUgZGF0ZSBpcyBpbnZhbGlkXG4gICAgICovXG4gICAgc3RhdGljIGpzb25QYXJzZSh5ZWFyTW9udGhEYXlTdHJpbmc6IHN0cmluZyk6IFR1aURheSB7XG4gICAgICAgIGNvbnN0IHtkYXksIG1vbnRoLCB5ZWFyfSA9IHRoaXMucGFyc2VSYXdEYXRlU3RyaW5nKHllYXJNb250aERheVN0cmluZywgYFlNRGApO1xuXG4gICAgICAgIGlmICghVHVpWWVhci5pc1ZhbGlkWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR1aUludmFsaWRZZWFyRXhjZXB0aW9uKHllYXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFUdWlNb250aC5pc1ZhbGlkTW9udGgoeWVhciwgbW9udGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHVpSW52YWxpZE1vbnRoRXhjZXB0aW9uKG1vbnRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKGRheSkgfHxcbiAgICAgICAgICAgICF0dWlJblJhbmdlKFxuICAgICAgICAgICAgICAgIGRheSxcbiAgICAgICAgICAgICAgICBNSU5fREFZLFxuICAgICAgICAgICAgICAgIFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRoLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcikpICsgMSxcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHVpSW52YWxpZERheUV4Y2VwdGlvbihkYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkoeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBub3JtYWxpemVEYXlQYXJ0KGRheTogbnVtYmVyLCBtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBuZ0Rldk1vZGUgJiYgdHVpQXNzZXJ0LmFzc2VydChUdWlNb250aC5pc1ZhbGlkTW9udGgoeWVhciwgbW9udGgpKTtcblxuICAgICAgICBjb25zdCBtb250aERheXNDb3VudCA9IFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KFxuICAgICAgICAgICAgbW9udGgsXG4gICAgICAgICAgICBUdWlZZWFyLmlzTGVhcFllYXIoeWVhciksXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHR1aU5vcm1hbGl6ZVRvSW50TnVtYmVyKGRheSwgMSwgbW9udGhEYXlzQ291bnQpO1xuICAgIH1cblxuICAgIGdldCBmb3JtYXR0ZWREYXlQYXJ0KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy5kYXkpLnBhZFN0YXJ0KDIsIGAwYCk7XG4gICAgfVxuXG4gICAgZ2V0IGlzV2Vla2VuZCgpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZGF5T2ZXZWVrID0gdGhpcy5kYXlPZldlZWsoZmFsc2UpO1xuXG4gICAgICAgIHJldHVybiBkYXlPZldlZWsgPT09IFR1aURheU9mV2Vlay5TYXR1cmRheSB8fCBkYXlPZldlZWsgPT09IFR1aURheU9mV2Vlay5TdW5kYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXkgb2Ygd2Vla1xuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0RnJvbU1vbmRheSB3aGV0aGVyIHdlZWsgc3RhcnRzIGZyb20gTW9uZGF5IGFuZCBub3QgZnJvbSBTdW5kYXlcbiAgICAgKiBAcmV0dXJuIGRheSBvZiB3ZWVrIChmcm9tIDAgdG8gNilcbiAgICAgKi9cbiAgICBkYXlPZldlZWsoc3RhcnRGcm9tTW9uZGF5OiBib29sZWFuID0gdHJ1ZSk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGRheU9mV2VlayA9IHN0YXJ0RnJvbU1vbmRheVxuICAgICAgICAgICAgPyB0aGlzLnRvTG9jYWxOYXRpdmVEYXRlKCkuZ2V0RGF5KCkgLSAxXG4gICAgICAgICAgICA6IHRoaXMudG9Mb2NhbE5hdGl2ZURhdGUoKS5nZXREYXkoKTtcblxuICAgICAgICByZXR1cm4gZGF5T2ZXZWVrIDwgMCA/IDYgOiBkYXlPZldlZWs7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIGRhdGUgaXMgYWZ0ZXIgY3VycmVudFxuICAgICAqL1xuICAgIGRheUJlZm9yZShhbm90aGVyOiBUdWlEYXkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMubW9udGhCZWZvcmUoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA8IGFub3RoZXIuZGF5KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBkYXRlIGlzIGFmdGVyIG9yIGVxdWFscyB0byBjdXJyZW50XG4gICAgICovXG4gICAgZGF5U2FtZU9yQmVmb3JlKGFub3RoZXI6IFR1aURheSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5tb250aEJlZm9yZShhbm90aGVyKSB8fFxuICAgICAgICAgICAgKHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5IDw9IGFub3RoZXIuZGF5KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBkYXRlIGlzIHRoZSBzYW1lIGFzIGN1cnJlbnRcbiAgICAgKi9cbiAgICBkYXlTYW1lKGFub3RoZXI6IFR1aURheSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aFNhbWUoYW5vdGhlcikgJiYgdGhpcy5kYXkgPT09IGFub3RoZXIuZGF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBkYXRlIGlzIGVpdGhlciBiZWZvcmUgb3IgdGhlIHNhbWUgYXMgY3VycmVudFxuICAgICAqL1xuICAgIGRheVNhbWVPckFmdGVyKGFub3RoZXI6IFR1aURheSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5tb250aEFmdGVyKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy5tb250aFNhbWUoYW5vdGhlcikgJiYgdGhpcy5kYXkgPj0gYW5vdGhlci5kYXkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIGRhdGUgaXMgYmVmb3JlIGN1cnJlbnRcbiAgICAgKi9cbiAgICBkYXlBZnRlcihhbm90aGVyOiBUdWlEYXkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMubW9udGhBZnRlcihhbm90aGVyKSB8fFxuICAgICAgICAgICAgKHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5ID4gYW5vdGhlci5kYXkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xhbXBpbmcgZGF0ZSBiZXR3ZWVuIHR3byBsaW1pdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtaW5cbiAgICAgKiBAcGFyYW0gbWF4XG4gICAgICogQHJldHVybiBjbGFtcGVkIGRhdGVcbiAgICAgKi9cbiAgICBkYXlMaW1pdChtaW46IFR1aURheSB8IG51bGwsIG1heDogVHVpRGF5IHwgbnVsbCk6IFR1aURheSB7XG4gICAgICAgIGlmIChtaW4gIT09IG51bGwgJiYgdGhpcy5kYXlCZWZvcmUobWluKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXggIT09IG51bGwgJiYgdGhpcy5kYXlBZnRlcihtYXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1tdXRhYmx5IGFsdGVycyBjdXJyZW50IGRheSBieSBwYXNzZWQgb2Zmc2V0XG4gICAgICpcbiAgICAgKiBJZiByZXN1bHRpbmcgbW9udGggaGFzIG1vcmUgZGF5cyB0aGFuIG9yaWdpbmFsIG9uZSwgZGF0ZSBpcyByb3VuZGVkIHRvIHRoZSBtYXhpbXVtIGRheVxuICAgICAqIGluIHRoZSByZXN1bHRpbmcgbW9udGguIE9mZnNldCBvZiBkYXlzIHdpbGwgYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgcmVzdWx0ZWQgeWVhciBhbmQgbW9udGhcbiAgICAgKiB0byBub3QgaW50ZXJmZXJlIHdpdGggcGFyZW50IGNsYXNzZXMgbWV0aG9kc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqIEByZXR1cm4gbmV3IGRhdGUgb2JqZWN0IGFzIGEgcmVzdWx0IG9mIG9mZnNldHRpbmcgY3VycmVudFxuICAgICAqL1xuICAgIG92ZXJyaWRlIGFwcGVuZCh7eWVhciA9IDAsIG1vbnRoID0gMCwgZGF5ID0gMH06IFR1aURheUxpa2UpOiBUdWlEYXkge1xuICAgICAgICBjb25zdCB0b3RhbE1vbnRocyA9ICh0aGlzLnllYXIgKyB5ZWFyKSAqIE1PTlRIU19JTl9ZRUFSICsgdGhpcy5tb250aCArIG1vbnRoO1xuICAgICAgICBsZXQgeWVhcnMgPSBNYXRoLmZsb29yKHRvdGFsTW9udGhzIC8gTU9OVEhTX0lOX1lFQVIpO1xuICAgICAgICBsZXQgbW9udGhzID0gdG90YWxNb250aHMgJSBNT05USFNfSU5fWUVBUjtcblxuICAgICAgICBsZXQgZGF5cyA9XG4gICAgICAgICAgICBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICB0aGlzLmRheSxcbiAgICAgICAgICAgICAgICBUdWlNb250aC5nZXRNb250aERheXNDb3VudChtb250aHMsIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFycykpLFxuICAgICAgICAgICAgKSArIGRheTtcblxuICAgICAgICB3aGlsZSAoZGF5cyA+IFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRocywgVHVpWWVhci5pc0xlYXBZZWFyKHllYXJzKSkpIHtcbiAgICAgICAgICAgIGRheXMgLT0gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGhzLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcnMpKTtcblxuICAgICAgICAgICAgaWYgKG1vbnRocyA9PT0gVHVpTW9udGhOdW1iZXIuRGVjZW1iZXIpIHtcbiAgICAgICAgICAgICAgICB5ZWFycysrO1xuICAgICAgICAgICAgICAgIG1vbnRocyA9IFR1aU1vbnRoTnVtYmVyLkphbnVhcnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbnRocysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGRheXMgPCBNSU5fREFZKSB7XG4gICAgICAgICAgICBpZiAobW9udGhzID09PSBUdWlNb250aE51bWJlci5KYW51YXJ5KSB7XG4gICAgICAgICAgICAgICAgeWVhcnMtLTtcbiAgICAgICAgICAgICAgICBtb250aHMgPSBUdWlNb250aE51bWJlci5EZWNlbWJlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9udGhzLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRheXMgKz0gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGhzLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KHllYXJzLCBtb250aHMsIGRheXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZm9ybWF0dGVkIHdob2xlIGRhdGVcbiAgICAgKi9cbiAgICBnZXRGb3JtYXR0ZWREYXkoZGF0ZUZvcm1hdDogVHVpRGF0ZU1vZGUsIHNlcGFyYXRvcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgbmdEZXZNb2RlICYmXG4gICAgICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvci5sZW5ndGggPT09IDEsXG4gICAgICAgICAgICAgICAgYFNlcGFyYXRvciBzaG91bGQgY29uc2lzdCBvZiBvbmx5IDEgc3ltYm9sYCxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgZGQgPSB0aGlzLmZvcm1hdHRlZERheVBhcnQ7XG4gICAgICAgIGNvbnN0IG1tID0gdGhpcy5mb3JtYXR0ZWRNb250aFBhcnQ7XG4gICAgICAgIGNvbnN0IHl5eXkgPSB0aGlzLmZvcm1hdHRlZFllYXI7XG5cbiAgICAgICAgc3dpdGNoIChkYXRlRm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIGBZTURgOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHt5eXl5fSR7c2VwYXJhdG9yfSR7bW19JHtzZXBhcmF0b3J9JHtkZH1gO1xuICAgICAgICAgICAgY2FzZSBgTURZYDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7bW19JHtzZXBhcmF0b3J9JHtkZH0ke3NlcGFyYXRvcn0ke3l5eXl9YDtcbiAgICAgICAgICAgIGNhc2UgYERNWWA6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtkZH0ke3NlcGFyYXRvcn0ke21tfSR7c2VwYXJhdG9yfSR7eXl5eX1gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3ZlcnJpZGUgdG9TdHJpbmcoZGF0ZUZvcm1hdDogVHVpRGF0ZU1vZGUgPSBgRE1ZYCwgc2VwYXJhdG9yOiBzdHJpbmcgPSBgLmApOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtYXR0ZWREYXkoZGF0ZUZvcm1hdCwgc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICBvdmVycmlkZSB0b0pTT04oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke3N1cGVyLnRvSlNPTigpfS0ke3RoaXMuZm9ybWF0dGVkRGF5UGFydH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlIHtAbGluayBEYXRlfSBiYXNlZCBvbiBsb2NhbCB0aW1lIHpvbmVcbiAgICAgKi9cbiAgICBvdmVycmlkZSB0b0xvY2FsTmF0aXZlRGF0ZSgpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlIHtAbGluayBEYXRlfSBiYXNlZCBvbiBVVENcbiAgICAgKi9cbiAgICBvdmVycmlkZSB0b1V0Y05hdGl2ZURhdGUoKTogRGF0ZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5KSk7XG4gICAgfVxufVxuIl19