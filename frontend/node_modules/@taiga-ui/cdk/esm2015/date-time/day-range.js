import { tuiAssert } from '@taiga-ui/cdk/classes';
import { DATE_FILLER_LENGTH, DATE_RANGE_FILLER_LENGTH } from './date-fillers';
import { RANGE_SEPARATOR_CHAR } from './date-time';
import { TuiDay } from './day';
import { TuiMonthRange } from './month-range';
/**
 * An immutable range of two {@link TuiDay} objects
 */
export class TuiDayRange extends TuiMonthRange {
    constructor(from, to) {
        super(from, to);
        this.from = from;
        this.to = to;
        ngDevMode && tuiAssert.assert(from.daySameOrBefore(to));
    }
    /**
     * Creates range from two days after sorting them
     *
     * @param day1
     * @param day2
     * @return new range with sorted days
     */
    static sort(day1, day2) {
        return day1.daySameOrBefore(day2)
            ? new TuiDayRange(day1, day2)
            : new TuiDayRange(day2, day1);
    }
    /**
     * Parse and correct a day range in string format
     *
     * @param rangeString a string of dates in a format dd.mm.yyyy - dd.mm.yyyy
     * @param dateMode {@link TuiDateMode}
     * @return normalized day range object
     */
    static normalizeParse(rangeString, dateMode = `DMY`) {
        const leftDay = TuiDay.normalizeParse(rangeString.slice(0, DATE_FILLER_LENGTH), dateMode);
        if (rangeString.length < DATE_RANGE_FILLER_LENGTH) {
            return new TuiDayRange(leftDay, leftDay);
        }
        return TuiDayRange.sort(leftDay, TuiDay.normalizeParse(rangeString.slice(DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length), dateMode));
    }
    get isSingleDay() {
        return this.from.daySame(this.to);
    }
    /**
     * Tests ranges for identity
     *
     * @param another second range to test against current
     * @return `true` if days are identical
     */
    daySame(another) {
        return this.from.daySame(another.from) && this.to.daySame(another.to);
    }
    /**
     * Locks range between two days included, or limits from one side if the other is null
     *
     * @param min
     * @param max
     * @return range â€” clamped range
     */
    dayLimit(min, max) {
        return new TuiDayRange(this.from.dayLimit(min, max), this.to.dayLimit(min, max));
    }
    /**
     * Human readable format.
     */
    getFormattedDayRange(dateFormat, dateSeparator) {
        const from = this.from.getFormattedDay(dateFormat, dateSeparator);
        const to = this.to.getFormattedDay(dateFormat, dateSeparator);
        return `${from}${RANGE_SEPARATOR_CHAR}${to}`;
    }
    toString(dateFormat = `DMY`, dateSeparator = `.`) {
        const from = this.from.getFormattedDay(dateFormat, dateSeparator);
        const to = this.to.getFormattedDay(dateFormat, dateSeparator);
        return `${from}${RANGE_SEPARATOR_CHAR}${to}`;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LXJhbmdlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvY2RrL2RhdGUtdGltZS9kYXktcmFuZ2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBR2hELE9BQU8sRUFBQyxrQkFBa0IsRUFBRSx3QkFBd0IsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQzVFLE9BQU8sRUFBQyxvQkFBb0IsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUNqRCxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sT0FBTyxDQUFDO0FBQzdCLE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFNUM7O0dBRUc7QUFDSCxNQUFNLE9BQU8sV0FBWSxTQUFRLGFBQWE7SUFDMUMsWUFBOEIsSUFBWSxFQUFvQixFQUFVO1FBQ3BFLEtBQUssQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFEVSxTQUFJLEdBQUosSUFBSSxDQUFRO1FBQW9CLE9BQUUsR0FBRixFQUFFLENBQVE7UUFHcEUsU0FBUyxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzVELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxNQUFNLENBQVUsSUFBSSxDQUFDLElBQVksRUFBRSxJQUFZO1FBQzNDLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUM7WUFDN0IsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7WUFDN0IsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsTUFBTSxDQUFDLGNBQWMsQ0FDakIsV0FBbUIsRUFDbkIsV0FBd0IsS0FBSztRQUU3QixNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsY0FBYyxDQUNqQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxrQkFBa0IsQ0FBQyxFQUN4QyxRQUFRLENBQ1gsQ0FBQztRQUVGLElBQUksV0FBVyxDQUFDLE1BQU0sR0FBRyx3QkFBd0IsRUFBRTtZQUMvQyxPQUFPLElBQUksV0FBVyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztTQUM1QztRQUVELE9BQU8sV0FBVyxDQUFDLElBQUksQ0FDbkIsT0FBTyxFQUNQLE1BQU0sQ0FBQyxjQUFjLENBQ2pCLFdBQVcsQ0FBQyxLQUFLLENBQUMsa0JBQWtCLEdBQUcsb0JBQW9CLENBQUMsTUFBTSxDQUFDLEVBQ25FLFFBQVEsQ0FDWCxDQUNKLENBQUM7SUFDTixDQUFDO0lBRUQsSUFBSSxXQUFXO1FBQ1gsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsT0FBTyxDQUFDLE9BQW9CO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUMxRSxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsUUFBUSxDQUFDLEdBQWtCLEVBQUUsR0FBa0I7UUFDM0MsT0FBTyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDckYsQ0FBQztJQUVEOztPQUVHO0lBQ0gsb0JBQW9CLENBQUMsVUFBdUIsRUFBRSxhQUFxQjtRQUMvRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDbEUsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsVUFBVSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBRTlELE9BQU8sR0FBRyxJQUFJLEdBQUcsb0JBQW9CLEdBQUcsRUFBRSxFQUFFLENBQUM7SUFDakQsQ0FBQztJQUVRLFFBQVEsQ0FDYixhQUEwQixLQUFLLEVBQy9CLGdCQUF3QixHQUFHO1FBRTNCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsRUFBRSxhQUFhLENBQUMsQ0FBQztRQUNsRSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxVQUFVLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFFOUQsT0FBTyxHQUFHLElBQUksR0FBRyxvQkFBb0IsR0FBRyxFQUFFLEVBQUUsQ0FBQztJQUNqRCxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3R1aUFzc2VydH0gZnJvbSAnQHRhaWdhLXVpL2Nkay9jbGFzc2VzJztcbmltcG9ydCB7VHVpRGF0ZU1vZGV9IGZyb20gJ0B0YWlnYS11aS9jZGsvdHlwZXMnO1xuXG5pbXBvcnQge0RBVEVfRklMTEVSX0xFTkdUSCwgREFURV9SQU5HRV9GSUxMRVJfTEVOR1RIfSBmcm9tICcuL2RhdGUtZmlsbGVycyc7XG5pbXBvcnQge1JBTkdFX1NFUEFSQVRPUl9DSEFSfSBmcm9tICcuL2RhdGUtdGltZSc7XG5pbXBvcnQge1R1aURheX0gZnJvbSAnLi9kYXknO1xuaW1wb3J0IHtUdWlNb250aFJhbmdlfSBmcm9tICcuL21vbnRoLXJhbmdlJztcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgcmFuZ2Ugb2YgdHdvIHtAbGluayBUdWlEYXl9IG9iamVjdHNcbiAqL1xuZXhwb3J0IGNsYXNzIFR1aURheVJhbmdlIGV4dGVuZHMgVHVpTW9udGhSYW5nZSB7XG4gICAgY29uc3RydWN0b3Iob3ZlcnJpZGUgcmVhZG9ubHkgZnJvbTogVHVpRGF5LCBvdmVycmlkZSByZWFkb25seSB0bzogVHVpRGF5KSB7XG4gICAgICAgIHN1cGVyKGZyb20sIHRvKTtcblxuICAgICAgICBuZ0Rldk1vZGUgJiYgdHVpQXNzZXJ0LmFzc2VydChmcm9tLmRheVNhbWVPckJlZm9yZSh0bykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgcmFuZ2UgZnJvbSB0d28gZGF5cyBhZnRlciBzb3J0aW5nIHRoZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXkxXG4gICAgICogQHBhcmFtIGRheTJcbiAgICAgKiBAcmV0dXJuIG5ldyByYW5nZSB3aXRoIHNvcnRlZCBkYXlzXG4gICAgICovXG4gICAgc3RhdGljIG92ZXJyaWRlIHNvcnQoZGF5MTogVHVpRGF5LCBkYXkyOiBUdWlEYXkpOiBUdWlEYXlSYW5nZSB7XG4gICAgICAgIHJldHVybiBkYXkxLmRheVNhbWVPckJlZm9yZShkYXkyKVxuICAgICAgICAgICAgPyBuZXcgVHVpRGF5UmFuZ2UoZGF5MSwgZGF5MilcbiAgICAgICAgICAgIDogbmV3IFR1aURheVJhbmdlKGRheTIsIGRheTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGFuZCBjb3JyZWN0IGEgZGF5IHJhbmdlIGluIHN0cmluZyBmb3JtYXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZVN0cmluZyBhIHN0cmluZyBvZiBkYXRlcyBpbiBhIGZvcm1hdCBkZC5tbS55eXl5IC0gZGQubW0ueXl5eVxuICAgICAqIEBwYXJhbSBkYXRlTW9kZSB7QGxpbmsgVHVpRGF0ZU1vZGV9XG4gICAgICogQHJldHVybiBub3JtYWxpemVkIGRheSByYW5nZSBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgbm9ybWFsaXplUGFyc2UoXG4gICAgICAgIHJhbmdlU3RyaW5nOiBzdHJpbmcsXG4gICAgICAgIGRhdGVNb2RlOiBUdWlEYXRlTW9kZSA9IGBETVlgLFxuICAgICk6IFR1aURheVJhbmdlIHtcbiAgICAgICAgY29uc3QgbGVmdERheSA9IFR1aURheS5ub3JtYWxpemVQYXJzZShcbiAgICAgICAgICAgIHJhbmdlU3RyaW5nLnNsaWNlKDAsIERBVEVfRklMTEVSX0xFTkdUSCksXG4gICAgICAgICAgICBkYXRlTW9kZSxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAocmFuZ2VTdHJpbmcubGVuZ3RoIDwgREFURV9SQU5HRV9GSUxMRVJfTEVOR1RIKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR1aURheVJhbmdlKGxlZnREYXksIGxlZnREYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFR1aURheVJhbmdlLnNvcnQoXG4gICAgICAgICAgICBsZWZ0RGF5LFxuICAgICAgICAgICAgVHVpRGF5Lm5vcm1hbGl6ZVBhcnNlKFxuICAgICAgICAgICAgICAgIHJhbmdlU3RyaW5nLnNsaWNlKERBVEVfRklMTEVSX0xFTkdUSCArIFJBTkdFX1NFUEFSQVRPUl9DSEFSLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgZGF0ZU1vZGUsXG4gICAgICAgICAgICApLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldCBpc1NpbmdsZURheSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbS5kYXlTYW1lKHRoaXMudG8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHJhbmdlcyBmb3IgaWRlbnRpdHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbm90aGVyIHNlY29uZCByYW5nZSB0byB0ZXN0IGFnYWluc3QgY3VycmVudFxuICAgICAqIEByZXR1cm4gYHRydWVgIGlmIGRheXMgYXJlIGlkZW50aWNhbFxuICAgICAqL1xuICAgIGRheVNhbWUoYW5vdGhlcjogVHVpRGF5UmFuZ2UpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbS5kYXlTYW1lKGFub3RoZXIuZnJvbSkgJiYgdGhpcy50by5kYXlTYW1lKGFub3RoZXIudG8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvY2tzIHJhbmdlIGJldHdlZW4gdHdvIGRheXMgaW5jbHVkZWQsIG9yIGxpbWl0cyBmcm9tIG9uZSBzaWRlIGlmIHRoZSBvdGhlciBpcyBudWxsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWluXG4gICAgICogQHBhcmFtIG1heFxuICAgICAqIEByZXR1cm4gcmFuZ2Ug4oCUIGNsYW1wZWQgcmFuZ2VcbiAgICAgKi9cbiAgICBkYXlMaW1pdChtaW46IFR1aURheSB8IG51bGwsIG1heDogVHVpRGF5IHwgbnVsbCk6IFR1aURheVJhbmdlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXlSYW5nZSh0aGlzLmZyb20uZGF5TGltaXQobWluLCBtYXgpLCB0aGlzLnRvLmRheUxpbWl0KG1pbiwgbWF4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSHVtYW4gcmVhZGFibGUgZm9ybWF0LlxuICAgICAqL1xuICAgIGdldEZvcm1hdHRlZERheVJhbmdlKGRhdGVGb3JtYXQ6IFR1aURhdGVNb2RlLCBkYXRlU2VwYXJhdG9yOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBmcm9tID0gdGhpcy5mcm9tLmdldEZvcm1hdHRlZERheShkYXRlRm9ybWF0LCBkYXRlU2VwYXJhdG9yKTtcbiAgICAgICAgY29uc3QgdG8gPSB0aGlzLnRvLmdldEZvcm1hdHRlZERheShkYXRlRm9ybWF0LCBkYXRlU2VwYXJhdG9yKTtcblxuICAgICAgICByZXR1cm4gYCR7ZnJvbX0ke1JBTkdFX1NFUEFSQVRPUl9DSEFSfSR7dG99YDtcbiAgICB9XG5cbiAgICBvdmVycmlkZSB0b1N0cmluZyhcbiAgICAgICAgZGF0ZUZvcm1hdDogVHVpRGF0ZU1vZGUgPSBgRE1ZYCxcbiAgICAgICAgZGF0ZVNlcGFyYXRvcjogc3RyaW5nID0gYC5gLFxuICAgICk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb20uZ2V0Rm9ybWF0dGVkRGF5KGRhdGVGb3JtYXQsIGRhdGVTZXBhcmF0b3IpO1xuICAgICAgICBjb25zdCB0byA9IHRoaXMudG8uZ2V0Rm9ybWF0dGVkRGF5KGRhdGVGb3JtYXQsIGRhdGVTZXBhcmF0b3IpO1xuXG4gICAgICAgIHJldHVybiBgJHtmcm9tfSR7UkFOR0VfU0VQQVJBVE9SX0NIQVJ9JHt0b31gO1xuICAgIH1cbn1cbiJdfQ==