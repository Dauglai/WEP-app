import * as i0 from '@angular/core';
import { Directive, ElementRef, Optional, Self, Inject, Renderer2, NgZone, InjectionToken, Input, NgModule } from '@angular/core';
import { tuiCoerceBooleanProperty } from '@taiga-ui/cdk/coercion';
import { ANIMATION_FRAME, WINDOW } from '@ng-web-apis/common';
import { TUI_FOCUSABLE_ITEM_ACCESSOR, TUI_IS_IOS } from '@taiga-ui/cdk/tokens';
import { POLLING_TIME } from '@taiga-ui/cdk/constants';
import * as i1 from 'rxjs';
import { race, timer } from 'rxjs';
import { throttleTime, map, skipWhile, take } from 'rxjs/operators';
import { tuiPx, tuiIsPresent } from '@taiga-ui/cdk/utils';

class AbstractTuiAutofocusHandler {
    constructor(focusable, el) {
        this.focusable = focusable;
        this.el = el;
    }
    get element() {
        var _a;
        return ((_a = this.focusable) === null || _a === void 0 ? void 0 : _a.nativeFocusableElement) || this.el.nativeElement;
    }
    get isTextFieldElement() {
        return this.element.matches(`input, textarea`);
    }
}
AbstractTuiAutofocusHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiAutofocusHandler, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
AbstractTuiAutofocusHandler.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: AbstractTuiAutofocusHandler, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiAutofocusHandler, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined }, { type: i0.ElementRef }]; } });

const TIMEOUT = 1000;
const NG_ANIMATION_SELECTOR = `.ng-animating`;
class TuiDefaultAutofocusHandler extends AbstractTuiAutofocusHandler {
    constructor(focusable, el, animationFrame$) {
        super(focusable, el);
        this.animationFrame$ = animationFrame$;
    }
    setFocus() {
        if (this.isTextFieldElement) {
            race(timer(TIMEOUT), this.animationFrame$.pipe(throttleTime(POLLING_TIME), map(() => this.element.closest(NG_ANIMATION_SELECTOR)), skipWhile(Boolean), take(1))).subscribe(() => this.element.focus());
        }
        else {
            this.element.focus();
        }
    }
}
TuiDefaultAutofocusHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDefaultAutofocusHandler, deps: [{ token: TUI_FOCUSABLE_ITEM_ACCESSOR, optional: true, self: true }, { token: ElementRef }, { token: ANIMATION_FRAME }], target: i0.ɵɵFactoryTarget.Directive });
TuiDefaultAutofocusHandler.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiDefaultAutofocusHandler, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDefaultAutofocusHandler, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }, {
                    type: Inject,
                    args: [TUI_FOCUSABLE_ITEM_ACCESSOR]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i1.Observable, decorators: [{
                    type: Inject,
                    args: [ANIMATION_FRAME]
                }] }]; } });

const TEXTFIELD_ATTRS = [
    `type`,
    `inputMode`,
    `autocomplete`,
    `accept`,
    `min`,
    `max`,
    `step`,
    `pattern`,
    `size`,
    `maxlength`,
];
class TuiIosAutofocusHandler extends AbstractTuiAutofocusHandler {
    constructor(focusable, el, renderer, ngZone, win) {
        super(focusable, el);
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.win = win;
        this.patchCssStyles();
    }
    setFocus() {
        if (this.isTextFieldElement) {
            this.ngZone.runOutsideAngular(() => this.iosWebkitAutofocus());
        }
        else {
            this.element.focus();
        }
    }
    iosWebkitAutofocus() {
        var _a;
        const fakeInput = this.makeFakeInput();
        const duration = this.getDurationTimeBeforeFocus();
        let fakeFocusTimeoutId = 0;
        let elementFocusTimeoutId = 0;
        const blurHandler = () => fakeInput.focus({ preventScroll: true });
        const focusHandler = () => {
            clearTimeout(fakeFocusTimeoutId);
            fakeFocusTimeoutId = this.win.setTimeout(() => {
                clearTimeout(elementFocusTimeoutId);
                fakeInput.removeEventListener(`blur`, blurHandler);
                fakeInput.removeEventListener(`focus`, focusHandler);
                elementFocusTimeoutId = this.win.setTimeout(() => {
                    this.element.focus({ preventScroll: false });
                    fakeInput.remove();
                }, duration);
            });
        };
        fakeInput.addEventListener(`blur`, blurHandler, { once: true });
        fakeInput.addEventListener(`focus`, focusHandler);
        if (this.insideDialog()) {
            this.win.document.body.appendChild(fakeInput);
        }
        else {
            (_a = this.element.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(fakeInput);
        }
        fakeInput.focus({ preventScroll: true });
    }
    /**
     * @note:
     * emulate textfield position in layout with cursor
     * before focus to real textfield element
     *
     * required note:
     * [fakeInput.readOnly = true] ~
     * don't use {readOnly: true} value, it's doesn't work for emulate autofill
     *
     * [fakeInput.style.opacity = 0] ~
     * don't use {opacity: 0}, sometimes it's doesn't work for emulate real input
     *
     * [fakeInput.style.fontSize = 16px] ~
     * disable possible auto zoom
     *
     * [fakeInput.style.top/left] ~
     * emulate position cursor before focus to real textfield element
     */
    makeFakeInput() {
        const fakeInput = this.renderer.createElement(`input`);
        const rect = this.element.getBoundingClientRect();
        this.patchFakeInputFromFocusableElement(fakeInput);
        fakeInput.style.height = tuiPx(rect.height);
        fakeInput.style.width = tuiPx(rect.width / 2);
        fakeInput.style.position = `fixed`;
        fakeInput.style.zIndex = `-99999999`;
        fakeInput.style.caretColor = `transparent`;
        fakeInput.style.color = `transparent`;
        fakeInput.style.cursor = `none`;
        fakeInput.style.fontSize = tuiPx(16);
        fakeInput.style.top = tuiPx(rect.top);
        fakeInput.style.left = tuiPx(rect.left);
        return fakeInput;
    }
    getDurationTimeBeforeFocus() {
        return (parseFloat(this.win
            .getComputedStyle(this.element)
            .getPropertyValue(`--tui-duration`)) || 0);
    }
    /**
     * @note:
     * unfortunately, in older versions of iOS
     * there is a bug that the fake input cursor
     * will move along with the dialog animation
     * and then that dialog will be shaking
     */
    insideDialog() {
        return !!this.element.closest(`tui-dialog`);
    }
    /**
     * @note:
     * This is necessary so that the viewport isn't recalculated
     * and then the dialogs don't shake.
     *
     * Also, we need to fixed height viewport,
     * so that when focusing the dialogs don't shake
     */
    patchCssStyles() {
        const doc = this.win.document;
        for (const element of [doc.documentElement, doc.body]) {
            element.style.setProperty(`overflow`, `auto`);
            element.style.setProperty(`height`, `100%`);
        }
    }
    /**
     * @note:
     * inherit basic attributes values from real input
     * for help iOS detect what do you want see on keyboard,
     * for example [inputMode=numeric, autocomplete=cc-number]
     */
    patchFakeInputFromFocusableElement(fakeInput) {
        TEXTFIELD_ATTRS.forEach(attr => {
            const value = this.element.getAttribute(attr);
            if (tuiIsPresent(value)) {
                fakeInput.setAttribute(attr, value);
            }
        });
    }
}
TuiIosAutofocusHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiIosAutofocusHandler, deps: [{ token: TUI_FOCUSABLE_ITEM_ACCESSOR, optional: true, self: true }, { token: ElementRef }, { token: Renderer2 }, { token: NgZone }, { token: WINDOW }], target: i0.ɵɵFactoryTarget.Directive });
TuiIosAutofocusHandler.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiIosAutofocusHandler, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiIosAutofocusHandler, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }, {
                    type: Inject,
                    args: [TUI_FOCUSABLE_ITEM_ACCESSOR]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i0.Renderer2, decorators: [{
                    type: Inject,
                    args: [Renderer2]
                }] }, { type: i0.NgZone, decorators: [{
                    type: Inject,
                    args: [NgZone]
                }] }, { type: Window, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }]; } });

const TUI_AUTOFOCUS_HANDLER = new InjectionToken(`[TUI_AUTOFOCUS_HANDLER]`);
const TUI_AUTOFOCUS_PROVIDERS = [
    {
        provide: TUI_AUTOFOCUS_HANDLER,
        useFactory: (focusable, el, animationFrame$, renderer, ngZone, win, isIos) => isIos
            ? new TuiIosAutofocusHandler(focusable, el, renderer, ngZone, win)
            : new TuiDefaultAutofocusHandler(focusable, el, animationFrame$),
        deps: [
            [new Optional(), new Self(), TUI_FOCUSABLE_ITEM_ACCESSOR],
            ElementRef,
            ANIMATION_FRAME,
            Renderer2,
            NgZone,
            WINDOW,
            TUI_IS_IOS,
        ],
    },
];

class TuiAutoFocusDirective {
    constructor(handler) {
        this.handler = handler;
        this.autoFocus = true;
    }
    ngAfterViewInit() {
        if (tuiCoerceBooleanProperty(this.autoFocus)) {
            this.focus();
        }
    }
    focus() {
        void Promise.resolve().then(() => this.handler.setFocus());
    }
}
TuiAutoFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiAutoFocusDirective, deps: [{ token: TUI_AUTOFOCUS_HANDLER }], target: i0.ɵɵFactoryTarget.Directive });
TuiAutoFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiAutoFocusDirective, selector: "[tuiAutoFocus]", inputs: { autoFocus: ["tuiAutoFocus", "autoFocus"] }, providers: TUI_AUTOFOCUS_PROVIDERS, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiAutoFocusDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiAutoFocus]',
                    providers: TUI_AUTOFOCUS_PROVIDERS,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_AUTOFOCUS_HANDLER]
                }] }]; }, propDecorators: { autoFocus: [{
                type: Input,
                args: ['tuiAutoFocus']
            }] } });

class TuiAutoFocusModule {
}
TuiAutoFocusModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiAutoFocusModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TuiAutoFocusModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiAutoFocusModule, declarations: [TuiAutoFocusDirective], exports: [TuiAutoFocusDirective] });
TuiAutoFocusModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiAutoFocusModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiAutoFocusModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [TuiAutoFocusDirective],
                    exports: [TuiAutoFocusDirective],
                }]
        }] });

class TuiSynchronousAutofocusHandler extends AbstractTuiAutofocusHandler {
    constructor(focusable, el) {
        super(focusable, el);
    }
    setFocus() {
        this.element.focus();
    }
}
TuiSynchronousAutofocusHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSynchronousAutofocusHandler, deps: [{ token: TUI_FOCUSABLE_ITEM_ACCESSOR, optional: true, self: true }, { token: ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
TuiSynchronousAutofocusHandler.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiSynchronousAutofocusHandler, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSynchronousAutofocusHandler, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }, {
                    type: Inject,
                    args: [TUI_FOCUSABLE_ITEM_ACCESSOR]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }]; } });

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractTuiAutofocusHandler, TUI_AUTOFOCUS_HANDLER, TUI_AUTOFOCUS_PROVIDERS, TuiAutoFocusDirective, TuiAutoFocusModule, TuiDefaultAutofocusHandler, TuiIosAutofocusHandler, TuiSynchronousAutofocusHandler };
//# sourceMappingURL=taiga-ui-cdk-directives-auto-focus.js.map
