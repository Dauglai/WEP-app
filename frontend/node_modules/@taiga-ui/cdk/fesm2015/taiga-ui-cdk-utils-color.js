function tuiHexToRgb(hex) {
    const matches = hex
        .replace(`#`, ``)
        .split(``)
        .map((char, _, array) => (array.length === 3 ? char + char : char))
        .join(``)
        .match(/.{2}/g);
    return matches
        ? matches.map(x => Number.parseInt(x, 16))
        : [0, 0, 0];
}

/**
 * https://stackoverflow.com/a/54024653/2706426
 */
function tuiHsvToRgb(h, s, v) {
    return [hsvToColor(h, s, v, 5), hsvToColor(h, s, v, 3), hsvToColor(h, s, v, 1)];
}
function hsvToColor(h, s, v, n) {
    const k = (n + h / 60) % 6;
    return Math.round(v - v * s * Math.max(Math.min(k, 4 - k, 1), 0));
}

const DEFAULT = [0, 0, 0, 1];
function tuiParseColor(color) {
    const stripped = color
        .replace(`#`, ``)
        .replace(`rgba(`, ``)
        .replace(`rgb(`, ``)
        .replace(`)`, ``);
    const array = stripped.split(`,`).map(item => parseFloat(item));
    if (array.length === 4) {
        return array;
    }
    if (array.length === 3) {
        return array.concat(1);
    }
    const matches = stripped.match(new RegExp(`(.{${stripped.length / 3}})`, `g`));
    if (!matches) {
        return DEFAULT;
    }
    const parsed = matches.map(char => parseInt(stripped.length % 2 ? char + char : char, 16));
    return [
        parsed[0] || DEFAULT[0],
        parsed[1] || DEFAULT[1],
        parsed[2] || DEFAULT[2],
        parsed[3] === undefined ? DEFAULT[3] : parsed[3],
    ];
}

function tuiRgbToHex(r, g, b) {
    return `#${[r, g, b].map(x => x.toString(16).padStart(2, `0`)).join(``)}`;
}

function tuiRgbToHsv(r, g, b) {
    const v = Math.max(r, g, b);
    const n = v - Math.min(r, g, b);
    // eslint-disable-next-line no-nested-ternary
    const h = n && (v === r ? (g - b) / n : v === g ? 2 + (b - r) / n : 4 + (r - g) / n);
    return [60 * (h < 0 ? h + 6 : h), v && n / v, v];
}

/**
 * Generated bundle index. Do not edit.
 */

export { tuiHexToRgb, tuiHsvToRgb, tuiParseColor, tuiRgbToHex, tuiRgbToHsv };
//# sourceMappingURL=taiga-ui-cdk-utils-color.js.map
