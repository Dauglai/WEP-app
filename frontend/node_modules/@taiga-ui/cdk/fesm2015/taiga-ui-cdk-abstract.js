import { __decorate } from 'tslib';
import * as i0 from '@angular/core';
import { EventEmitter, Directive, Input, Output, HostBinding, Optional, Inject, Injectable, TemplateRef, ChangeDetectorRef, ComponentFactoryResolver, Injector, INJECTOR, ElementRef, ViewContainerRef, ViewChild } from '@angular/core';
import * as i1 from '@angular/forms';
import { NgModel } from '@angular/forms';
import { tuiAssert } from '@taiga-ui/cdk/classes';
import { EMPTY_FUNCTION } from '@taiga-ui/cdk/constants';
import { tuiDefaultProp } from '@taiga-ui/cdk/decorators';
import { Subject, merge, Observable, BehaviorSubject } from 'rxjs';
import { takeUntil, ignoreElements, endWith, share } from 'rxjs/operators';
import { tuiIfMap } from '@taiga-ui/cdk/observables';
import { PolymorpheusTemplate } from '@tinkoff/ng-polymorpheus';
import * as i1$1 from '@taiga-ui/cdk/services';
import { TuiIdService } from '@taiga-ui/cdk/services';
import { TuiNoHostException } from '@taiga-ui/cdk/exceptions';
import { DOCUMENT } from '@angular/common';

const TUI = `tui_interactive_`;
/**
 * The most basic class for interactive components
 */
class AbstractTuiInteractive {
    constructor() {
        this.pseudoHover = null;
        this.pseudoActive = null;
        this.pseudoFocus = null;
        /**
         * Determines if component is focusable with keyboard.
         */
        this.focusable = true;
        this.nativeId = ``;
        /**
         * Emits 'true' on focus and 'false' on blur.
         */
        this.focusedChange = new EventEmitter();
        this.focusVisibleChange = new EventEmitter();
        this.focusVisible = false;
        this.autoIdString = `${TUI}${AbstractTuiInteractive.autoId++}${Date.now()}`;
    }
    get computedDisabled() {
        return this.disabled;
    }
    get computedFocusable() {
        return !this.computedDisabled && (this.focusable || this.focused);
    }
    get computedFocused() {
        var _a;
        return !this.computedDisabled && ((_a = this.pseudoFocus) !== null && _a !== void 0 ? _a : this.focused);
    }
    get computedFocusVisible() {
        var _a;
        return !this.computedDisabled && ((_a = this.pseudoFocus) !== null && _a !== void 0 ? _a : this.focusVisible);
    }
    // TODO: 3.0 Consider removing since native input is exposed
    get id() {
        return this.nativeId || this.autoIdString;
    }
    updateFocused(focused) {
        this.focusedChange.emit(focused);
    }
    updateFocusVisible(focusVisible) {
        if (this.focusVisible === focusVisible) {
            return;
        }
        this.focusVisible = focusVisible;
        this.focusVisibleChange.emit(focusVisible);
    }
}
AbstractTuiInteractive.autoId = 0;
AbstractTuiInteractive.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiInteractive, deps: [], target: i0.ɵɵFactoryTarget.Directive });
AbstractTuiInteractive.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: AbstractTuiInteractive, inputs: { pseudoHover: "pseudoHover", pseudoActive: "pseudoActive", pseudoFocus: "pseudoFocus", focusable: "focusable", nativeId: "nativeId" }, outputs: { focusedChange: "focusedChange", focusVisibleChange: "focusVisibleChange" }, host: { properties: { "class._disabled": "this.computedDisabled", "class._focused": "this.computedFocused", "class._focus-visible": "this.computedFocusVisible" } }, ngImport: i0 });
__decorate([
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "pseudoHover", void 0);
__decorate([
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "pseudoActive", void 0);
__decorate([
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "pseudoFocus", void 0);
__decorate([
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "focusable", void 0);
__decorate([
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "nativeId", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiInteractive, decorators: [{
            type: Directive
        }], ctorParameters: function () { return []; }, propDecorators: { pseudoHover: [{
                type: Input
            }], pseudoActive: [{
                type: Input
            }], pseudoFocus: [{
                type: Input
            }], focusable: [{
                type: Input
            }], nativeId: [{
                type: Input
            }], focusedChange: [{
                type: Output
            }], focusVisibleChange: [{
                type: Output
            }], computedDisabled: [{
                type: HostBinding,
                args: [`class._disabled`]
            }], computedFocused: [{
                type: HostBinding,
                args: [`class._focused`]
            }], computedFocusVisible: [{
                type: HostBinding,
                args: [`class._focus-visible`]
            }] } });

class AbstractTuiValueTransformer {
}

/**
 * Basic ControlValueAccessor class to build form components upon
 */
class AbstractTuiControl extends AbstractTuiInteractive {
    constructor(ngControl, cdr, valueTransformer) {
        super();
        this.ngControl = ngControl;
        this.cdr = cdr;
        this.valueTransformer = valueTransformer;
        this.onTouched = EMPTY_FUNCTION;
        this.onChange = EMPTY_FUNCTION;
        this.fallbackValue = this.getFallbackValue();
        this.destroy$ = new Subject();
        this.readOnly = false;
        this.pseudoInvalid = null;
        if (ngDevMode && this.ngControl === null) {
            tuiAssert.assert(false, `NgControl not injected in ${this.constructor.name}!\n`, `Use [(ngModel)] or [formControl] or formControlName for correct work.`);
        }
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
        }
    }
    get computedInvalid() {
        return (this.interactive &&
            (this.pseudoInvalid !== null
                ? this.pseudoInvalid
                : this.touched && this.invalid));
    }
    get value() {
        var _a;
        return (_a = this.previousInternalValue) !== null && _a !== void 0 ? _a : this.fallbackValue;
    }
    set value(value) {
        this.updateValue(value);
    }
    get safeCurrentValue() {
        var _a;
        return (_a = this.rawValue) !== null && _a !== void 0 ? _a : this.fallbackValue;
    }
    get invalid() {
        return this.safeNgControlData(({ invalid }) => invalid, false);
    }
    get valid() {
        return this.safeNgControlData(({ valid }) => valid, false);
    }
    get touched() {
        return this.safeNgControlData(({ touched }) => touched, false);
    }
    get disabled() {
        return this.safeNgControlData(({ disabled }) => disabled, false);
    }
    get interactive() {
        return !this.readOnly && !this.computedDisabled;
    }
    get control() {
        return this.safeNgControlData(({ control }) => control, null);
    }
    get computedName() {
        var _a, _b;
        return (_b = (_a = this.controlName) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null;
    }
    get controlName() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.ngControl) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : null;
    }
    get rawValue() {
        const { ngControl } = this;
        if (ngControl === null) {
            return undefined;
        }
        const controlValue = ngControl instanceof NgModel && this.previousInternalValue === undefined
            ? ngControl.viewModel
            : ngControl.value;
        return this.fromControlValue(controlValue);
    }
    ngOnInit() {
        var _a, _b;
        if (!((_a = this.ngControl) === null || _a === void 0 ? void 0 : _a.valueChanges) || !((_b = this.ngControl) === null || _b === void 0 ? void 0 : _b.statusChanges)) {
            return;
        }
        merge(this.ngControl.valueChanges, this.ngControl.statusChanges)
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => this.refreshLocalValue(this.safeCurrentValue));
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    checkControlUpdate() {
        this.cdr.markForCheck();
    }
    registerOnChange(onChange) {
        this.onChange = (componentValue) => {
            onChange(this.toControlValue(componentValue));
        };
    }
    registerOnTouched(onTouched) {
        this.onTouched = onTouched;
    }
    setDisabledState() {
        this.checkControlUpdate();
    }
    writeValue(value) {
        const controlValue = this.ngControl instanceof NgModel && this.previousInternalValue === undefined
            ? this.ngControl.model
            : value;
        this.refreshLocalValue(this.fromControlValue(controlValue));
    }
    updateFocused(focused) {
        if (!focused) {
            this.controlMarkAsTouched();
        }
        super.updateFocused(focused);
    }
    /**
     * @deprecated use `value` setter
     */
    updateValue(value) {
        if (this.disabled || this.valueIdenticalComparator(this.value, value)) {
            return;
        }
        this.previousInternalValue = value;
        this.controlSetValue(value);
    }
    valueIdenticalComparator(oldValue, newValue) {
        return oldValue === newValue;
    }
    safeNgControlData(extractor, defaultFieldValue) {
        var _a;
        return (_a = (this.ngControl && extractor(this.ngControl))) !== null && _a !== void 0 ? _a : defaultFieldValue;
    }
    controlMarkAsTouched() {
        this.onTouched();
        this.checkControlUpdate();
    }
    controlSetValue(value) {
        this.onChange(value);
        this.checkControlUpdate();
    }
    refreshLocalValue(value) {
        this.previousInternalValue = value;
        this.checkControlUpdate();
    }
    fromControlValue(controlValue) {
        return this.valueTransformer
            ? this.valueTransformer.fromControlValue(controlValue)
            : controlValue;
    }
    toControlValue(componentValue) {
        return this.valueTransformer
            ? this.valueTransformer.toControlValue(componentValue)
            : componentValue;
    }
}
AbstractTuiControl.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiControl, deps: [{ token: i1.NgControl, optional: true }, { token: i0.ChangeDetectorRef }, { token: AbstractTuiValueTransformer, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
AbstractTuiControl.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: AbstractTuiControl, inputs: { readOnly: "readOnly", pseudoInvalid: "pseudoInvalid" }, host: { properties: { "class._readonly": "this.readOnly", "class._invalid": "this.computedInvalid" } }, usesInheritance: true, ngImport: i0 });
__decorate([
    tuiDefaultProp()
], AbstractTuiControl.prototype, "readOnly", void 0);
__decorate([
    tuiDefaultProp()
], AbstractTuiControl.prototype, "pseudoInvalid", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiControl, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1.NgControl, decorators: [{
                    type: Optional
                }] }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [AbstractTuiValueTransformer]
                }] }]; }, propDecorators: { readOnly: [{
                type: Input
            }, {
                type: HostBinding,
                args: [`class._readonly`]
            }], pseudoInvalid: [{
                type: Input
            }], computedInvalid: [{
                type: HostBinding,
                args: [`class._invalid`]
            }] } });
function tuiAsControl(useExisting) {
    return {
        provide: AbstractTuiControl,
        useExisting,
    };
}

class AbstractTuiController {
    constructor() {
        this.change$ = new Subject();
    }
    ngOnChanges() {
        this.change$.next();
    }
}
AbstractTuiController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiController, deps: [], target: i0.ɵɵFactoryTarget.Directive });
AbstractTuiController.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: AbstractTuiController, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiController, decorators: [{
            type: Directive
        }] });

class AbstractTuiDialogService extends Observable {
    constructor(idService) {
        super(observer => this.dialogs$.subscribe(observer));
        this.idService = idService;
        this.dialogs$ = new BehaviorSubject([]);
    }
    open(content, options = {}) {
        return new Observable(observer => {
            const completeWith = (result) => {
                observer.next(result);
                observer.complete();
            };
            const dialog = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), options), { content,
                completeWith, $implicit: observer, component: this.component, createdAt: Date.now(), id: this.idService.generate() });
            this.dialogs$.next([...this.dialogs$.value, dialog]);
            return () => {
                this.dialogs$.next(this.dialogs$.value.filter(item => item !== dialog));
            };
        });
    }
}
AbstractTuiDialogService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiDialogService, deps: [{ token: TuiIdService }], target: i0.ɵɵFactoryTarget.Injectable });
AbstractTuiDialogService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiDialogService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiDialogService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.TuiIdService, decorators: [{
                    type: Inject,
                    args: [TuiIdService]
                }] }]; } });

class AbstractTuiDialogDirective extends PolymorpheusTemplate {
    constructor(templateRef, cdr, service) {
        super(templateRef, cdr);
        this.service = service;
        this.open$ = new Subject();
        this.options = {};
        this.openChange = this.open$.pipe(tuiIfMap(() => this.service.open(this, this.options).pipe(ignoreElements(), endWith(false))), share());
    }
    set open(open) {
        this.open$.next(open);
    }
}
AbstractTuiDialogDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiDialogDirective, deps: [{ token: TemplateRef }, { token: ChangeDetectorRef }, { token: AbstractTuiDialogService }], target: i0.ɵɵFactoryTarget.Directive });
AbstractTuiDialogDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: AbstractTuiDialogDirective, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiDialogDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Inject,
                    args: [TemplateRef]
                }] }, { type: i0.ChangeDetectorRef, decorators: [{
                    type: Inject,
                    args: [ChangeDetectorRef]
                }] }, { type: AbstractTuiDialogService, decorators: [{
                    type: Inject,
                    args: [AbstractTuiDialogService]
                }] }]; } });

class AbstractTuiMultipleControl extends AbstractTuiControl {
    clear() {
        this.value = [];
    }
    getFallbackValue() {
        return [];
    }
}
AbstractTuiMultipleControl.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiMultipleControl, deps: null, target: i0.ɵɵFactoryTarget.Directive });
AbstractTuiMultipleControl.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: AbstractTuiMultipleControl, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiMultipleControl, decorators: [{
            type: Directive
        }] });

class AbstractTuiNullableControl extends AbstractTuiControl {
    getFallbackValue() {
        return null;
    }
}
AbstractTuiNullableControl.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiNullableControl, deps: null, target: i0.ɵɵFactoryTarget.Directive });
AbstractTuiNullableControl.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: AbstractTuiNullableControl, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiNullableControl, decorators: [{
            type: Directive
        }] });

/**
 * Abstract service for displaying portals
 */
class AbstractTuiPortalService {
    get safeHost() {
        if (!this.host) {
            throw new TuiNoHostException();
        }
        return this.host;
    }
    attach(host) {
        this.host = host;
    }
    add(component) {
        return this.safeHost.addComponentChild(component);
    }
    remove({ hostView }) {
        hostView.destroy();
    }
    addTemplate(templateRef, context) {
        return this.safeHost.addTemplateChild(templateRef, context);
    }
    removeTemplate(viewRef) {
        viewRef.destroy();
    }
}
AbstractTuiPortalService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiPortalService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
AbstractTuiPortalService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiPortalService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiPortalService, decorators: [{
            type: Injectable
        }] });

/**
 * Abstract class for host element for dynamically created portals.
 */
class AbstractTuiPortalHostComponent {
    constructor(injector, el, portalService) {
        this.injector = injector;
        this.el = el;
        portalService.attach(this);
    }
    get clientRect() {
        return this.el.nativeElement.getBoundingClientRect();
    }
    addComponentChild(component) {
        const parent = component.createInjector(this.injector);
        const resolver = parent.get(ComponentFactoryResolver);
        const factory = resolver.resolveComponentFactory(component.component);
        const providers = [{ provide: AbstractTuiPortalHostComponent, useValue: this }];
        const injector = Injector.create({ parent, providers });
        const ref = this.vcr.createComponent(factory, undefined, injector);
        ref.changeDetectorRef.detectChanges();
        return ref;
    }
    addTemplateChild(templateRef, context) {
        return this.vcr.createEmbeddedView(templateRef, context);
    }
}
AbstractTuiPortalHostComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiPortalHostComponent, deps: [{ token: INJECTOR }, { token: ElementRef }, { token: AbstractTuiPortalService }], target: i0.ɵɵFactoryTarget.Directive });
AbstractTuiPortalHostComponent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: AbstractTuiPortalHostComponent, viewQueries: [{ propertyName: "vcr", first: true, predicate: ["viewContainer"], descendants: true, read: ViewContainerRef }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiPortalHostComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.Injector, decorators: [{
                    type: Inject,
                    args: [INJECTOR]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: AbstractTuiPortalService, decorators: [{
                    type: Inject,
                    args: [AbstractTuiPortalService]
                }] }]; }, propDecorators: { vcr: [{
                type: ViewChild,
                args: [`viewContainer`, { read: ViewContainerRef }]
            }] } });

/**
 * Use this abstract class to create your own toggleable themes.
 * A component extending this class must have CSS variables definitions
 * and have ViewEncapsulation set to NONE. A boolean input allows to
 * switch theme on or off.
 */
class AbstractTuiThemeSwitcher {
    constructor(doc) {
        this.doc = doc;
        if (this.style !== null) {
            this.addTheme();
            return;
        }
        const styles = this.doc.head.querySelectorAll(`style`);
        this.constructor.style =
            styles[styles.length - 1];
    }
    get style() {
        return this.constructor.style;
    }
    ngOnDestroy() {
        this.removeTheme();
    }
    addTheme() {
        if (this.style) {
            this.doc.head.appendChild(this.style);
        }
    }
    removeTheme() {
        if (this.style && this.doc.head.contains(this.style)) {
            this.doc.head.removeChild(this.style);
        }
    }
}
AbstractTuiThemeSwitcher.style = null;
AbstractTuiThemeSwitcher.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiThemeSwitcher, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive });
AbstractTuiThemeSwitcher.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: AbstractTuiThemeSwitcher, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: AbstractTuiThemeSwitcher, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractTuiControl, AbstractTuiController, AbstractTuiDialogDirective, AbstractTuiDialogService, AbstractTuiInteractive, AbstractTuiMultipleControl, AbstractTuiNullableControl, AbstractTuiPortalHostComponent, AbstractTuiPortalService, AbstractTuiThemeSwitcher, AbstractTuiValueTransformer, tuiAsControl };
//# sourceMappingURL=taiga-ui-cdk-abstract.js.map
