import * as i0 from '@angular/core';
import { Injectable, ComponentFactoryResolver, INJECTOR, Inject, ElementRef, ChangeDetectorRef, Self, NgZone, PLATFORM_ID } from '@angular/core';
import * as i1 from 'rxjs';
import { ReplaySubject, Observable, defer, merge, fromEvent, of, timer, from } from 'rxjs';
import { tuiFocusVisibleObservable, tuiWatch, tuiTypedFromEvent, tuiZoneOptimized, tuiZonefree, tuiPreventDefault } from '@taiga-ui/cdk/observables';
import { takeUntil, delay, throttleTime, map, startWith, distinctUntilChanged, switchMap, filter, pairwise, repeat, catchError, debounceTime, share, tap, shareReplay, scan } from 'rxjs/operators';
import { WINDOW, ANIMATION_FRAME, PERFORMANCE } from '@ng-web-apis/common';
import { POLLING_TIME, EMPTY_ARRAY } from '@taiga-ui/cdk/constants';
import { tuiGetElementObscures } from '@taiga-ui/cdk/utils/dom';
import { DOCUMENT, isPlatformServer } from '@angular/common';
import { ResizeObserverService, RESIZE_OBSERVER_SUPPORT, RESIZE_OPTION_BOX } from '@ng-web-apis/resize-observer';
import { tuiAssert } from '@taiga-ui/cdk/classes';
import { tuiClamp } from '@taiga-ui/cdk/utils/math';
import { tuiEaseInOutQuad, tuiGetSwipeDirection, tuiIsPresent } from '@taiga-ui/cdk/utils/miscellaneous';
import { __awaiter } from 'tslib';
import { fromFetch } from 'rxjs/fetch';
import { TUI_SWIPE_OPTIONS, TUI_ZOOM_OPTIONS } from '@taiga-ui/cdk/tokens';
import { tuiDistanceBetweenTouches } from '@taiga-ui/cdk/utils';

/**
 * @note:
 * Observable abstraction over ngOnDestroy to use with takeUntil
 *
 * Why we use `ReplaySubject` instead of `Subject`?
 * Well, we’ll use ReplaySubject to emit the last message in case
 * the subscription is ended after the component is destroyed.
 */
class TuiDestroyService extends ReplaySubject {
    constructor() {
        super(1);
    }
    ngOnDestroy() {
        this.next();
        this.complete();
    }
}
TuiDestroyService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDestroyService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
TuiDestroyService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDestroyService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDestroyService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

/**
 * Service to use styles with directives
 */
class TuiDirectiveStylesService {
    constructor(resolver, injector) {
        this.resolver = resolver;
        this.injector = injector;
        this.map = new Map();
    }
    addComponent(component) {
        if (!this.map.has(component)) {
            this.map.set(component, this.resolver.resolveComponentFactory(component).create(this.injector));
        }
    }
}
TuiDirectiveStylesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDirectiveStylesService, deps: [{ token: ComponentFactoryResolver }, { token: INJECTOR }], target: i0.ɵɵFactoryTarget.Injectable });
TuiDirectiveStylesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDirectiveStylesService, providedIn: `root` });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDirectiveStylesService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: `root`,
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver, decorators: [{
                    type: Inject,
                    args: [ComponentFactoryResolver]
                }] }, { type: i0.Injector, decorators: [{
                    type: Inject,
                    args: [INJECTOR]
                }] }]; } });

/**
 * Service to imitate :focus-visible
 * (https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible)
 * in browsers that do not support it
 */
class TuiFocusVisibleService extends Observable {
    constructor({ nativeElement }, cdr, destroy$) {
        super(subscriber => this.focusVisible$.subscribe(subscriber));
        this.focusVisible$ = tuiFocusVisibleObservable(nativeElement).pipe(tuiWatch(cdr), takeUntil(destroy$));
    }
}
TuiFocusVisibleService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiFocusVisibleService, deps: [{ token: ElementRef }, { token: ChangeDetectorRef }, { token: TuiDestroyService, self: true }], target: i0.ɵɵFactoryTarget.Injectable });
TuiFocusVisibleService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiFocusVisibleService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiFocusVisibleService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i0.ChangeDetectorRef, decorators: [{
                    type: Inject,
                    args: [ChangeDetectorRef]
                }] }, { type: i1.Observable, decorators: [{
                    type: Self
                }, {
                    type: Inject,
                    args: [TuiDestroyService]
                }] }]; } });

const TUI = `tui_`;
/**
 * Generates unique ids
 */
class TuiIdService {
    generate() {
        return `${TUI}${TuiIdService.autoId++}${Date.now()}`;
    }
}
TuiIdService.autoId = 0;
TuiIdService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiIdService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
TuiIdService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiIdService, providedIn: `root` });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiIdService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: `root`,
                }]
        }] });

/**
 * Service that subscribes to scroll events of all parent elements
 */
class TuiParentsScrollService extends Observable {
    constructor(el, win) {
        super(subscriber => this.callback$.subscribe(subscriber));
        this.callback$ = defer(() => {
            let { nativeElement } = el;
            const eventTargets = [win, nativeElement];
            while (nativeElement.parentElement) {
                nativeElement = nativeElement.parentElement;
                eventTargets.push(nativeElement);
            }
            return merge(...eventTargets.map(element => tuiTypedFromEvent(element, `scroll`)));
        });
    }
}
TuiParentsScrollService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiParentsScrollService, deps: [{ token: ElementRef }, { token: WINDOW }], target: i0.ɵɵFactoryTarget.Injectable });
TuiParentsScrollService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiParentsScrollService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiParentsScrollService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: Window, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }]; } });

// @bad TODO: Consider Intersection Observer with fallback to current implementation
/**
 * Service that monitors element visibility by subscribing to scrolls
 * and polling with set interval, returns either null or an array
 * of elements that overlap given element edges
 */
class TuiObscuredService extends Observable {
    constructor(parentsScroll$, { nativeElement }, ngZone, win, destroy$, animationFrame$) {
        super(subscriber => this.obscured$.subscribe(subscriber));
        this.obscured$ = merge(
        // delay is added so it will not interfere with other listeners
        merge(parentsScroll$, fromEvent(win, `resize`)).pipe(delay(0)), animationFrame$.pipe(throttleTime(POLLING_TIME))).pipe(map(() => tuiGetElementObscures(nativeElement)), startWith(null), distinctUntilChanged(), tuiZoneOptimized(ngZone), takeUntil(destroy$));
    }
}
TuiObscuredService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiObscuredService, deps: [{ token: TuiParentsScrollService, self: true }, { token: ElementRef }, { token: NgZone }, { token: WINDOW }, { token: TuiDestroyService, self: true }, { token: ANIMATION_FRAME }], target: i0.ɵɵFactoryTarget.Injectable });
TuiObscuredService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiObscuredService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiObscuredService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: TuiParentsScrollService, decorators: [{
                    type: Inject,
                    args: [TuiParentsScrollService]
                }, {
                    type: Self
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i0.NgZone, decorators: [{
                    type: Inject,
                    args: [NgZone]
                }] }, { type: Window, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }, { type: i1.Observable, decorators: [{
                    type: Self
                }, {
                    type: Inject,
                    args: [TuiDestroyService]
                }] }, { type: i1.Observable, decorators: [{
                    type: Inject,
                    args: [ANIMATION_FRAME]
                }] }]; } });

class TuiPanService extends Observable {
    constructor({ nativeElement }, doc) {
        super(subscriber => {
            merge(tuiTypedFromEvent(nativeElement, `touchstart`, { passive: true }), tuiTypedFromEvent(nativeElement, `mousedown`))
                .pipe(switchMap(() => merge(tuiTypedFromEvent(doc, `touchmove`, {
                passive: true,
            }).pipe(filter(({ touches }) => touches.length < 2), map(({ touches }) => touches[0])), tuiTypedFromEvent(doc, `mousemove`))), pairwise(), map(([first, second]) => {
                const deltaX = second.clientX - first.clientX;
                const deltaY = second.clientY - first.clientY;
                return [deltaX, deltaY];
            }), 
            // eslint-disable-next-line rxjs/no-unsafe-takeuntil
            takeUntil(merge(tuiTypedFromEvent(doc, `touchend`), tuiTypedFromEvent(doc, `mouseup`))), repeat())
                .subscribe(subscriber);
        });
    }
}
TuiPanService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiPanService, deps: [{ token: ElementRef }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });
TuiPanService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiPanService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiPanService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });

class TuiResizeService extends ResizeObserverService {
    constructor(el, ngZone, destroy$, support, box, animationFrame$) {
        super(el, ngZone, support, box);
        return this.pipe(catchError(() => 
        /**
         * @note: if not supported ResizeObserver
         * remove `catchError` after supports modern browsers
         */
        animationFrame$.pipe(throttleTime(POLLING_TIME), map(() => `${el.nativeElement.clientWidth} ${el.nativeElement.clientHeight}`), distinctUntilChanged(), map(() => EMPTY_ARRAY))), debounceTime(0), tuiZonefree(ngZone), share(), takeUntil(destroy$));
    }
}
TuiResizeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiResizeService, deps: [{ token: ElementRef }, { token: NgZone }, { token: TuiDestroyService, self: true }, { token: RESIZE_OBSERVER_SUPPORT }, { token: RESIZE_OPTION_BOX }, { token: ANIMATION_FRAME }], target: i0.ɵɵFactoryTarget.Injectable });
TuiResizeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiResizeService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiResizeService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i0.NgZone, decorators: [{
                    type: Inject,
                    args: [NgZone]
                }] }, { type: i1.Observable, decorators: [{
                    type: Self
                }, {
                    type: Inject,
                    args: [TuiDestroyService]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [RESIZE_OBSERVER_SUPPORT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [RESIZE_OPTION_BOX]
                }] }, { type: i1.Observable, decorators: [{
                    type: Inject,
                    args: [ANIMATION_FRAME]
                }] }]; } });

const SCROLL_TIME = 300;
class TuiScrollService {
    constructor(performanceRef, animationFrame$) {
        this.performanceRef = performanceRef;
        this.animationFrame$ = animationFrame$;
    }
    scroll$(elementOrWindow, scrollTop, scrollLeft = getX(elementOrWindow), duration = SCROLL_TIME) {
        ngDevMode && tuiAssert.assert(duration >= 0, `Duration cannot be negative`);
        ngDevMode && tuiAssert.assert(scrollTop >= 0, `scrollTop cannot be negative`);
        ngDevMode && tuiAssert.assert(scrollLeft >= 0, `scrollLeft cannot be negative`);
        const initialTop = getY(elementOrWindow);
        const initialLeft = getX(elementOrWindow);
        const deltaTop = scrollTop - initialTop;
        const deltaLeft = scrollLeft - initialLeft;
        const observable = !duration
            ? of([scrollTop, scrollLeft])
            : defer(() => of(this.performanceRef.now())).pipe(switchMap(start => this.animationFrame$.pipe(map(now => now - start))), map(elapsed => tuiEaseInOutQuad(tuiClamp(elapsed / duration, 0, 1))), map(percent => [
                initialTop + deltaTop * percent,
                initialLeft + deltaLeft * percent,
            ]), takeUntil(timer(duration)));
        return observable.pipe(tap(([scrollTop, scrollLeft]) => {
            var _a;
            (_a = elementOrWindow.scrollTo) === null || _a === void 0 ? void 0 : _a.call(elementOrWindow, scrollLeft, scrollTop);
        }));
    }
}
TuiScrollService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiScrollService, deps: [{ token: PERFORMANCE }, { token: ANIMATION_FRAME }], target: i0.ɵɵFactoryTarget.Injectable });
TuiScrollService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiScrollService, providedIn: `root` });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiScrollService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: `root`,
                }]
        }], ctorParameters: function () { return [{ type: Performance, decorators: [{
                    type: Inject,
                    args: [PERFORMANCE]
                }] }, { type: i1.Observable, decorators: [{
                    type: Inject,
                    args: [ANIMATION_FRAME]
                }] }]; } });
function getX(elementOrWindow) {
    return `scrollX` in elementOrWindow
        ? elementOrWindow.scrollX
        : elementOrWindow.scrollLeft;
}
function getY(elementOrWindow) {
    return `scrollY` in elementOrWindow
        ? elementOrWindow.scrollY
        : elementOrWindow.scrollTop;
}

class TuiStaticRequestService {
    constructor(win, platformId) {
        this.win = win;
        this.platformId = platformId;
        this.cache = new Map();
    }
    request(url) {
        const cache = this.cache.get(url);
        if (cache) {
            return cache;
        }
        const response$ = `AbortController` in this.win || isPlatformServer(this.platformId)
            ? fromFetch(url)
            : /**
               * Fallback for Firefox 55 and 56
               * TODO: drop after browser support bump
               */
                defer(() => from(fetch(url)));
        const piped = response$.pipe(switchMap((res) => __awaiter(this, void 0, void 0, function* () { return res.text(); })), shareReplay({ bufferSize: 1, refCount: false }));
        this.cache.set(url, piped);
        return piped;
    }
}
TuiStaticRequestService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiStaticRequestService, deps: [{ token: WINDOW }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });
TuiStaticRequestService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiStaticRequestService, providedIn: `root` });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiStaticRequestService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: `root`,
                }]
        }], ctorParameters: function () { return [{ type: Window, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }]; } });

class TuiSwipeService extends Observable {
    constructor({ nativeElement }, { timeout, threshold }, doc) {
        super(subscriber => {
            merge(tuiTypedFromEvent(nativeElement, `touchstart`, { passive: true }), tuiTypedFromEvent(doc, `touchend`))
                .pipe(pairwise(), filter(([first, second]) => !!first.touches.length &&
                first.touches[0].identifier ===
                    second.changedTouches[0].identifier), map(([start, end]) => {
                const startX = start.touches[0].clientX;
                const startY = start.touches[0].clientY;
                const endX = end.changedTouches[0].clientX;
                const endY = end.changedTouches[0].clientY;
                const distanceX = startX - endX;
                const distanceY = startY - endY;
                const duration = end.timeStamp - start.timeStamp;
                if ((Math.abs(distanceX) > threshold ||
                    Math.abs(distanceY) > threshold) &&
                    duration < timeout) {
                    return {
                        direction: tuiGetSwipeDirection(distanceX, distanceY),
                        events: [start, end],
                    };
                }
                return null;
            }), filter(tuiIsPresent))
                .subscribe(subscriber);
        });
    }
}
TuiSwipeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSwipeService, deps: [{ token: ElementRef }, { token: TUI_SWIPE_OPTIONS }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });
TuiSwipeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSwipeService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSwipeService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_SWIPE_OPTIONS]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });

const TOUCH_SENSITIVITY = 0.01;
class TuiZoomService extends Observable {
    constructor({ nativeElement }, { wheelSensitivity }) {
        super(subscriber => {
            merge(tuiTypedFromEvent(nativeElement, `touchstart`, { passive: true }).pipe(filter(({ touches }) => touches.length > 1), switchMap(startEvent => tuiTypedFromEvent(nativeElement, `touchmove`, {
                passive: true,
            }).pipe(tuiPreventDefault(), scan((prev, event) => {
                const distance = tuiDistanceBetweenTouches(event);
                return {
                    event,
                    distance,
                    delta: (distance - prev.distance) *
                        TOUCH_SENSITIVITY,
                };
            }, {
                event: startEvent,
                distance: tuiDistanceBetweenTouches(startEvent),
                delta: 0,
            }), map(({ event, delta }) => {
                const clientX = (event.touches[0].clientX +
                    event.touches[1].clientX) /
                    2;
                const clientY = (event.touches[0].clientY +
                    event.touches[1].clientY) /
                    2;
                return { clientX, clientY, delta, event };
            }), takeUntil(tuiTypedFromEvent(nativeElement, `touchend`))))), tuiTypedFromEvent(nativeElement, `wheel`, { passive: false }).pipe(tuiPreventDefault(), map(wheel => ({
                clientX: wheel.clientX,
                clientY: wheel.clientY,
                delta: -wheel.deltaY * wheelSensitivity,
                event: wheel,
            })))).subscribe(subscriber);
        });
    }
}
TuiZoomService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiZoomService, deps: [{ token: ElementRef }, { token: TUI_ZOOM_OPTIONS }], target: i0.ɵɵFactoryTarget.Injectable });
TuiZoomService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiZoomService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiZoomService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_ZOOM_OPTIONS]
                }] }]; } });

/**
 * Generated bundle index. Do not edit.
 */

export { TuiDestroyService, TuiDirectiveStylesService, TuiFocusVisibleService, TuiIdService, TuiObscuredService, TuiPanService, TuiParentsScrollService, TuiResizeService, TuiScrollService, TuiStaticRequestService, TuiSwipeService, TuiZoomService };
//# sourceMappingURL=taiga-ui-cdk-services.js.map
