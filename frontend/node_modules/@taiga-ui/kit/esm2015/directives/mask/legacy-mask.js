/* eslint-disable */
/**
 * Copied from
 * {@link https://github.com/text-mask/text-mask/blob/master/angular2/src/angular2TextMask.ts angular2-text-mask}
 * ___
 * "angular2-text-mask" is a legacy not-maintained library. It is published using legacy View Engine distribution.
 * Stackblitz fails to run "View Engine"-libraries in Ivy application.
 * See {@link https://github.com/Tinkoff/taiga-ui/issues/2541#issuecomment-1235516443 this comment}.
 */
import { Directive, forwardRef, Inject, Input, NgModule, Optional, } from '@angular/core';
import { COMPOSITION_BUFFER_MODE, NG_VALUE_ACCESSOR, } from '@angular/forms';
import { ɵgetDOM as getDOM } from '@angular/platform-browser';
import { TUI_LEGACY_MASK } from '@taiga-ui/core';
import { createTextMaskInputElement } from 'text-mask-core';
import * as i0 from "@angular/core";
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 */
function _isAndroid() {
    const userAgent = getDOM() ? getDOM().getUserAgent() : '';
    return /android (\d+)/.test(userAgent.toLowerCase());
}
/**
 * @internal
 * @deprecated
 * Don't use it! It can be deleted at any time (even in minor releases).
 * Use {@link https://github.com/text-mask/text-mask/tree/master/angular2 angular2-text-mask} instead.
 */
export class MaskedInputDirective {
    constructor(_renderer, _elementRef, _compositionMode) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._compositionMode = _compositionMode;
        this.textMaskConfig = {
            mask: [],
            guide: true,
            placeholderChar: '_',
            pipe: undefined,
            keepCharPositions: false,
        };
        this.onChange = (_) => { };
        this.onTouched = () => { };
        /** Whether the user is creating a composition string (IME events). */
        this._composing = false;
        if (this._compositionMode == null) {
            this._compositionMode = !_isAndroid();
        }
    }
    ngOnChanges() {
        this._setupMask(true);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(this.inputElement.value);
        }
    }
    writeValue(value) {
        this._setupMask();
        // set the initial value for cases where the mask is disabled
        const normalizedValue = value == null ? '' : value;
        this._renderer.setProperty(this.inputElement, 'value', normalizedValue);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(value);
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    _handleInput(value) {
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this._setupMask();
            if (this.textMaskInputElement !== undefined) {
                this.textMaskInputElement.update(value);
                // get the updated value
                value = this.inputElement.value;
                this.onChange(value);
            }
        }
    }
    _setupMask(create = false) {
        if (!this.inputElement) {
            if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {
                // `textMask` directive is used directly on an input element
                this.inputElement = this._elementRef.nativeElement;
            }
            else {
                // `textMask` directive is used on an abstracted input element, `md-input-container`, etc
                this.inputElement =
                    this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];
            }
        }
        if (this.inputElement && create) {
            this.textMaskInputElement = createTextMaskInputElement(Object.assign({ inputElement: this.inputElement }, this.textMaskConfig));
        }
    }
    _compositionStart() {
        this._composing = true;
    }
    _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this._handleInput(value);
    }
}
MaskedInputDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MaskedInputDirective, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }, { token: COMPOSITION_BUFFER_MODE, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
MaskedInputDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: MaskedInputDirective, selector: "[textMask]", inputs: { textMaskConfig: ["textMask", "textMaskConfig"] }, host: { listeners: { "input": "_handleInput($event.target.value)", "blur": "onTouched()", "compositionstart": "_compositionStart()", "compositionend": "_compositionEnd($event.target.value)" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => MaskedInputDirective),
            multi: true,
        },
        {
            provide: TUI_LEGACY_MASK,
            useExisting: forwardRef(() => MaskedInputDirective),
        },
    ], exportAs: ["textMask"], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MaskedInputDirective, decorators: [{
            type: Directive,
            args: [{
                    host: {
                        '(input)': '_handleInput($event.target.value)',
                        '(blur)': 'onTouched()',
                        '(compositionstart)': '_compositionStart()',
                        '(compositionend)': '_compositionEnd($event.target.value)',
                    },
                    selector: '[textMask]',
                    exportAs: 'textMask',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => MaskedInputDirective),
                            multi: true,
                        },
                        {
                            provide: TUI_LEGACY_MASK,
                            useExisting: forwardRef(() => MaskedInputDirective),
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [COMPOSITION_BUFFER_MODE]
                }] }]; }, propDecorators: { textMaskConfig: [{
                type: Input,
                args: ['textMask']
            }] } });
/**
 * @internal
 * @deprecated
 * Don't use it! It can be deleted at any time (even in minor releases).
 * Use {@link https://github.com/text-mask/text-mask/tree/master/angular2 angular2-text-mask} instead.
 */
export class TextMaskModule {
}
TextMaskModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TextMaskModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TextMaskModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TextMaskModule, declarations: [MaskedInputDirective], exports: [MaskedInputDirective] });
TextMaskModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TextMaskModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TextMaskModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [MaskedInputDirective],
                    exports: [MaskedInputDirective],
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGVnYWN5LW1hc2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9raXQvZGlyZWN0aXZlcy9tYXNrL2xlZ2FjeS1tYXNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG9CQUFvQjtBQUNwQjs7Ozs7OztHQU9HO0FBQ0gsT0FBTyxFQUNILFNBQVMsRUFFVCxVQUFVLEVBQ1YsTUFBTSxFQUNOLEtBQUssRUFDTCxRQUFRLEVBRVIsUUFBUSxHQUVYLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFDSCx1QkFBdUIsRUFFdkIsaUJBQWlCLEdBQ3BCLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEIsT0FBTyxFQUFDLE9BQU8sSUFBSSxNQUFNLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUM1RCxPQUFPLEVBQUMsZUFBZSxFQUFxQixNQUFNLGdCQUFnQixDQUFDO0FBQ25FLE9BQU8sRUFBQywwQkFBMEIsRUFBQyxNQUFNLGdCQUFnQixDQUFDOztBQUUxRDs7O0dBR0c7QUFDSCxTQUFTLFVBQVU7SUFDZixNQUFNLFNBQVMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUMxRCxPQUFPLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7QUFDekQsQ0FBQztBQUVEOzs7OztHQUtHO0FBc0JILE1BQU0sT0FBTyxvQkFBb0I7SUFrQjdCLFlBQ1ksU0FBb0IsRUFDcEIsV0FBdUIsRUFDc0IsZ0JBQXlCO1FBRnRFLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFDcEIsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFDc0IscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFTO1FBcEIvRCxtQkFBYyxHQUF1QjtZQUNwRCxJQUFJLEVBQUUsRUFBRTtZQUNSLEtBQUssRUFBRSxJQUFJO1lBQ1gsZUFBZSxFQUFFLEdBQUc7WUFDcEIsSUFBSSxFQUFFLFNBQVM7WUFDZixpQkFBaUIsRUFBRSxLQUFLO1NBQzNCLENBQUM7UUFFRixhQUFRLEdBQUcsQ0FBQyxDQUFNLEVBQUUsRUFBRSxHQUFFLENBQUMsQ0FBQztRQUMxQixjQUFTLEdBQUcsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFDO1FBS3JCLHNFQUFzRTtRQUM5RCxlQUFVLEdBQUcsS0FBSyxDQUFDO1FBT3ZCLElBQUksSUFBSSxDQUFDLGdCQUFnQixJQUFJLElBQUksRUFBRTtZQUMvQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUN6QztJQUNMLENBQUM7SUFFRCxXQUFXO1FBQ1AsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0QixJQUFJLElBQUksQ0FBQyxvQkFBb0IsS0FBSyxTQUFTLEVBQUU7WUFDekMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzdEO0lBQ0wsQ0FBQztJQUVELFVBQVUsQ0FBQyxLQUFVO1FBQ2pCLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUVsQiw2REFBNkQ7UUFDN0QsTUFBTSxlQUFlLEdBQUcsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFDbkQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFFeEUsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEtBQUssU0FBUyxFQUFFO1lBQ3pDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDM0M7SUFDTCxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsRUFBb0I7UUFDakMsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUNELGlCQUFpQixDQUFDLEVBQWM7UUFDNUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVELGdCQUFnQixDQUFDLFVBQW1CO1FBQ2hDLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUN0QixJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFDOUIsVUFBVSxFQUNWLFVBQVUsQ0FDYixDQUFDO0lBQ04sQ0FBQztJQUVELFlBQVksQ0FBQyxLQUFVO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDdkUsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBRWxCLElBQUksSUFBSSxDQUFDLG9CQUFvQixLQUFLLFNBQVMsRUFBRTtnQkFDekMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFFeEMsd0JBQXdCO2dCQUN4QixLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUM7Z0JBQ2hDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDeEI7U0FDSjtJQUNMLENBQUM7SUFFRCxVQUFVLENBQUMsTUFBTSxHQUFHLEtBQUs7UUFDckIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDcEIsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLEtBQUssT0FBTyxFQUFFO2dCQUNsRSw0REFBNEQ7Z0JBQzVELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUM7YUFDdEQ7aUJBQU07Z0JBQ0gseUZBQXlGO2dCQUN6RixJQUFJLENBQUMsWUFBWTtvQkFDYixJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUN2RTtTQUNKO1FBRUQsSUFBSSxJQUFJLENBQUMsWUFBWSxJQUFJLE1BQU0sRUFBRTtZQUM3QixJQUFJLENBQUMsb0JBQW9CLEdBQUcsMEJBQTBCLENBQ2xELE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBQyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FDeEUsQ0FBQztTQUNMO0lBQ0wsQ0FBQztJQUVELGlCQUFpQjtRQUNiLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO0lBQzNCLENBQUM7SUFFRCxlQUFlLENBQUMsS0FBVTtRQUN0QixJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztRQUN4QixJQUFJLENBQUMsZ0JBQWdCLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN0RCxDQUFDOztrSEF0R1Esb0JBQW9CLHFFQXFCTCx1QkFBdUI7c0dBckJ0QyxvQkFBb0Isb1NBWmxCO1FBQ1A7WUFDSSxPQUFPLEVBQUUsaUJBQWlCO1lBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsb0JBQW9CLENBQUM7WUFDbkQsS0FBSyxFQUFFLElBQUk7U0FDZDtRQUNEO1lBQ0ksT0FBTyxFQUFFLGVBQWU7WUFDeEIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQztTQUN0RDtLQUNKOzRGQUVRLG9CQUFvQjtrQkFyQmhDLFNBQVM7bUJBQUM7b0JBQ1AsSUFBSSxFQUFFO3dCQUNGLFNBQVMsRUFBRSxtQ0FBbUM7d0JBQzlDLFFBQVEsRUFBRSxhQUFhO3dCQUN2QixvQkFBb0IsRUFBRSxxQkFBcUI7d0JBQzNDLGtCQUFrQixFQUFFLHNDQUFzQztxQkFDN0Q7b0JBQ0QsUUFBUSxFQUFFLFlBQVk7b0JBQ3RCLFFBQVEsRUFBRSxVQUFVO29CQUNwQixTQUFTLEVBQUU7d0JBQ1A7NEJBQ0ksT0FBTyxFQUFFLGlCQUFpQjs0QkFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUscUJBQXFCLENBQUM7NEJBQ25ELEtBQUssRUFBRSxJQUFJO3lCQUNkO3dCQUNEOzRCQUNJLE9BQU8sRUFBRSxlQUFlOzRCQUN4QixXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxxQkFBcUIsQ0FBQzt5QkFDdEQ7cUJBQ0o7aUJBQ0o7OzBCQXNCUSxRQUFROzswQkFBSSxNQUFNOzJCQUFDLHVCQUF1Qjs0Q0FwQjVCLGNBQWM7c0JBQWhDLEtBQUs7dUJBQUMsVUFBVTs7QUF3R3JCOzs7OztHQUtHO0FBS0gsTUFBTSxPQUFPLGNBQWM7OzRHQUFkLGNBQWM7NkdBQWQsY0FBYyxpQkFuSGQsb0JBQW9CLGFBQXBCLG9CQUFvQjs2R0FtSHBCLGNBQWM7NEZBQWQsY0FBYztrQkFKMUIsUUFBUTttQkFBQztvQkFDTixZQUFZLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQztvQkFDcEMsT0FBTyxFQUFFLENBQUMsb0JBQW9CLENBQUM7aUJBQ2xDIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogQ29waWVkIGZyb21cbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vdGV4dC1tYXNrL3RleHQtbWFzay9ibG9iL21hc3Rlci9hbmd1bGFyMi9zcmMvYW5ndWxhcjJUZXh0TWFzay50cyBhbmd1bGFyMi10ZXh0LW1hc2t9XG4gKiBfX19cbiAqIFwiYW5ndWxhcjItdGV4dC1tYXNrXCIgaXMgYSBsZWdhY3kgbm90LW1haW50YWluZWQgbGlicmFyeS4gSXQgaXMgcHVibGlzaGVkIHVzaW5nIGxlZ2FjeSBWaWV3IEVuZ2luZSBkaXN0cmlidXRpb24uXG4gKiBTdGFja2JsaXR6IGZhaWxzIHRvIHJ1biBcIlZpZXcgRW5naW5lXCItbGlicmFyaWVzIGluIEl2eSBhcHBsaWNhdGlvbi5cbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL1RpbmtvZmYvdGFpZ2EtdWkvaXNzdWVzLzI1NDEjaXNzdWVjb21tZW50LTEyMzU1MTY0NDMgdGhpcyBjb21tZW50fS5cbiAqL1xuaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBOZ01vZHVsZSxcbiAgICBPbkNoYW5nZXMsXG4gICAgT3B0aW9uYWwsXG4gICAgUmVuZGVyZXIyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgQ09NUE9TSVRJT05fQlVGRkVSX01PREUsXG4gICAgQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgTkdfVkFMVUVfQUNDRVNTT1IsXG59IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7ybVnZXRET00gYXMgZ2V0RE9NfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7VFVJX0xFR0FDWV9NQVNLLCBUdWlUZXh0TWFza09wdGlvbnN9IGZyb20gJ0B0YWlnYS11aS9jb3JlJztcbmltcG9ydCB7Y3JlYXRlVGV4dE1hc2tJbnB1dEVsZW1lbnR9IGZyb20gJ3RleHQtbWFzay1jb3JlJztcblxuLyoqXG4gKiBXZSBtdXN0IGNoZWNrIHdoZXRoZXIgdGhlIGFnZW50IGlzIEFuZHJvaWQgYmVjYXVzZSBjb21wb3NpdGlvbiBldmVudHNcbiAqIGJlaGF2ZSBkaWZmZXJlbnRseSBiZXR3ZWVuIGlPUyBhbmQgQW5kcm9pZC5cbiAqL1xuZnVuY3Rpb24gX2lzQW5kcm9pZCgpOiBib29sZWFuIHtcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBnZXRET00oKSA/IGdldERPTSgpLmdldFVzZXJBZ2VudCgpIDogJyc7XG4gICAgcmV0dXJuIC9hbmRyb2lkIChcXGQrKS8udGVzdCh1c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAZGVwcmVjYXRlZFxuICogRG9uJ3QgdXNlIGl0ISBJdCBjYW4gYmUgZGVsZXRlZCBhdCBhbnkgdGltZSAoZXZlbiBpbiBtaW5vciByZWxlYXNlcykuXG4gKiBVc2Uge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS90ZXh0LW1hc2svdGV4dC1tYXNrL3RyZWUvbWFzdGVyL2FuZ3VsYXIyIGFuZ3VsYXIyLXRleHQtbWFza30gaW5zdGVhZC5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgaG9zdDoge1xuICAgICAgICAnKGlucHV0KSc6ICdfaGFuZGxlSW5wdXQoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICAgICAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyxcbiAgICAgICAgJyhjb21wb3NpdGlvbnN0YXJ0KSc6ICdfY29tcG9zaXRpb25TdGFydCgpJyxcbiAgICAgICAgJyhjb21wb3NpdGlvbmVuZCknOiAnX2NvbXBvc2l0aW9uRW5kKCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICB9LFxuICAgIHNlbGVjdG9yOiAnW3RleHRNYXNrXScsXG4gICAgZXhwb3J0QXM6ICd0ZXh0TWFzaycsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWFza2VkSW5wdXREaXJlY3RpdmUpLFxuICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IFRVSV9MRUdBQ1lfTUFTSyxcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1hc2tlZElucHV0RGlyZWN0aXZlKSxcbiAgICAgICAgfSxcbiAgICBdLFxufSlcbmV4cG9ydCBjbGFzcyBNYXNrZWRJbnB1dERpcmVjdGl2ZSBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkNoYW5nZXMge1xuICAgIEBJbnB1dCgndGV4dE1hc2snKSB0ZXh0TWFza0NvbmZpZzogVHVpVGV4dE1hc2tPcHRpb25zID0ge1xuICAgICAgICBtYXNrOiBbXSxcbiAgICAgICAgZ3VpZGU6IHRydWUsXG4gICAgICAgIHBsYWNlaG9sZGVyQ2hhcjogJ18nLFxuICAgICAgICBwaXBlOiB1bmRlZmluZWQsXG4gICAgICAgIGtlZXBDaGFyUG9zaXRpb25zOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgb25DaGFuZ2UgPSAoXzogYW55KSA9PiB7fTtcbiAgICBvblRvdWNoZWQgPSAoKSA9PiB7fTtcblxuICAgIHByaXZhdGUgdGV4dE1hc2tJbnB1dEVsZW1lbnQ6IGFueTtcbiAgICBwcml2YXRlIGlucHV0RWxlbWVudCE6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICAvKiogV2hldGhlciB0aGUgdXNlciBpcyBjcmVhdGluZyBhIGNvbXBvc2l0aW9uIHN0cmluZyAoSU1FIGV2ZW50cykuICovXG4gICAgcHJpdmF0ZSBfY29tcG9zaW5nID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChDT01QT1NJVElPTl9CVUZGRVJfTU9ERSkgcHJpdmF0ZSBfY29tcG9zaXRpb25Nb2RlOiBib29sZWFuLFxuICAgICkge1xuICAgICAgICBpZiAodGhpcy5fY29tcG9zaXRpb25Nb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvc2l0aW9uTW9kZSA9ICFfaXNBbmRyb2lkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5fc2V0dXBNYXNrKHRydWUpO1xuICAgICAgICBpZiAodGhpcy50ZXh0TWFza0lucHV0RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRNYXNrSW5wdXRFbGVtZW50LnVwZGF0ZSh0aGlzLmlucHV0RWxlbWVudC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fc2V0dXBNYXNrKCk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBpbml0aWFsIHZhbHVlIGZvciBjYXNlcyB3aGVyZSB0aGUgbWFzayBpcyBkaXNhYmxlZFxuICAgICAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5pbnB1dEVsZW1lbnQsICd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMudGV4dE1hc2tJbnB1dEVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy50ZXh0TWFza0lucHV0RWxlbWVudC51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKF86IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfVxuXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgX2hhbmRsZUlucHV0KHZhbHVlOiBhbnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb21wb3NpdGlvbk1vZGUgfHwgKHRoaXMuX2NvbXBvc2l0aW9uTW9kZSAmJiAhdGhpcy5fY29tcG9zaW5nKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBNYXNrKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRNYXNrSW5wdXRFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRNYXNrSW5wdXRFbGVtZW50LnVwZGF0ZSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHVwZGF0ZWQgdmFsdWVcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NldHVwTWFzayhjcmVhdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0lOUFVUJykge1xuICAgICAgICAgICAgICAgIC8vIGB0ZXh0TWFza2AgZGlyZWN0aXZlIGlzIHVzZWQgZGlyZWN0bHkgb24gYW4gaW5wdXQgZWxlbWVudFxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBgdGV4dE1hc2tgIGRpcmVjdGl2ZSBpcyB1c2VkIG9uIGFuIGFic3RyYWN0ZWQgaW5wdXQgZWxlbWVudCwgYG1kLWlucHV0LWNvbnRhaW5lcmAsIGV0Y1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdJTlBVVCcpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW5wdXRFbGVtZW50ICYmIGNyZWF0ZSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0TWFza0lucHV0RWxlbWVudCA9IGNyZWF0ZVRleHRNYXNrSW5wdXRFbGVtZW50KFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe2lucHV0RWxlbWVudDogdGhpcy5pbnB1dEVsZW1lbnR9LCB0aGlzLnRleHRNYXNrQ29uZmlnKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY29tcG9zaXRpb25TdGFydCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBfY29tcG9zaXRpb25FbmQodmFsdWU6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRpb25Nb2RlICYmIHRoaXMuX2hhbmRsZUlucHV0KHZhbHVlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAZGVwcmVjYXRlZFxuICogRG9uJ3QgdXNlIGl0ISBJdCBjYW4gYmUgZGVsZXRlZCBhdCBhbnkgdGltZSAoZXZlbiBpbiBtaW5vciByZWxlYXNlcykuXG4gKiBVc2Uge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS90ZXh0LW1hc2svdGV4dC1tYXNrL3RyZWUvbWFzdGVyL2FuZ3VsYXIyIGFuZ3VsYXIyLXRleHQtbWFza30gaW5zdGVhZC5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtNYXNrZWRJbnB1dERpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW01hc2tlZElucHV0RGlyZWN0aXZlXSxcbn0pXG5leHBvcnQgY2xhc3MgVGV4dE1hc2tNb2R1bGUge31cbiJdfQ==