import { ChangeDetectionStrategy, Component, ElementRef, Inject, Optional, } from '@angular/core';
import { NgControl } from '@angular/forms';
import { AbstractTuiControl, TUI_DEFAULT_IDENTITY_MATCHER, tuiIsPresent, tuiTypedFromEvent, } from '@taiga-ui/cdk';
import { TUI_DATA_LIST_HOST, TuiDataListComponent, TuiOptionComponent, } from '@taiga-ui/core';
import { POLYMORPHEUS_CONTEXT, PolymorpheusComponent } from '@tinkoff/ng-polymorpheus';
import { EMPTY, merge, Subject } from 'rxjs';
import { distinctUntilChanged, map, startWith } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@taiga-ui/core";
import * as i2 from "@angular/common";
import * as i3 from "@angular/forms";
import * as i4 from "@taiga-ui/cdk";
export class TuiSelectOptionComponent {
    constructor(context, host, el, option, dataList, control, abstractControl) {
        this.context = context;
        this.host = host;
        this.el = el;
        this.option = option;
        this.dataList = dataList;
        this.control = control;
        this.abstractControl = abstractControl;
        this.changeDetection$ = new Subject();
        this.selected$ = merge(this.changeDetection$, this.control.valueChanges || EMPTY, tuiTypedFromEvent(this.el.nativeElement, 'animationstart')).pipe(startWith(null), map(() => this.selected), distinctUntilChanged());
    }
    get matcher() {
        return this.host.identityMatcher || TUI_DEFAULT_IDENTITY_MATCHER;
    }
    ngDoCheck() {
        this.changeDetection$.next();
    }
    ngOnInit() {
        /**
         * This would cause changes inside already checked parent component (during the same change detection cycle),
         * and it might cause ExpressionChanged error due to potential HostBinding
         * (for example, inside {@link https://github.com/angular/angular/blob/main/packages/forms/src/directives/ng_control_status.ts#L99 NgControlStatus}).
         * Microtask keeps it in the same frame but allows change detection to run.
         */
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        Promise.resolve().then(() => {
            if (tuiIsPresent(this.option.value) && this.host.checkOption) {
                this.host.checkOption(this.option.value);
            }
        });
    }
    get value() {
        var _a, _b;
        return (_b = (_a = this.abstractControl) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : this.control.value;
    }
    get selected() {
        return (tuiIsPresent(this.option.value) &&
            tuiIsPresent(this.value) &&
            this.matcher(this.value, this.option.value));
    }
}
TuiSelectOptionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSelectOptionComponent, deps: [{ token: POLYMORPHEUS_CONTEXT }, { token: TUI_DATA_LIST_HOST }, { token: ElementRef }, { token: TuiOptionComponent }, { token: TuiDataListComponent, optional: true }, { token: NgControl }, { token: AbstractTuiControl, optional: true }], target: i0.ɵɵFactoryTarget.Component });
TuiSelectOptionComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: TuiSelectOptionComponent, selector: "tui-select-option", ngImport: i0, template: "<ng-container [ngTemplateOutlet]=\"context.$implicit\"></ng-container>\n<tui-svg\n    *ngIf=\"selected$ | async; else dummy\"\n    automation-id=\"tui-select-option__checkmark\"\n    src=\"tuiIconCheckLarge\"\n    class=\"t-checkmark\"\n    [tuiScrollIntoView]=\"true\"\n></tui-svg>\n<ng-template #dummy>\n    <span class=\"t-dummy\"></span>\n</ng-template>\n", styles: ["@keyframes retrigger{0%{left:1px}to{left:2px}}:host{display:flex;flex:1;align-items:center;max-width:100%;animation:retrigger 1s}.t-checkmark{margin:0 -.375rem 0 auto;border-left:5px solid transparent}.t-dummy{width:1.5rem}\n"], components: [{ type: i1.TuiSvgComponent, selector: "tui-svg", inputs: ["src"] }], directives: [{ type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.TuiScrollIntoViewDirective, selector: "[tuiScrollIntoView]", inputs: ["tuiScrollIntoView"] }], pipes: { "async": i2.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSelectOptionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'tui-select-option',
                    templateUrl: './select-option.template.html',
                    styleUrls: ['./select-option.style.less'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [POLYMORPHEUS_CONTEXT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_DATA_LIST_HOST]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i1.TuiOptionComponent, decorators: [{
                    type: Inject,
                    args: [TuiOptionComponent]
                }] }, { type: i1.TuiDataListComponent, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TuiDataListComponent]
                }] }, { type: i3.NgControl, decorators: [{
                    type: Inject,
                    args: [NgControl]
                }] }, { type: i4.AbstractTuiControl, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [AbstractTuiControl]
                }] }]; } });
export const TUI_SELECT_OPTION = new PolymorpheusComponent(TuiSelectOptionComponent);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LW9wdGlvbi5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9raXQvY29tcG9uZW50cy9zZWxlY3Qtb3B0aW9uL3NlbGVjdC1vcHRpb24uY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMva2l0L2NvbXBvbmVudHMvc2VsZWN0LW9wdGlvbi9zZWxlY3Qtb3B0aW9uLnRlbXBsYXRlLmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILHVCQUF1QixFQUN2QixTQUFTLEVBRVQsVUFBVSxFQUNWLE1BQU0sRUFFTixRQUFRLEdBRVgsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQ3pDLE9BQU8sRUFDSCxrQkFBa0IsRUFDbEIsNEJBQTRCLEVBRzVCLFlBQVksRUFDWixpQkFBaUIsR0FDcEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNILGtCQUFrQixFQUNsQixvQkFBb0IsRUFFcEIsa0JBQWtCLEdBQ3JCLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEIsT0FBTyxFQUFDLG9CQUFvQixFQUFFLHFCQUFxQixFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDckYsT0FBTyxFQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQzNDLE9BQU8sRUFBQyxvQkFBb0IsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7Ozs7OztBQVFwRSxNQUFNLE9BQU8sd0JBQXdCO0lBYWpDLFlBRWEsT0FBcUUsRUFFN0QsSUFBd0IsRUFDSixFQUEyQixFQUNqQixNQUE2QixFQUd6RCxRQUF3QyxFQUNyQixPQUFrQixFQUdyQyxlQUE2QztRQVh2RCxZQUFPLEdBQVAsT0FBTyxDQUE4RDtRQUU3RCxTQUFJLEdBQUosSUFBSSxDQUFvQjtRQUNK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b21wb25lbnQsXG4gICAgRG9DaGVjayxcbiAgICBFbGVtZW50UmVmLFxuICAgIEluamVjdCxcbiAgICBPbkluaXQsXG4gICAgT3B0aW9uYWwsXG4gICAgVGVtcGxhdGVSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOZ0NvbnRyb2x9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7XG4gICAgQWJzdHJhY3RUdWlDb250cm9sLFxuICAgIFRVSV9ERUZBVUxUX0lERU5USVRZX01BVENIRVIsXG4gICAgVHVpQ29udGV4dFdpdGhJbXBsaWNpdCxcbiAgICBUdWlJZGVudGl0eU1hdGNoZXIsXG4gICAgdHVpSXNQcmVzZW50LFxuICAgIHR1aVR5cGVkRnJvbUV2ZW50LFxufSBmcm9tICdAdGFpZ2EtdWkvY2RrJztcbmltcG9ydCB7XG4gICAgVFVJX0RBVEFfTElTVF9IT1NULFxuICAgIFR1aURhdGFMaXN0Q29tcG9uZW50LFxuICAgIFR1aURhdGFMaXN0SG9zdCxcbiAgICBUdWlPcHRpb25Db21wb25lbnQsXG59IGZyb20gJ0B0YWlnYS11aS9jb3JlJztcbmltcG9ydCB7UE9MWU1PUlBIRVVTX0NPTlRFWFQsIFBvbHltb3JwaGV1c0NvbXBvbmVudH0gZnJvbSAnQHRpbmtvZmYvbmctcG9seW1vcnBoZXVzJztcbmltcG9ydCB7RU1QVFksIG1lcmdlLCBTdWJqZWN0fSBmcm9tICdyeGpzJztcbmltcG9ydCB7ZGlzdGluY3RVbnRpbENoYW5nZWQsIG1hcCwgc3RhcnRXaXRofSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndHVpLXNlbGVjdC1vcHRpb24nLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zZWxlY3Qtb3B0aW9uLnRlbXBsYXRlLmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3NlbGVjdC1vcHRpb24uc3R5bGUubGVzcyddLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBUdWlTZWxlY3RPcHRpb25Db21wb25lbnQ8VD4gaW1wbGVtZW50cyBPbkluaXQsIERvQ2hlY2sge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY2hhbmdlRGV0ZWN0aW9uJCA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgICByZWFkb25seSBzZWxlY3RlZCQgPSBtZXJnZShcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rpb24kLFxuICAgICAgICB0aGlzLmNvbnRyb2wudmFsdWVDaGFuZ2VzIHx8IEVNUFRZLFxuICAgICAgICB0dWlUeXBlZEZyb21FdmVudCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdhbmltYXRpb25zdGFydCcpLFxuICAgICkucGlwZShcbiAgICAgICAgc3RhcnRXaXRoKG51bGwpLFxuICAgICAgICBtYXAoKCkgPT4gdGhpcy5zZWxlY3RlZCksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KFBPTFlNT1JQSEVVU19DT05URVhUKVxuICAgICAgICByZWFkb25seSBjb250ZXh0OiBUdWlDb250ZXh0V2l0aEltcGxpY2l0PFRlbXBsYXRlUmVmPFJlY29yZDxzdHJpbmcsIHVua25vd24+Pj4sXG4gICAgICAgIEBJbmplY3QoVFVJX0RBVEFfTElTVF9IT1NUKVxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGhvc3Q6IFR1aURhdGFMaXN0SG9zdDxUPixcbiAgICAgICAgQEluamVjdChFbGVtZW50UmVmKSBwcml2YXRlIHJlYWRvbmx5IGVsOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgICAgQEluamVjdChUdWlPcHRpb25Db21wb25lbnQpIHByb3RlY3RlZCByZWFkb25seSBvcHRpb246IFR1aU9wdGlvbkNvbXBvbmVudDxUPixcbiAgICAgICAgQE9wdGlvbmFsKClcbiAgICAgICAgQEluamVjdChUdWlEYXRhTGlzdENvbXBvbmVudClcbiAgICAgICAgcHJvdGVjdGVkIHJlYWRvbmx5IGRhdGFMaXN0OiBUdWlEYXRhTGlzdENvbXBvbmVudDxUPiB8IG51bGwsXG4gICAgICAgIEBJbmplY3QoTmdDb250cm9sKSBwcm90ZWN0ZWQgcmVhZG9ubHkgY29udHJvbDogTmdDb250cm9sLFxuICAgICAgICBAT3B0aW9uYWwoKVxuICAgICAgICBASW5qZWN0KEFic3RyYWN0VHVpQ29udHJvbClcbiAgICAgICAgcHJvdGVjdGVkIHJlYWRvbmx5IGFic3RyYWN0Q29udHJvbDogQWJzdHJhY3RUdWlDb250cm9sPFQ+IHwgbnVsbCxcbiAgICApIHt9XG5cbiAgICBnZXQgbWF0Y2hlcigpOiBUdWlJZGVudGl0eU1hdGNoZXI8VD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0LmlkZW50aXR5TWF0Y2hlciB8fCBUVUlfREVGQVVMVF9JREVOVElUWV9NQVRDSEVSO1xuICAgIH1cblxuICAgIG5nRG9DaGVjaygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rpb24kLm5leHQoKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgd291bGQgY2F1c2UgY2hhbmdlcyBpbnNpZGUgYWxyZWFkeSBjaGVja2VkIHBhcmVudCBjb21wb25lbnQgKGR1cmluZyB0aGUgc2FtZSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlKSxcbiAgICAgICAgICogYW5kIGl0IG1pZ2h0IGNhdXNlIEV4cHJlc3Npb25DaGFuZ2VkIGVycm9yIGR1ZSB0byBwb3RlbnRpYWwgSG9zdEJpbmRpbmdcbiAgICAgICAgICogKGZvciBleGFtcGxlLCBpbnNpZGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi9tYWluL3BhY2thZ2VzL2Zvcm1zL3NyYy9kaXJlY3RpdmVzL25nX2NvbnRyb2xfc3RhdHVzLnRzI0w5OSBOZ0NvbnRyb2xTdGF0dXN9KS5cbiAgICAgICAgICogTWljcm90YXNrIGtlZXBzIGl0IGluIHRoZSBzYW1lIGZyYW1lIGJ1dCBhbGxvd3MgY2hhbmdlIGRldGVjdGlvbiB0byBydW4uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR1aUlzUHJlc2VudCh0aGlzLm9wdGlvbi52YWx1ZSkgJiYgdGhpcy5ob3N0LmNoZWNrT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0LmNoZWNrT3B0aW9uKHRoaXMub3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCB2YWx1ZSgpOiBUIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLmFic3RyYWN0Q29udHJvbD8udmFsdWUgPz8gdGhpcy5jb250cm9sLnZhbHVlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgc2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0dWlJc1ByZXNlbnQodGhpcy5vcHRpb24udmFsdWUpICYmXG4gICAgICAgICAgICB0dWlJc1ByZXNlbnQodGhpcy52YWx1ZSkgJiZcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlcih0aGlzLnZhbHVlLCB0aGlzLm9wdGlvbi52YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBUVUlfU0VMRUNUX09QVElPTiA9IG5ldyBQb2x5bW9ycGhldXNDb21wb25lbnQoVHVpU2VsZWN0T3B0aW9uQ29tcG9uZW50KTtcbiIsIjxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29udGV4dC4kaW1wbGljaXRcIj48L25nLWNvbnRhaW5lcj5cbjx0dWktc3ZnXG4gICAgKm5nSWY9XCJzZWxlY3RlZCQgfCBhc3luYzsgZWxzZSBkdW1teVwiXG4gICAgYXV0b21hdGlvbi1pZD1cInR1aS1zZWxlY3Qtb3B0aW9uX19jaGVja21hcmtcIlxuICAgIHNyYz1cInR1aUljb25DaGVja0xhcmdlXCJcbiAgICBjbGFzcz1cInQtY2hlY2ttYXJrXCJcbiAgICBbdHVpU2Nyb2xsSW50b1ZpZXddPVwidHJ1ZVwiXG4+PC90dWktc3ZnPlxuPG5nLXRlbXBsYXRlICNkdW1teT5cbiAgICA8c3BhbiBjbGFzcz1cInQtZHVtbXlcIj48L3NwYW4+XG48L25nLXRlbXBsYXRlPlxuIl19