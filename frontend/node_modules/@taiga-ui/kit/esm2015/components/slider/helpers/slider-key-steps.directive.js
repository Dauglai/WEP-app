import { ChangeDetectorRef, Directive, ElementRef, forwardRef, HostListener, Inject, Input, Optional, Self, } from '@angular/core';
import { NgControl } from '@angular/forms';
import { AbstractTuiControl, tuiAssert, tuiClamp, tuiIsNativeFocused, } from '@taiga-ui/cdk';
import { tuiKeyStepValueToPercentage, tuiPercentageToKeyStepValue, } from '@taiga-ui/kit/utils';
// TODO: find the best way for prevent cycle
// eslint-disable-next-line import/no-cycle
import { TuiSliderComponent } from '../slider.component';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "../slider.component";
export class TuiSliderKeyStepsDirective extends AbstractTuiControl {
    constructor(control, cdr, el, slider) {
        super(control, cdr);
        this.el = el;
        this.slider = slider;
    }
    get nativeFocusableElement() {
        return this.computedDisabled ? null : this.el.nativeElement;
    }
    get focused() {
        return tuiIsNativeFocused(this.nativeFocusableElement);
    }
    get min() {
        return this.keySteps[0][1];
    }
    get max() {
        return this.keySteps[this.keySteps.length - 1][1];
    }
    updateControlValue() {
        this.value = tuiPercentageToKeyStepValue(this.slider.valuePercentage, this.keySteps);
    }
    writeValue(controlValue) {
        if (controlValue === null) {
            return;
        }
        const clampedControlValue = tuiClamp(controlValue, this.min, this.max);
        ngDevMode &&
            tuiAssert.assert(controlValue === clampedControlValue, '\n[SliderKeySteps]: You cannot programmatically set value which is less/more than min/max');
        this.slider.value = this.transformToNativeValue(clampedControlValue);
    }
    getFallbackValue() {
        return 0;
    }
    transformToNativeValue(controlValue) {
        const { min, max } = this.slider;
        const newValuePercentage = tuiKeyStepValueToPercentage(controlValue, this.keySteps);
        return (newValuePercentage * (max - min)) / 100 + min;
    }
}
TuiSliderKeyStepsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderKeyStepsDirective, deps: [{ token: NgControl, optional: true, self: true }, { token: ChangeDetectorRef }, { token: ElementRef }, { token: forwardRef(() => TuiSliderComponent) }], target: i0.ɵɵFactoryTarget.Directive });
TuiSliderKeyStepsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiSliderKeyStepsDirective, selector: "input[tuiSlider][keySteps]", inputs: { keySteps: "keySteps" }, host: { listeners: { "input": "updateControlValue()", "change": "updateControlValue()" }, properties: { "attr.aria-valuenow": "safeCurrentValue", "attr.aria-valuemin": "min", "attr.aria-valuemax": "max" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderKeyStepsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[tuiSlider][keySteps]',
                    host: {
                        '[attr.aria-valuenow]': 'safeCurrentValue',
                        '[attr.aria-valuemin]': 'min',
                        '[attr.aria-valuemax]': 'max',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i1.NgControl, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }, {
                    type: Inject,
                    args: [NgControl]
                }] }, { type: i0.ChangeDetectorRef, decorators: [{
                    type: Inject,
                    args: [ChangeDetectorRef]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i2.TuiSliderComponent, decorators: [{
                    type: Inject,
                    args: [forwardRef(() => TuiSliderComponent)]
                }] }]; }, propDecorators: { keySteps: [{
                type: Input
            }], updateControlValue: [{
                type: HostListener,
                args: ['input']
            }, {
                type: HostListener,
                args: ['change']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLWtleS1zdGVwcy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9raXQvY29tcG9uZW50cy9zbGlkZXIvaGVscGVycy9zbGlkZXIta2V5LXN0ZXBzLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0gsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsVUFBVSxFQUNWLFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxFQUNMLFFBQVEsRUFDUixJQUFJLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQ3pDLE9BQU8sRUFDSCxrQkFBa0IsRUFDbEIsU0FBUyxFQUNULFFBQVEsRUFFUixrQkFBa0IsR0FDckIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUNILDJCQUEyQixFQUMzQiwyQkFBMkIsR0FDOUIsTUFBTSxxQkFBcUIsQ0FBQztBQUU3Qiw0Q0FBNEM7QUFDNUMsMkNBQTJDO0FBQzNDLE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLHFCQUFxQixDQUFDOzs7O0FBVXZELE1BQU0sT0FBTywwQkFDVCxTQUFRLGtCQUEwQjtJQXNCbEMsWUFJSSxPQUF5QixFQUNFLEdBQXNCLEVBQ1osRUFBZ0MsRUFFcEQsTUFBMEI7UUFFM0MsS0FBSyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQztRQUppQixPQUFFLEdBQUYsRUFBRSxDQUE4QjtRQUVwRCxXQUFNLEdBQU4sTUFBTSxDQUFvQjtJQUcvQyxDQUFDO0lBM0JELElBQUksc0JBQXNCO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDO0lBQ2hFLENBQUM7SUFFRCxJQUFJLE9BQU87UUFDUCxPQUFPLGtCQUFrQixDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFRCxJQUFJLEdBQUc7UUFDSCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVELElBQUksR0FBRztRQUNILE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBaUJELGtCQUFrQjtRQUNkLElBQUksQ0FBQyxLQUFLLEdBQUcsMkJBQTJCLENBQ3BDLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUMzQixJQUFJLENBQUMsUUFBUSxDQUNoQixDQUFDO0lBQ04sQ0FBQztJQUVRLFVBQVUsQ0FBQyxZQUEyQjtRQUMzQyxJQUFJLFlBQVksS0FBSyxJQUFJLEVBQUU7WUFDdkIsT0FBTztTQUNWO1FBRUQsTUFBTSxtQkFBbUIsR0FBRyxRQUFRLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXZFLFNBQVM7WUFDTCxTQUFTLENBQUMsTUFBTSxDQUNaLFlBQVksS0FBSyxtQkFBbUIsRUFDcEMsMkZBQTJGLENBQzlGLENBQUM7UUFFTixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUMsbUJBQW1CLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRVMsZ0JBQWdCO1FBQ3RCLE9BQU8sQ0FBQyxDQUFDO0lBQ2IsQ0FBQztJQUVPLHNCQUFzQixDQUFDLFlBQW9CO1FBQy9DLE1BQU0sRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUMvQixNQUFNLGtCQUFrQixHQUFHLDJCQUEyQixDQUNsRCxZQUFZLEVBQ1osSUFBSSxDQUFDLFFBQVEsQ0FDaEIsQ0FBQztRQUVGLE9BQU8sQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7SUFDMUQsQ0FBQzs7d0hBekVRLDBCQUEwQixrQkEwQnZCLFNBQVMseUNBRVQsaUJBQWlCLGFBQ2pCLFVBQVUsYUFDVixVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUM7NEdBOUJ2QywwQkFBMEI7NEZBQTFCLDBCQUEwQjtrQkFSdEMsU0FBUzttQkFBQztvQkFDUCxRQUFRLEVBQUUsNEJBQTRCO29CQUN0QyxJQUFJLEVBQUU7d0JBQ0Ysc0JBQXNCLEVBQUUsa0JBQWtCO3dCQUMxQyxzQkFBc0IsRUFBRSxLQUFLO3dCQUM3QixzQkFBc0IsRUFBRSxLQUFLO3FCQUNoQztpQkFDSjs7MEJBeUJRLFFBQVE7OzBCQUNSLElBQUk7OzBCQUNKLE1BQU07MkJBQUMsU0FBUzs7MEJBRWhCLE1BQU07MkJBQUMsaUJBQWlCOzswQkFDeEIsTUFBTTsyQkFBQyxVQUFVOzswQkFDakIsTUFBTTsyQkFBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUM7NENBekJoRCxRQUFRO3NCQURQLEtBQUs7Z0JBa0NOLGtCQUFrQjtzQkFGakIsWUFBWTt1QkFBQyxPQUFPOztzQkFDcEIsWUFBWTt1QkFBQyxRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgU2VsZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge05nQ29udHJvbH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtcbiAgICBBYnN0cmFjdFR1aUNvbnRyb2wsXG4gICAgdHVpQXNzZXJ0LFxuICAgIHR1aUNsYW1wLFxuICAgIFR1aUZvY3VzYWJsZUVsZW1lbnRBY2Nlc3NvcixcbiAgICB0dWlJc05hdGl2ZUZvY3VzZWQsXG59IGZyb20gJ0B0YWlnYS11aS9jZGsnO1xuaW1wb3J0IHtUdWlLZXlTdGVwc30gZnJvbSAnQHRhaWdhLXVpL2tpdC90eXBlcyc7XG5pbXBvcnQge1xuICAgIHR1aUtleVN0ZXBWYWx1ZVRvUGVyY2VudGFnZSxcbiAgICB0dWlQZXJjZW50YWdlVG9LZXlTdGVwVmFsdWUsXG59IGZyb20gJ0B0YWlnYS11aS9raXQvdXRpbHMnO1xuXG4vLyBUT0RPOiBmaW5kIHRoZSBiZXN0IHdheSBmb3IgcHJldmVudCBjeWNsZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1jeWNsZVxuaW1wb3J0IHtUdWlTbGlkZXJDb21wb25lbnR9IGZyb20gJy4uL3NsaWRlci5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2lucHV0W3R1aVNsaWRlcl1ba2V5U3RlcHNdJyxcbiAgICBob3N0OiB7XG4gICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbm93XSc6ICdzYWZlQ3VycmVudFZhbHVlJyxcbiAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVtaW5dJzogJ21pbicsXG4gICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbWF4XSc6ICdtYXgnLFxuICAgIH0sXG59KVxuZXhwb3J0IGNsYXNzIFR1aVNsaWRlcktleVN0ZXBzRGlyZWN0aXZlXG4gICAgZXh0ZW5kcyBBYnN0cmFjdFR1aUNvbnRyb2w8bnVtYmVyPlxuICAgIGltcGxlbWVudHMgVHVpRm9jdXNhYmxlRWxlbWVudEFjY2Vzc29yXG57XG4gICAgQElucHV0KClcbiAgICBrZXlTdGVwcyE6IFR1aUtleVN0ZXBzO1xuXG4gICAgZ2V0IG5hdGl2ZUZvY3VzYWJsZUVsZW1lbnQoKTogSFRNTElucHV0RWxlbWVudCB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZERpc2FibGVkID8gbnVsbCA6IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBnZXQgZm9jdXNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHR1aUlzTmF0aXZlRm9jdXNlZCh0aGlzLm5hdGl2ZUZvY3VzYWJsZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIGdldCBtaW4oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5U3RlcHNbMF1bMV07XG4gICAgfVxuXG4gICAgZ2V0IG1heCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlTdGVwc1t0aGlzLmtleVN0ZXBzLmxlbmd0aCAtIDFdWzFdO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBAT3B0aW9uYWwoKVxuICAgICAgICBAU2VsZigpXG4gICAgICAgIEBJbmplY3QoTmdDb250cm9sKVxuICAgICAgICBjb250cm9sOiBOZ0NvbnRyb2wgfCBudWxsLFxuICAgICAgICBASW5qZWN0KENoYW5nZURldGVjdG9yUmVmKSBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBASW5qZWN0KEVsZW1lbnRSZWYpIHByaXZhdGUgcmVhZG9ubHkgZWw6IEVsZW1lbnRSZWY8SFRNTElucHV0RWxlbWVudD4sXG4gICAgICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBUdWlTbGlkZXJDb21wb25lbnQpKVxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHNsaWRlcjogVHVpU2xpZGVyQ29tcG9uZW50LFxuICAgICkge1xuICAgICAgICBzdXBlcihjb250cm9sLCBjZHIpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2lucHV0JylcbiAgICBASG9zdExpc3RlbmVyKCdjaGFuZ2UnKVxuICAgIHVwZGF0ZUNvbnRyb2xWYWx1ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHR1aVBlcmNlbnRhZ2VUb0tleVN0ZXBWYWx1ZShcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyLnZhbHVlUGVyY2VudGFnZSxcbiAgICAgICAgICAgIHRoaXMua2V5U3RlcHMsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgb3ZlcnJpZGUgd3JpdGVWYWx1ZShjb250cm9sVmFsdWU6IG51bWJlciB8IG51bGwpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNvbnRyb2xWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xhbXBlZENvbnRyb2xWYWx1ZSA9IHR1aUNsYW1wKGNvbnRyb2xWYWx1ZSwgdGhpcy5taW4sIHRoaXMubWF4KTtcblxuICAgICAgICBuZ0Rldk1vZGUgJiZcbiAgICAgICAgICAgIHR1aUFzc2VydC5hc3NlcnQoXG4gICAgICAgICAgICAgICAgY29udHJvbFZhbHVlID09PSBjbGFtcGVkQ29udHJvbFZhbHVlLFxuICAgICAgICAgICAgICAgICdcXG5bU2xpZGVyS2V5U3RlcHNdOiBZb3UgY2Fubm90IHByb2dyYW1tYXRpY2FsbHkgc2V0IHZhbHVlIHdoaWNoIGlzIGxlc3MvbW9yZSB0aGFuIG1pbi9tYXgnLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnNsaWRlci52YWx1ZSA9IHRoaXMudHJhbnNmb3JtVG9OYXRpdmVWYWx1ZShjbGFtcGVkQ29udHJvbFZhbHVlKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0RmFsbGJhY2tWYWx1ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRyYW5zZm9ybVRvTmF0aXZlVmFsdWUoY29udHJvbFZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5zbGlkZXI7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlUGVyY2VudGFnZSA9IHR1aUtleVN0ZXBWYWx1ZVRvUGVyY2VudGFnZShcbiAgICAgICAgICAgIGNvbnRyb2xWYWx1ZSxcbiAgICAgICAgICAgIHRoaXMua2V5U3RlcHMsXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIChuZXdWYWx1ZVBlcmNlbnRhZ2UgKiAobWF4IC0gbWluKSkgLyAxMDAgKyBtaW47XG4gICAgfVxufVxuIl19