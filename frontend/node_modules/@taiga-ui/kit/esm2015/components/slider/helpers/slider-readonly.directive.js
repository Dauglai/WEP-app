import { __decorate } from "tslib";
import { DOCUMENT } from '@angular/common';
import { Directive, ElementRef, HostListener, Inject, Input, Self } from '@angular/core';
import { ALWAYS_FALSE_HANDLER, ALWAYS_TRUE_HANDLER, tuiCoerceBooleanProperty, tuiDefaultProp, TuiDestroyService, tuiTypedFromEvent, } from '@taiga-ui/cdk';
import { combineLatest, merge } from 'rxjs';
import { filter, map, takeUntil, tap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "rxjs";
const SLIDER_INTERACTION_KEYS = new Set([
    'ArrowLeft',
    'ArrowRight',
    'ArrowUp',
    'ArrowDown',
    'Home',
    'End',
    'PageUp',
    'PageDown',
]);
/**
 * Native <input type='range' readonly> doesn't work.
 * This directive imitates this native behaviour.
 */
export class TuiSliderReadonlyDirective {
    constructor(el, doc, destroy$) {
        this.readonly = true;
        const touchStart$ = tuiTypedFromEvent(el.nativeElement, 'touchstart', {
            passive: false,
        });
        const touchMove$ = tuiTypedFromEvent(doc, 'touchmove', {
            passive: false,
        });
        const touchEnd$ = tuiTypedFromEvent(doc, 'touchend', {
            passive: true,
        });
        const shouldPreventMove$ = merge(touchStart$.pipe(tap(e => this.preventEvent(e)), map(ALWAYS_TRUE_HANDLER)), touchEnd$.pipe(map(ALWAYS_FALSE_HANDLER)));
        /**
         * @bad TODO think about another solution.
         * Keep in mind that preventing touch event (on slider) inside `@HostListener('touchstart')` doesn't work for mobile chrome.
         */
        combineLatest([touchMove$, shouldPreventMove$])
            .pipe(filter(([_, shouldPreventMove]) => shouldPreventMove), takeUntil(destroy$))
            .subscribe(([moveEvent]) => this.preventEvent(moveEvent));
    }
    preventEvent(event) {
        if (event.cancelable && tuiCoerceBooleanProperty(this.readonly)) {
            event.preventDefault();
        }
    }
    preventKeyboardInteraction(event) {
        if (SLIDER_INTERACTION_KEYS.has(event.key)) {
            this.preventEvent(event);
        }
    }
}
TuiSliderReadonlyDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderReadonlyDirective, deps: [{ token: ElementRef }, { token: DOCUMENT }, { token: TuiDestroyService, self: true }], target: i0.ɵɵFactoryTarget.Directive });
TuiSliderReadonlyDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiSliderReadonlyDirective, selector: "input[tuiSlider][readonly]", inputs: { readonly: "readonly" }, host: { listeners: { "mousedown": "preventEvent($event)", "keydown": "preventKeyboardInteraction($event)" } }, providers: [TuiDestroyService], ngImport: i0 });
__decorate([
    tuiDefaultProp()
], TuiSliderReadonlyDirective.prototype, "readonly", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderReadonlyDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[tuiSlider][readonly]',
                    providers: [TuiDestroyService],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i1.Observable, decorators: [{
                    type: Self
                }, {
                    type: Inject,
                    args: [TuiDestroyService]
                }] }]; }, propDecorators: { readonly: [{
                type: Input
            }], preventEvent: [{
                type: HostListener,
                args: ['mousedown', ['$event']]
            }], preventKeyboardInteraction: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLXJlYWRvbmx5LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2tpdC9jb21wb25lbnRzL3NsaWRlci9oZWxwZXJzL3NsaWRlci1yZWFkb25seS5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QyxPQUFPLEVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDdkYsT0FBTyxFQUNILG9CQUFvQixFQUNwQixtQkFBbUIsRUFDbkIsd0JBQXdCLEVBQ3hCLGNBQWMsRUFDZCxpQkFBaUIsRUFDakIsaUJBQWlCLEdBQ3BCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBQyxhQUFhLEVBQUUsS0FBSyxFQUFhLE1BQU0sTUFBTSxDQUFDO0FBQ3RELE9BQU8sRUFBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQzs7O0FBRTNELE1BQU0sdUJBQXVCLEdBQUcsSUFBSSxHQUFHLENBQUM7SUFDcEMsV0FBVztJQUNYLFlBQVk7SUFDWixTQUFTO0lBQ1QsV0FBVztJQUNYLE1BQU07SUFDTixLQUFLO0lBQ0wsUUFBUTtJQUNSLFVBQVU7Q0FDYixDQUFDLENBQUM7QUFFSDs7O0dBR0c7QUFLSCxNQUFNLE9BQU8sMEJBQTBCO0lBS25DLFlBQ3dCLEVBQWdDLEVBQ2xDLEdBQWEsRUFHL0IsUUFBNkI7UUFQakMsYUFBUSxHQUFxQixJQUFJLENBQUM7UUFTOUIsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxZQUFZLEVBQUU7WUFDbEUsT0FBTyxFQUFFLEtBQUs7U0FDakIsQ0FBQyxDQUFDO1FBQ0gsTUFBTSxVQUFVLEdBQUcsaUJBQWlCLENBQUMsR0FBRyxFQUFFLFdBQVcsRUFBRTtZQUNuRCxPQUFPLEVBQUUsS0FBSztTQUNqQixDQUFDLENBQUM7UUFDSCxNQUFNLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsVUFBVSxFQUFFO1lBQ2pELE9BQU8sRUFBRSxJQUFJO1NBQ2hCLENBQUMsQ0FBQztRQUVILE1BQU0sa0JBQWtCLEdBQUcsS0FBSyxDQUM1QixXQUFXLENBQUMsSUFBSSxDQUNaLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFDOUIsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQzNCLEVBQ0QsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUM1QyxDQUFDO1FBRUY7OztXQUdHO1FBQ0gsYUFBYSxDQUFDLENBQUMsVUFBVSxFQUFFLGtCQUFrQixDQUFDLENBQUM7YUFDMUMsSUFBSSxDQUNELE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDLEVBQ3JELFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FDdEI7YUFDQSxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUdELFlBQVksQ0FBQyxLQUFZO1FBQ3JCLElBQUksS0FBSyxDQUFDLFVBQVUsSUFBSSx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDN0QsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO1NBQzFCO0lBQ0wsQ0FBQztJQUdELDBCQUEwQixDQUFDLEtBQW9CO1FBQzNDLElBQUksdUJBQXVCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUN4QyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzVCO0lBQ0wsQ0FBQzs7d0hBdERRLDBCQUEwQixrQkFNdkIsVUFBVSxhQUNWLFFBQVEsYUFFUixpQkFBaUI7NEdBVHBCLDBCQUEwQixzTUFGeEIsQ0FBQyxpQkFBaUIsQ0FBQztBQUs5QjtJQURDLGNBQWMsRUFBRTs0REFDaUI7NEZBSHpCLDBCQUEwQjtrQkFKdEMsU0FBUzttQkFBQztvQkFDUCxRQUFRLEVBQUUsNEJBQTRCO29CQUN0QyxTQUFTLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQztpQkFDakM7OzBCQU9RLE1BQU07MkJBQUMsVUFBVTs4QkFDSyxRQUFROzBCQUE5QixNQUFNOzJCQUFDLFFBQVE7OzBCQUNmLElBQUk7OzBCQUNKLE1BQU07MkJBQUMsaUJBQWlCOzRDQU43QixRQUFRO3NCQUZQLEtBQUs7Z0JBMENOLFlBQVk7c0JBRFgsWUFBWTt1QkFBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUM7Z0JBUXJDLDBCQUEwQjtzQkFEekIsWUFBWTt1QkFBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0RPQ1VNRU5UfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBJbnB1dCwgU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIEFMV0FZU19GQUxTRV9IQU5ETEVSLFxuICAgIEFMV0FZU19UUlVFX0hBTkRMRVIsXG4gICAgdHVpQ29lcmNlQm9vbGVhblByb3BlcnR5LFxuICAgIHR1aURlZmF1bHRQcm9wLFxuICAgIFR1aURlc3Ryb3lTZXJ2aWNlLFxuICAgIHR1aVR5cGVkRnJvbUV2ZW50LFxufSBmcm9tICdAdGFpZ2EtdWkvY2RrJztcbmltcG9ydCB7Y29tYmluZUxhdGVzdCwgbWVyZ2UsIE9ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtmaWx0ZXIsIG1hcCwgdGFrZVVudGlsLCB0YXB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuY29uc3QgU0xJREVSX0lOVEVSQUNUSU9OX0tFWVMgPSBuZXcgU2V0KFtcbiAgICAnQXJyb3dMZWZ0JyxcbiAgICAnQXJyb3dSaWdodCcsXG4gICAgJ0Fycm93VXAnLFxuICAgICdBcnJvd0Rvd24nLFxuICAgICdIb21lJyxcbiAgICAnRW5kJyxcbiAgICAnUGFnZVVwJyxcbiAgICAnUGFnZURvd24nLFxuXSk7XG5cbi8qKlxuICogTmF0aXZlIDxpbnB1dCB0eXBlPSdyYW5nZScgcmVhZG9ubHk+IGRvZXNuJ3Qgd29yay5cbiAqIFRoaXMgZGlyZWN0aXZlIGltaXRhdGVzIHRoaXMgbmF0aXZlIGJlaGF2aW91ci5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdpbnB1dFt0dWlTbGlkZXJdW3JlYWRvbmx5XScsXG4gICAgcHJvdmlkZXJzOiBbVHVpRGVzdHJveVNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBUdWlTbGlkZXJSZWFkb25seURpcmVjdGl2ZSB7XG4gICAgQElucHV0KClcbiAgICBAdHVpRGVmYXVsdFByb3AoKVxuICAgIHJlYWRvbmx5OiBib29sZWFuIHwgc3RyaW5nID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KEVsZW1lbnRSZWYpIGVsOiBFbGVtZW50UmVmPEhUTUxJbnB1dEVsZW1lbnQ+LFxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBkb2M6IERvY3VtZW50LFxuICAgICAgICBAU2VsZigpXG4gICAgICAgIEBJbmplY3QoVHVpRGVzdHJveVNlcnZpY2UpXG4gICAgICAgIGRlc3Ryb3kkOiBPYnNlcnZhYmxlPHVua25vd24+LFxuICAgICkge1xuICAgICAgICBjb25zdCB0b3VjaFN0YXJ0JCA9IHR1aVR5cGVkRnJvbUV2ZW50KGVsLm5hdGl2ZUVsZW1lbnQsICd0b3VjaHN0YXJ0Jywge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b3VjaE1vdmUkID0gdHVpVHlwZWRGcm9tRXZlbnQoZG9jLCAndG91Y2htb3ZlJywge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b3VjaEVuZCQgPSB0dWlUeXBlZEZyb21FdmVudChkb2MsICd0b3VjaGVuZCcsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHNob3VsZFByZXZlbnRNb3ZlJCA9IG1lcmdlKFxuICAgICAgICAgICAgdG91Y2hTdGFydCQucGlwZShcbiAgICAgICAgICAgICAgICB0YXAoZSA9PiB0aGlzLnByZXZlbnRFdmVudChlKSksXG4gICAgICAgICAgICAgICAgbWFwKEFMV0FZU19UUlVFX0hBTkRMRVIpLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHRvdWNoRW5kJC5waXBlKG1hcChBTFdBWVNfRkFMU0VfSEFORExFUikpLFxuICAgICAgICApO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYmFkIFRPRE8gdGhpbmsgYWJvdXQgYW5vdGhlciBzb2x1dGlvbi5cbiAgICAgICAgICogS2VlcCBpbiBtaW5kIHRoYXQgcHJldmVudGluZyB0b3VjaCBldmVudCAob24gc2xpZGVyKSBpbnNpZGUgYEBIb3N0TGlzdGVuZXIoJ3RvdWNoc3RhcnQnKWAgZG9lc24ndCB3b3JrIGZvciBtb2JpbGUgY2hyb21lLlxuICAgICAgICAgKi9cbiAgICAgICAgY29tYmluZUxhdGVzdChbdG91Y2hNb3ZlJCwgc2hvdWxkUHJldmVudE1vdmUkXSlcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIGZpbHRlcigoW18sIHNob3VsZFByZXZlbnRNb3ZlXSkgPT4gc2hvdWxkUHJldmVudE1vdmUpLFxuICAgICAgICAgICAgICAgIHRha2VVbnRpbChkZXN0cm95JCksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChbbW92ZUV2ZW50XSkgPT4gdGhpcy5wcmV2ZW50RXZlbnQobW92ZUV2ZW50KSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2Vkb3duJywgWyckZXZlbnQnXSlcbiAgICBwcmV2ZW50RXZlbnQoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChldmVudC5jYW5jZWxhYmxlICYmIHR1aUNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh0aGlzLnJlYWRvbmx5KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICAgIHByZXZlbnRLZXlib2FyZEludGVyYWN0aW9uKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChTTElERVJfSU5URVJBQ1RJT05fS0VZUy5oYXMoZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgdGhpcy5wcmV2ZW50RXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19