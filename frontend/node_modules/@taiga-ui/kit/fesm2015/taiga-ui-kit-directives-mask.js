import * as i0 from '@angular/core';
import { forwardRef, Directive, Optional, Inject, Input, NgModule } from '@angular/core';
import { COMPOSITION_BUFFER_MODE, NG_VALUE_ACCESSOR } from '@angular/forms';
import { ɵgetDOM } from '@angular/platform-browser';
import { TUI_LEGACY_MASK } from '@taiga-ui/core';
import { createTextMaskInputElement } from 'text-mask-core';

/* eslint-disable */
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 */
function _isAndroid() {
    const userAgent = ɵgetDOM() ? ɵgetDOM().getUserAgent() : '';
    return /android (\d+)/.test(userAgent.toLowerCase());
}
/**
 * @internal
 * @deprecated
 * Don't use it! It can be deleted at any time (even in minor releases).
 * Use {@link https://github.com/text-mask/text-mask/tree/master/angular2 angular2-text-mask} instead.
 */
class MaskedInputDirective {
    constructor(_renderer, _elementRef, _compositionMode) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._compositionMode = _compositionMode;
        this.textMaskConfig = {
            mask: [],
            guide: true,
            placeholderChar: '_',
            pipe: undefined,
            keepCharPositions: false,
        };
        this.onChange = (_) => { };
        this.onTouched = () => { };
        /** Whether the user is creating a composition string (IME events). */
        this._composing = false;
        if (this._compositionMode == null) {
            this._compositionMode = !_isAndroid();
        }
    }
    ngOnChanges() {
        this._setupMask(true);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(this.inputElement.value);
        }
    }
    writeValue(value) {
        this._setupMask();
        // set the initial value for cases where the mask is disabled
        const normalizedValue = value == null ? '' : value;
        this._renderer.setProperty(this.inputElement, 'value', normalizedValue);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(value);
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    _handleInput(value) {
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this._setupMask();
            if (this.textMaskInputElement !== undefined) {
                this.textMaskInputElement.update(value);
                // get the updated value
                value = this.inputElement.value;
                this.onChange(value);
            }
        }
    }
    _setupMask(create = false) {
        if (!this.inputElement) {
            if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {
                // `textMask` directive is used directly on an input element
                this.inputElement = this._elementRef.nativeElement;
            }
            else {
                // `textMask` directive is used on an abstracted input element, `md-input-container`, etc
                this.inputElement =
                    this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];
            }
        }
        if (this.inputElement && create) {
            this.textMaskInputElement = createTextMaskInputElement(Object.assign({ inputElement: this.inputElement }, this.textMaskConfig));
        }
    }
    _compositionStart() {
        this._composing = true;
    }
    _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this._handleInput(value);
    }
}
MaskedInputDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MaskedInputDirective, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }, { token: COMPOSITION_BUFFER_MODE, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
MaskedInputDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: MaskedInputDirective, selector: "[textMask]", inputs: { textMaskConfig: ["textMask", "textMaskConfig"] }, host: { listeners: { "input": "_handleInput($event.target.value)", "blur": "onTouched()", "compositionstart": "_compositionStart()", "compositionend": "_compositionEnd($event.target.value)" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => MaskedInputDirective),
            multi: true,
        },
        {
            provide: TUI_LEGACY_MASK,
            useExisting: forwardRef(() => MaskedInputDirective),
        },
    ], exportAs: ["textMask"], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MaskedInputDirective, decorators: [{
            type: Directive,
            args: [{
                    host: {
                        '(input)': '_handleInput($event.target.value)',
                        '(blur)': 'onTouched()',
                        '(compositionstart)': '_compositionStart()',
                        '(compositionend)': '_compositionEnd($event.target.value)',
                    },
                    selector: '[textMask]',
                    exportAs: 'textMask',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => MaskedInputDirective),
                            multi: true,
                        },
                        {
                            provide: TUI_LEGACY_MASK,
                            useExisting: forwardRef(() => MaskedInputDirective),
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [COMPOSITION_BUFFER_MODE]
                }] }]; }, propDecorators: { textMaskConfig: [{
                type: Input,
                args: ['textMask']
            }] } });
/**
 * @internal
 * @deprecated
 * Don't use it! It can be deleted at any time (even in minor releases).
 * Use {@link https://github.com/text-mask/text-mask/tree/master/angular2 angular2-text-mask} instead.
 */
class TextMaskModule {
}
TextMaskModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TextMaskModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TextMaskModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TextMaskModule, declarations: [MaskedInputDirective], exports: [MaskedInputDirective] });
TextMaskModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TextMaskModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TextMaskModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [MaskedInputDirective],
                    exports: [MaskedInputDirective],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { MaskedInputDirective, TextMaskModule };
//# sourceMappingURL=taiga-ui-kit-directives-mask.js.map
