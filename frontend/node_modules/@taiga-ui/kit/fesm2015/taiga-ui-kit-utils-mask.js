import { TuiDay, DATE_FILLER_LENGTH, DATE_RANGE_FILLER_LENGTH, TuiDayRange, RANGE_SEPARATOR_CHAR, tuiIsString, tuiAssert, CHAR_NO_BREAK_SPACE, CHAR_EN_DASH } from '@taiga-ui/cdk';
import { MAX_TIME_VALUES, DATE_TIME_SEPARATOR } from '@taiga-ui/kit/constants';
import { TUI_DIGIT_REGEXP } from '@taiga-ui/core';

function tuiNormalizeDateValue(dateValue, { value, min, max, dateFormat, dateSeparator }) {
    return value && value.toString(dateFormat, dateSeparator) === dateValue
        ? dateValue
        : TuiDay.normalizeParse(dateValue, dateFormat)
            .dayLimit(min, max)
            .toString(dateFormat, dateSeparator);
}
function tuiCreateAutoCorrectedDatePipe(config) {
    return value => {
        if (value.length !== DATE_FILLER_LENGTH) {
            return { value };
        }
        return {
            value: tuiNormalizeDateValue(value, config),
        };
    };
}

function parseWithLimit(value, config) {
    return TuiDay.normalizeParse(value.slice(0, DATE_FILLER_LENGTH), config.dateFormat).dayLimit(config.min, config.max);
}
function processRawValue(value, config) {
    const { dateFormat, dateSeparator } = config;
    switch (value.length) {
        case DATE_FILLER_LENGTH:
            return parseWithLimit(value, config).toString(dateFormat, dateSeparator);
        case DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length:
            return (parseWithLimit(value, config).toString(dateFormat, dateSeparator) +
                RANGE_SEPARATOR_CHAR);
        case DATE_RANGE_FILLER_LENGTH:
            return config.value &&
                config.value.toString(dateFormat, dateSeparator) === value
                ? value
                : TuiDayRange.sort(parseWithLimit(value.slice(0, DATE_FILLER_LENGTH), config), parseWithLimit(value.slice(DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length), config)).toString(dateFormat, dateSeparator);
        default:
            return value;
    }
}
/**
 * Normalizes date in formatted string
 *
 * Normalizes when:
 *
 * 1. It is a single date
 * 2. It is a single date and a separator
 * 3. It is two dates and a separator between them
 *
 * In **other** cases, the value does not change.
 *
 * @param config with min and max date
 * @return mask pipe handler that handles `min` and `max`
 */
function tuiCreateAutoCorrectedDateRangePipe(config) {
    return value => ({ value: processRawValue(value, config) });
}

/**
 * Adjusts the entered time by omitting only suitable values for hours and minutes
 * @returns time as a string
 */
function tuiCreateAutoCorrectedTimePipe(timeMode = `HH:MM`, maxValues = {}) {
    const timeFormatArray = [`HH`, `MM`, `SS`, `MS`];
    const safeValues = Object.assign(Object.assign({}, MAX_TIME_VALUES), maxValues);
    return conformedValue => {
        const indexesOfPipedChars = [];
        const conformedValueArr = conformedValue.split(``);
        timeFormatArray.forEach(format => {
            const position = timeMode.indexOf(format);
            const maxFirstDigit = parseInt(String(safeValues[format]).slice(0, 1), 10);
            if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {
                conformedValueArr[position + 1] = conformedValueArr[position];
                conformedValueArr[position] = `0`;
                indexesOfPipedChars.push(position);
            }
        });
        const isInvalid = timeFormatArray.some(format => parseInt(conformedValue.slice(timeMode.indexOf(format), 2), 10) >
            safeValues[format]);
        return isInvalid
            ? false
            : {
                value: conformedValueArr.join(``),
                indexesOfPipedChars,
            };
    };
}

function tuiCreateAutoCorrectedDateTimePipe(configs) {
    const timePipe = tuiCreateAutoCorrectedTimePipe(configs.timeMode);
    return value => {
        if (value.length < DATE_FILLER_LENGTH) {
            return { value };
        }
        const [date, time] = value.split(DATE_TIME_SEPARATOR);
        const formattedDate = tuiNormalizeDateValue(date, configs);
        if (!time) {
            return { value: formattedDate };
        }
        const pipedTime = timePipe(time, {});
        if (!pipedTime || tuiIsString(pipedTime)) {
            return false;
        }
        return {
            value: `${formattedDate}${DATE_TIME_SEPARATOR}${pipedTime.value}`,
            indexesOfPipedChars: pipedTime.indexesOfPipedChars
                ? pipedTime.indexesOfPipedChars.map(i => i + date.length + 2)
                : undefined,
        };
    };
}

const TWO_DIGITS = new Array(2).fill(TUI_DIGIT_REGEXP);
const FOUR_DIGITS = new Array(4).fill(TUI_DIGIT_REGEXP);
function tuiCreateDateMask(mode, separator) {
    ngDevMode &&
        tuiAssert.assert(separator.length === 1, `Separator should consist of only 1 symbol`);
    switch (mode) {
        case `YMD`:
            return [...FOUR_DIGITS, separator, ...TWO_DIGITS, separator, ...TWO_DIGITS];
        case `MDY`:
        case `DMY`:
        default:
            return [...TWO_DIGITS, separator, ...TWO_DIGITS, separator, ...FOUR_DIGITS];
    }
}

function tuiCreateDateRangeMask(dateMode, dateSeparator) {
    ngDevMode &&
        tuiAssert.assert(dateSeparator.length === 1, `Separator should consist of only 1 symbol`);
    const dateMask = tuiCreateDateMask(dateMode, dateSeparator);
    return [
        ...dateMask,
        CHAR_NO_BREAK_SPACE,
        CHAR_EN_DASH,
        CHAR_NO_BREAK_SPACE,
        ...dateMask,
    ];
}

function tuiCreateTimePartMask(maxPartValue, prefix) {
    const { length } = String(maxPartValue);
    const regExp = new Array(length).fill(TUI_DIGIT_REGEXP);
    if (prefix) {
        regExp.unshift(prefix);
    }
    return regExp;
}
function tuiCreateTimeMask(mode, maxValues = {}) {
    const { HH, MM, SS, MS } = Object.assign(Object.assign({}, MAX_TIME_VALUES), maxValues);
    return [
        ...tuiCreateTimePartMask(HH),
        ...tuiCreateTimePartMask(MM, `:`),
        ...(mode.includes(`HH:MM:SS`) ? tuiCreateTimePartMask(SS, `:`) : []),
        ...(mode === `HH:MM:SS.MSS` ? tuiCreateTimePartMask(MS, `.`) : []),
    ];
}

/**
 * Generated bundle index. Do not edit.
 */

export { tuiCreateAutoCorrectedDatePipe, tuiCreateAutoCorrectedDateRangePipe, tuiCreateAutoCorrectedDateTimePipe, tuiCreateAutoCorrectedTimePipe, tuiCreateDateMask, tuiCreateDateRangeMask, tuiCreateTimeMask, tuiNormalizeDateValue };
//# sourceMappingURL=taiga-ui-kit-utils-mask.js.map
