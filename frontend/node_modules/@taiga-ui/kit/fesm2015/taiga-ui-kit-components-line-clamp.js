import { __decorate } from 'tslib';
import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, HostBinding, InjectionToken, Directive, Inject, ElementRef, Renderer2, ChangeDetectorRef, NgZone, ViewChild, Input, Output, HostListener, NgModule } from '@angular/core';
import * as i1$1 from '@taiga-ui/cdk';
import { TuiDestroyService, TuiHoveredService, tuiTypedFromEvent, tuiIsCurrentTarget, tuiZonefree, tuiDefaultProp, TuiResizeModule, TuiLetModule } from '@taiga-ui/cdk';
import * as i3 from '@taiga-ui/core';
import { TuiHintComponent, TuiPositionService, tuiPositionAccessorFor, tuiRectAccessorFor, TuiHintDirective, tuiFadeIn, TuiPositionAccessor, tuiAsPositionAccessor, TUI_HINT_COMPONENT, TuiHintModule } from '@taiga-ui/core';
import { BehaviorSubject, Subject, of, timer } from 'rxjs';
import { distinctUntilChanged, startWith, pairwise, switchMap, filter, map } from 'rxjs/operators';
import * as i1 from '@tinkoff/ng-polymorpheus';
import { PolymorpheusModule } from '@tinkoff/ng-polymorpheus';
import * as i5 from '@angular/common';
import { CommonModule } from '@angular/common';

class TuiLineClampBoxComponent extends TuiHintComponent {
    get width() {
        return this.accessor.getClientRect().width;
    }
}
TuiLineClampBoxComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiLineClampBoxComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
TuiLineClampBoxComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: TuiLineClampBoxComponent, selector: "tui-line-clamp-box", host: { properties: { "style.minWidth.px": "this.width" } }, providers: [
        TuiDestroyService,
        TuiPositionService,
        TuiHoveredService,
        tuiPositionAccessorFor('hint'),
        tuiRectAccessorFor('hint', TuiHintDirective),
    ], usesInheritance: true, ngImport: i0, template: `
        <ng-container *polymorpheusOutlet="content as text">{{ text }}</ng-container>
    `, isInline: true, styles: [":host{box-shadow:0 1.5rem 1rem #00000008,0 .75rem .75rem #0000000a,0 .25rem .375rem #0000000d;position:absolute;width:-webkit-min-content;width:min-content;padding:.75rem 1rem;margin-left:calc(-1px - 1rem);margin-top:calc(-1px - .75rem);border-radius:var(--tui-radius-l);box-sizing:content-box;border:1px solid var(--tui-base-03);background:var(--tui-base-01);color:var(--tui-text-01);word-wrap:break-word}\n"], directives: [{ type: i1.PolymorpheusOutletDirective, selector: "[polymorpheusOutlet]", inputs: ["polymorpheusOutlet", "polymorpheusOutletContext"] }], animations: [tuiFadeIn], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiLineClampBoxComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'tui-line-clamp-box',
                    template: `
        <ng-container *polymorpheusOutlet="content as text">{{ text }}</ng-container>
    `,
                    styleUrls: ['./line-clamp-box.style.less'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        TuiDestroyService,
                        TuiPositionService,
                        TuiHoveredService,
                        tuiPositionAccessorFor('hint'),
                        tuiRectAccessorFor('hint', TuiHintDirective),
                    ],
                    animations: [tuiFadeIn],
                }]
        }], propDecorators: { width: [{
                type: HostBinding,
                args: ['style.minWidth.px']
            }] } });

const TUI_LINE_CLAMP_DEFAULT_OPTIONS = {
    showHint: true,
};
/**
 * Default parameters for LineClamp component
 */
const TUI_LINE_CLAMP_OPTIONS = new InjectionToken(`[TUI_LINE_CLAMP_OPTIONS]`, {
    factory: () => TUI_LINE_CLAMP_DEFAULT_OPTIONS,
});
const tuiLineClampOptionsProvider = (options) => ({
    provide: TUI_LINE_CLAMP_OPTIONS,
    useValue: Object.assign(Object.assign({}, TUI_LINE_CLAMP_DEFAULT_OPTIONS), options),
});

class TuiLineClampPositionDirective extends TuiPositionAccessor {
    constructor(accessor) {
        super();
        this.accessor = accessor;
        this.type = 'hint';
    }
    getPosition() {
        const { top, left } = this.accessor.getClientRect();
        return [top, left];
    }
}
TuiLineClampPositionDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiLineClampPositionDirective, deps: [{ token: TuiHintDirective }], target: i0.ɵɵFactoryTarget.Directive });
TuiLineClampPositionDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiLineClampPositionDirective, selector: "[tuiHintCustomPosition]", providers: [tuiAsPositionAccessor(TuiLineClampPositionDirective)], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiLineClampPositionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiHintCustomPosition]',
                    providers: [tuiAsPositionAccessor(TuiLineClampPositionDirective)],
                }]
        }], ctorParameters: function () { return [{ type: i3.TuiRectAccessor, decorators: [{
                    type: Inject,
                    args: [TuiHintDirective]
                }] }]; } });

class TuiLineClampComponent {
    constructor(el, renderer, cd, ngZone, options) {
        this.el = el;
        this.renderer = renderer;
        this.cd = cd;
        this.ngZone = ngZone;
        this.options = options;
        this.linesLimit$ = new BehaviorSubject(1);
        this.isOverflown$ = new Subject();
        this.initialized = false;
        this.maxHeight = null;
        this.height = 0;
        this.lineHeight = 24;
        this.overflownChange = this.isOverflown$.pipe(distinctUntilChanged());
        this.lineClamp$ = this.linesLimit$.pipe(startWith(1), pairwise(), switchMap(([prev, next]) => next >= prev
            ? of(next)
            : tuiTypedFromEvent(this.el.nativeElement, 'transitionend').pipe(filter(tuiIsCurrentTarget), map(() => next))));
        this.skipInitialTransition();
    }
    set linesLimit(linesLimit) {
        this.linesLimit$.next(linesLimit);
    }
    get overflown() {
        if (!this.outlet) {
            return false;
        }
        const { scrollHeight, scrollWidth } = this.outlet.nativeElement;
        const { clientHeight, clientWidth } = this.el.nativeElement;
        // 4px buffer for IE/Edge incorrectly rounding scrollHeight
        return scrollHeight - clientHeight > 4 || scrollWidth - clientWidth > 0;
    }
    get computedContent() {
        return this.options.showHint && this.overflown ? this.content : '';
    }
    updateView() {
        this.cd.detectChanges();
    }
    ngAfterViewInit() {
        this.initialized = true;
    }
    ngDoCheck() {
        this.updateStaticallyHostBinding();
        this.isOverflown$.next(this.overflown);
    }
    skipInitialTransition() {
        timer(0)
            .pipe(tuiZonefree(this.ngZone))
            .subscribe(() => {
            this.renderer.addClass(this.el.nativeElement, '_initialized');
            this.cd.detectChanges();
        });
    }
    updateStaticallyHostBinding() {
        if (this.outlet) {
            this.height = this.outlet.nativeElement.scrollHeight + 4;
        }
        if (this.initialized) {
            this.maxHeight = this.lineHeight * this.linesLimit$.value;
        }
    }
}
TuiLineClampComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiLineClampComponent, deps: [{ token: ElementRef }, { token: Renderer2 }, { token: ChangeDetectorRef }, { token: NgZone }, { token: TUI_LINE_CLAMP_OPTIONS }], target: i0.ɵɵFactoryTarget.Component });
TuiLineClampComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: TuiLineClampComponent, selector: "tui-line-clamp", inputs: { linesLimit: "linesLimit", lineHeight: "lineHeight", content: "content" }, outputs: { overflownChange: "overflownChange" }, host: { listeners: { "transitionend": "updateView()" }, properties: { "style.maxHeight.px": "this.maxHeight", "style.height.px": "this.height" } }, providers: [
        {
            provide: TUI_HINT_COMPONENT,
            useValue: TuiLineClampBoxComponent,
        },
    ], viewQueries: [{ propertyName: "outlet", first: true, predicate: TuiHintDirective, descendants: true, read: ElementRef }], ngImport: i0, template: "<div\n    *tuiLet=\"lineClamp$ | async as lineClamp\"\n    tuiHintCustomPosition\n    class=\"t-wrapper\"\n    [tuiHint]=\"computedContent\"\n    [style.-webkit-line-clamp]=\"lineClamp\"\n    [style.word-break]=\"(lineClamp || 0) > 1 ? 'break-word' : 'break-all'\"\n    (tuiResize)=\"updateView()\"\n>\n    <ng-container *polymorpheusOutlet=\"content as text\">\n        {{ text }}\n    </ng-container>\n</div>\n", styles: [":host{position:relative;display:block;overflow:hidden}:host._initialized{transition-property:max-height;transition-duration:var(--tui-duration, .3s);transition-timing-function:ease-in-out}.t-wrapper{display:-webkit-box;-webkit-box-orient:vertical;overflow:hidden;overflow-wrap:anywhere}.t-wrapper ::ng-deep>*{white-space:initial}\n"], directives: [{ type: i1$1.TuiLetDirective, selector: "[tuiLet]", inputs: ["tuiLet"] }, { type: TuiLineClampPositionDirective, selector: "[tuiHintCustomPosition]" }, { type: i3.TuiHintDirective, selector: "[tuiHint]:not(ng-container)", inputs: ["tuiHint", "tuiHintContext", "tuiHintAppearance"] }, { type: i3.TuiHintDriverDirective, selector: "[tuiHint]" }, { type: i3.TuiHintHoverDirective, selector: "[tuiHint]:not(ng-container)", inputs: ["tuiHintShowDelay", "tuiHintHideDelay"], exportAs: ["tuiHintHover"] }, { type: i1$1.TuiResizeDirective, selector: "[tuiResize]", outputs: ["tuiResize"] }, { type: i1.PolymorpheusOutletDirective, selector: "[polymorpheusOutlet]", inputs: ["polymorpheusOutlet", "polymorpheusOutletContext"] }], pipes: { "async": i5.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
__decorate([
    tuiDefaultProp()
], TuiLineClampComponent.prototype, "linesLimit", null);
__decorate([
    tuiDefaultProp()
], TuiLineClampComponent.prototype, "lineHeight", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiLineClampComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'tui-line-clamp',
                    templateUrl: './line-clamp.template.html',
                    styleUrls: ['./line-clamp.style.less'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        {
                            provide: TUI_HINT_COMPONENT,
                            useValue: TuiLineClampBoxComponent,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i0.Renderer2, decorators: [{
                    type: Inject,
                    args: [Renderer2]
                }] }, { type: i0.ChangeDetectorRef, decorators: [{
                    type: Inject,
                    args: [ChangeDetectorRef]
                }] }, { type: i0.NgZone, decorators: [{
                    type: Inject,
                    args: [NgZone]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_LINE_CLAMP_OPTIONS]
                }] }]; }, propDecorators: { outlet: [{
                type: ViewChild,
                args: [TuiHintDirective, { read: ElementRef }]
            }], maxHeight: [{
                type: HostBinding,
                args: ['style.maxHeight.px']
            }], height: [{
                type: HostBinding,
                args: ['style.height.px']
            }], linesLimit: [{
                type: Input
            }], lineHeight: [{
                type: Input
            }], content: [{
                type: Input
            }], overflownChange: [{
                type: Output
            }], updateView: [{
                type: HostListener,
                args: ['transitionend']
            }] } });

class TuiLineClampModule {
}
TuiLineClampModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiLineClampModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TuiLineClampModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiLineClampModule, declarations: [TuiLineClampComponent,
        TuiLineClampBoxComponent,
        TuiLineClampPositionDirective], imports: [CommonModule,
        PolymorpheusModule,
        TuiHintModule,
        TuiResizeModule,
        TuiLetModule], exports: [TuiLineClampComponent] });
TuiLineClampModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiLineClampModule, imports: [[
            CommonModule,
            PolymorpheusModule,
            TuiHintModule,
            TuiResizeModule,
            TuiLetModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiLineClampModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        PolymorpheusModule,
                        TuiHintModule,
                        TuiResizeModule,
                        TuiLetModule,
                    ],
                    declarations: [
                        TuiLineClampComponent,
                        TuiLineClampBoxComponent,
                        TuiLineClampPositionDirective,
                    ],
                    exports: [TuiLineClampComponent],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { TUI_LINE_CLAMP_DEFAULT_OPTIONS, TUI_LINE_CLAMP_OPTIONS, TuiLineClampBoxComponent, TuiLineClampComponent, TuiLineClampModule, tuiLineClampOptionsProvider };
//# sourceMappingURL=taiga-ui-kit-components-line-clamp.js.map
