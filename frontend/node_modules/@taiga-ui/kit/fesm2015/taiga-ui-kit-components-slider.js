import * as i0 from '@angular/core';
import { InjectionToken, ChangeDetectorRef, ElementRef, Injector, Component, ChangeDetectionStrategy, Optional, Self, Inject, Input, HostBinding, forwardRef, Directive, HostListener, ContentChild, NgModule } from '@angular/core';
import * as i1 from '@angular/forms';
import { NgModel, NgControl } from '@angular/forms';
import { tuiWatch, tuiIsEdgeOlderThan, CHROMIUM_EDGE_START_VERSION, tuiDefaultProp, tuiPure, AbstractTuiControl, tuiIsNativeFocused, tuiClamp, tuiAssert, tuiTypedFromEvent, ALWAYS_TRUE_HANDLER, ALWAYS_FALSE_HANDLER, tuiCoerceBooleanProperty, TuiDestroyService } from '@taiga-ui/cdk';
import { tuiPercentageToKeyStepValue, tuiKeyStepValueToPercentage } from '@taiga-ui/kit/utils';
import { __decorate } from 'tslib';
import { USER_AGENT } from '@ng-web-apis/common';
import { take, tap, map, filter, takeUntil } from 'rxjs/operators';
import * as i1$2 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import * as i1$1 from 'rxjs';
import { merge, combineLatest } from 'rxjs';

const TUI_SLIDER_DEFAULT_OPTIONS = {
    size: `m`,
    trackColor: `var(--tui-base-03)`,
};
/**
 * Default parameters for Slider component
 */
const TUI_SLIDER_OPTIONS = new InjectionToken(`[TUI_SLIDER_OPTIONS]`, { factory: () => TUI_SLIDER_DEFAULT_OPTIONS });
function tuiSliderOptionsProvider(options) {
    return {
        provide: TUI_SLIDER_OPTIONS,
        useValue: Object.assign(Object.assign({}, TUI_SLIDER_DEFAULT_OPTIONS), options),
    };
}

class TuiSliderComponent {
    constructor(control, cdr, options, el, userAgent, injector) {
        var _a;
        this.control = control;
        this.options = options;
        this.el = el;
        this.userAgent = userAgent;
        this.injector = injector;
        this.size = this.options.size;
        this.segments = 1;
        if (control instanceof NgModel) {
            /**
             * The ValueAccessor.writeValue method is called twice on any value accessor during component initialization,
             * when a control is bound using [(ngModel)], first time with a phantom null value.
             * With `changeDetection: ChangeDetectionStrategy.OnPush` the second call of writeValue with real value don't re-render the view.
             * ___
             * See this {@link https://github.com/angular/angular/issues/14988 issue}
             */
            (_a = control.valueChanges) === null || _a === void 0 ? void 0 : _a.pipe(tuiWatch(cdr), take(1)).subscribe();
        }
    }
    get min() {
        return Number(this.el.nativeElement.min);
    }
    get max() {
        return Number(this.el.nativeElement.max || 100);
    }
    get step() {
        return Number(this.el.nativeElement.step) || 1;
    }
    get value() {
        const { el, control, hasKeySteps } = this;
        if (!hasKeySteps && control instanceof NgModel) {
            /**
             * If developer uses `[(ngModel)]` and programmatically change value,
             * the `el.nativeElement.value` is equal to the previous value at this moment.
             */
            return control.viewModel;
        }
        return Number(el.nativeElement.value) || 0;
    }
    set value(newValue) {
        this.el.nativeElement.value = `${newValue}`;
    }
    get valuePercentage() {
        return (100 * (this.value - this.min)) / (this.max - this.min) || 0;
    }
    get segmentWidth() {
        return 100 / Math.max(1, this.segments);
    }
    // TODO: drop support of legacy Edge (EdgeHTML) in v4.x
    get isOldEdge() {
        return tuiIsEdgeOlderThan(CHROMIUM_EDGE_START_VERSION, this.userAgent);
    }
    get hasKeySteps() {
        return Boolean(this.injector.get(TuiSliderKeyStepsDirective, null));
    }
}
TuiSliderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderComponent, deps: [{ token: NgControl, optional: true, self: true }, { token: ChangeDetectorRef }, { token: TUI_SLIDER_OPTIONS }, { token: ElementRef }, { token: USER_AGENT }, { token: Injector }], target: i0.ɵɵFactoryTarget.Component });
TuiSliderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: TuiSliderComponent, selector: "input[type=range][tuiSlider]", inputs: { size: "size", segments: "segments" }, host: { listeners: { "input": "0" }, properties: { "style.--tui-slider-track-color": "options.trackColor", "attr.data-size": "this.size", "style.--tui-slider-fill-percentage.%": "this.valuePercentage", "style.--tui-slider-segment-width.%": "this.segmentWidth", "class._old-edge": "this.isOldEdge" } }, ngImport: i0, template: '', isInline: true, styles: [":host{display:block;width:100%;color:var(--tui-primary);cursor:pointer}:host:active{cursor:ew-resize}:host:disabled{opacity:var(--tui-disabled-opacity);cursor:auto}:host:not(._old-edge){-webkit-appearance:none;-moz-appearance:none;appearance:none;height:.125rem;padding:.4375rem 0;background-color:transparent;background-clip:content-box;outline:none;border-radius:var(--tui-radius-m)}:host:not(._old-edge)::-webkit-slider-container{border-radius:inherit}:host:not(._old-edge)[data-size=m]::-webkit-slider-runnable-track{height:.125rem;border-radius:inherit;background-repeat:no-repeat;background-color:var(--tui-slider-track-color);background-image:linear-gradient(to right,currentColor 0px .625rem,transparent .25rem),repeating-linear-gradient(to right,var(--tui-base-07) 0 .25rem,transparent 0 var(--tui-slider-segment-width)),linear-gradient(to right,currentColor var(--tui-slider-fill-percentage),transparent var(--tui-slider-fill-percentage));background-position-x:0,.375rem,0;background-size:calc(100% - 1rem),calc(100% - 1rem),auto}:host:not(._old-edge)[data-size=s]::-webkit-slider-runnable-track{height:.125rem;border-radius:inherit;background-repeat:no-repeat;background-color:var(--tui-slider-track-color);background-image:linear-gradient(to right,currentColor 0px .375rem,transparent .25rem),repeating-linear-gradient(to right,var(--tui-base-07) 0 .25rem,transparent 0 var(--tui-slider-segment-width)),linear-gradient(to right,currentColor var(--tui-slider-fill-percentage),transparent var(--tui-slider-fill-percentage));background-position-x:0,.125rem,0;background-size:calc(100% - .5rem),calc(100% - .5rem),auto}:host:not(._old-edge)[data-size=m]::-moz-range-track{height:.125rem;border-radius:inherit;background-repeat:no-repeat;background-color:var(--tui-slider-track-color);background-image:linear-gradient(to right,currentColor 0px .625rem,transparent .25rem),repeating-linear-gradient(to right,var(--tui-base-07) 0 .25rem,transparent 0 var(--tui-slider-segment-width));background-position-x:0,.375rem;background-size:calc(100% - 1rem)}:host:not(._old-edge)[data-size=s]::-moz-range-track{height:.125rem;border-radius:inherit;background-repeat:no-repeat;background-color:var(--tui-slider-track-color);background-image:linear-gradient(to right,currentColor 0px .375rem,transparent .25rem),repeating-linear-gradient(to right,var(--tui-base-07) 0 .25rem,transparent 0 var(--tui-slider-segment-width));background-position-x:0,.125rem;background-size:calc(100% - .5rem)}:host:not(._old-edge)[data-size=m]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;background-color:currentColor;border:none;border-radius:50%;height:1rem;width:1rem;margin-top:-.4375rem}:not(:disabled):host:not(._old-edge)[data-size=m]::-webkit-slider-thumb{cursor:ew-resize}:not(:disabled):host:not(._old-edge)[data-size=m]::-webkit-slider-thumb:hover{background:var(--tui-primary-hover)}:not(:disabled):host:not(._old-edge)[data-size=m]::-webkit-slider-thumb:active{background:var(--tui-primary-active)}:focus-visible:host:not(._old-edge)[data-size=m]::-webkit-slider-thumb{box-shadow:0 0 0 2px inset var(--tui-focus)}:host:not(._old-edge)[data-size=s]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;background-color:currentColor;border:none;border-radius:50%;height:.5rem;width:.5rem;margin-top:-.1875rem}:not(:disabled):host:not(._old-edge)[data-size=s]::-webkit-slider-thumb{cursor:ew-resize}:not(:disabled):host:not(._old-edge)[data-size=s]::-webkit-slider-thumb:hover{background:var(--tui-primary-hover)}:not(:disabled):host:not(._old-edge)[data-size=s]::-webkit-slider-thumb:active{background:var(--tui-primary-active)}:focus-visible:host:not(._old-edge)[data-size=s]::-webkit-slider-thumb{box-shadow:0 0 0 2px inset var(--tui-focus)}:host:not(._old-edge)[data-size=m]::-moz-range-thumb{-moz-appearance:none;appearance:none;background-color:currentColor;border:none;border-radius:50%;height:1rem;width:1rem}:not(:disabled):host:not(._old-edge)[data-size=m]::-moz-range-thumb{cursor:ew-resize}:not(:disabled):host:not(._old-edge)[data-size=m]::-moz-range-thumb:hover{background:var(--tui-primary-hover)}:not(:disabled):host:not(._old-edge)[data-size=m]::-moz-range-thumb:active{background:var(--tui-primary-active)}:focus-visible:host:not(._old-edge)[data-size=m]::-moz-range-thumb{box-shadow:0 0 0 2px inset var(--tui-focus)}:host:not(._old-edge)[data-size=s]::-moz-range-thumb{-moz-appearance:none;appearance:none;background-color:currentColor;border:none;border-radius:50%;height:.5rem;width:.5rem}:not(:disabled):host:not(._old-edge)[data-size=s]::-moz-range-thumb{cursor:ew-resize}:not(:disabled):host:not(._old-edge)[data-size=s]::-moz-range-thumb:hover{background:var(--tui-primary-hover)}:not(:disabled):host:not(._old-edge)[data-size=s]::-moz-range-thumb:active{background:var(--tui-primary-active)}:focus-visible:host:not(._old-edge)[data-size=s]::-moz-range-thumb{box-shadow:0 0 0 2px inset var(--tui-focus)}:host:not(._old-edge)::-moz-range-progress{border-radius:inherit}:host:not(._old-edge)::-moz-range-progress{height:.125rem;background:currentColor;border-top-right-radius:0;border-bottom-right-radius:0}:host._old-edge::-ms-thumb{background:currentColor;border-radius:50%}:host._old-edge::-ms-fill-lower{background:currentColor}:host._old-edge::-ms-track{background:var(--tui-slider-track-color);border:none}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
__decorate([
    tuiDefaultProp()
], TuiSliderComponent.prototype, "size", void 0);
__decorate([
    tuiDefaultProp()
], TuiSliderComponent.prototype, "segments", void 0);
__decorate([
    tuiPure
], TuiSliderComponent.prototype, "hasKeySteps", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderComponent, decorators: [{
            type: Component,
            args: [{
                    /**
                     * We have to call our component as `<input tuiSlider type="range" ... />`
                     * because otherwise built-in angular
                     * {@link https://github.com/angular/angular/blob/master/packages/forms/src/directives/range_value_accessor.ts#L45 RangeValueAccessor}
                     * cannot be matched by its CSS selector.
                     */
                    selector: 'input[type=range][tuiSlider]',
                    template: '',
                    styleUrls: ['./slider.style.less'],
                    host: {
                        /**
                         * For change detection.
                         * Webkit does not have built-in method for customization of filling progress (as Firefox).
                         * We draw filling of progress by `background: linear-gradient(...)` of the track.
                         * This function triggers change detection (for {@link valuePercentage} function) when we drag thumb of the input.
                         */
                        '(input)': '0',
                        '[style.--tui-slider-track-color]': 'options.trackColor',
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.NgControl, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }, {
                    type: Inject,
                    args: [NgControl]
                }] }, { type: i0.ChangeDetectorRef, decorators: [{
                    type: Inject,
                    args: [ChangeDetectorRef]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_SLIDER_OPTIONS]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [USER_AGENT]
                }] }, { type: i0.Injector, decorators: [{
                    type: Inject,
                    args: [Injector]
                }] }]; }, propDecorators: { size: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.data-size']
            }], segments: [{
                type: Input
            }], valuePercentage: [{
                type: HostBinding,
                args: ['style.--tui-slider-fill-percentage.%']
            }], segmentWidth: [{
                type: HostBinding,
                args: ['style.--tui-slider-segment-width.%']
            }], isOldEdge: [{
                type: HostBinding,
                args: ['class._old-edge']
            }], hasKeySteps: [] } });

class TuiSliderKeyStepsDirective extends AbstractTuiControl {
    constructor(control, cdr, el, slider) {
        super(control, cdr);
        this.el = el;
        this.slider = slider;
    }
    get nativeFocusableElement() {
        return this.computedDisabled ? null : this.el.nativeElement;
    }
    get focused() {
        return tuiIsNativeFocused(this.nativeFocusableElement);
    }
    get min() {
        return this.keySteps[0][1];
    }
    get max() {
        return this.keySteps[this.keySteps.length - 1][1];
    }
    updateControlValue() {
        this.value = tuiPercentageToKeyStepValue(this.slider.valuePercentage, this.keySteps);
    }
    writeValue(controlValue) {
        if (controlValue === null) {
            return;
        }
        const clampedControlValue = tuiClamp(controlValue, this.min, this.max);
        ngDevMode &&
            tuiAssert.assert(controlValue === clampedControlValue, '\n[SliderKeySteps]: You cannot programmatically set value which is less/more than min/max');
        this.slider.value = this.transformToNativeValue(clampedControlValue);
    }
    getFallbackValue() {
        return 0;
    }
    transformToNativeValue(controlValue) {
        const { min, max } = this.slider;
        const newValuePercentage = tuiKeyStepValueToPercentage(controlValue, this.keySteps);
        return (newValuePercentage * (max - min)) / 100 + min;
    }
}
TuiSliderKeyStepsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderKeyStepsDirective, deps: [{ token: NgControl, optional: true, self: true }, { token: ChangeDetectorRef }, { token: ElementRef }, { token: forwardRef(() => TuiSliderComponent) }], target: i0.ɵɵFactoryTarget.Directive });
TuiSliderKeyStepsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiSliderKeyStepsDirective, selector: "input[tuiSlider][keySteps]", inputs: { keySteps: "keySteps" }, host: { listeners: { "input": "updateControlValue()", "change": "updateControlValue()" }, properties: { "attr.aria-valuenow": "safeCurrentValue", "attr.aria-valuemin": "min", "attr.aria-valuemax": "max" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderKeyStepsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[tuiSlider][keySteps]',
                    host: {
                        '[attr.aria-valuenow]': 'safeCurrentValue',
                        '[attr.aria-valuemin]': 'min',
                        '[attr.aria-valuemax]': 'max',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i1.NgControl, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }, {
                    type: Inject,
                    args: [NgControl]
                }] }, { type: i0.ChangeDetectorRef, decorators: [{
                    type: Inject,
                    args: [ChangeDetectorRef]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: TuiSliderComponent, decorators: [{
                    type: Inject,
                    args: [forwardRef(() => TuiSliderComponent)]
                }] }]; }, propDecorators: { keySteps: [{
                type: Input
            }], updateControlValue: [{
                type: HostListener,
                args: ['input']
            }, {
                type: HostListener,
                args: ['change']
            }] } });

const SLIDER_INTERACTION_KEYS = new Set([
    'ArrowLeft',
    'ArrowRight',
    'ArrowUp',
    'ArrowDown',
    'Home',
    'End',
    'PageUp',
    'PageDown',
]);
/**
 * Native <input type='range' readonly> doesn't work.
 * This directive imitates this native behaviour.
 */
class TuiSliderReadonlyDirective {
    constructor(el, doc, destroy$) {
        this.readonly = true;
        const touchStart$ = tuiTypedFromEvent(el.nativeElement, 'touchstart', {
            passive: false,
        });
        const touchMove$ = tuiTypedFromEvent(doc, 'touchmove', {
            passive: false,
        });
        const touchEnd$ = tuiTypedFromEvent(doc, 'touchend', {
            passive: true,
        });
        const shouldPreventMove$ = merge(touchStart$.pipe(tap(e => this.preventEvent(e)), map(ALWAYS_TRUE_HANDLER)), touchEnd$.pipe(map(ALWAYS_FALSE_HANDLER)));
        /**
         * @bad TODO think about another solution.
         * Keep in mind that preventing touch event (on slider) inside `@HostListener('touchstart')` doesn't work for mobile chrome.
         */
        combineLatest([touchMove$, shouldPreventMove$])
            .pipe(filter(([_, shouldPreventMove]) => shouldPreventMove), takeUntil(destroy$))
            .subscribe(([moveEvent]) => this.preventEvent(moveEvent));
    }
    preventEvent(event) {
        if (event.cancelable && tuiCoerceBooleanProperty(this.readonly)) {
            event.preventDefault();
        }
    }
    preventKeyboardInteraction(event) {
        if (SLIDER_INTERACTION_KEYS.has(event.key)) {
            this.preventEvent(event);
        }
    }
}
TuiSliderReadonlyDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderReadonlyDirective, deps: [{ token: ElementRef }, { token: DOCUMENT }, { token: TuiDestroyService, self: true }], target: i0.ɵɵFactoryTarget.Directive });
TuiSliderReadonlyDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiSliderReadonlyDirective, selector: "input[tuiSlider][readonly]", inputs: { readonly: "readonly" }, host: { listeners: { "mousedown": "preventEvent($event)", "keydown": "preventKeyboardInteraction($event)" } }, providers: [TuiDestroyService], ngImport: i0 });
__decorate([
    tuiDefaultProp()
], TuiSliderReadonlyDirective.prototype, "readonly", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderReadonlyDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[tuiSlider][readonly]',
                    providers: [TuiDestroyService],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i1$1.Observable, decorators: [{
                    type: Self
                }, {
                    type: Inject,
                    args: [TuiDestroyService]
                }] }]; }, propDecorators: { readonly: [{
                type: Input
            }], preventEvent: [{
                type: HostListener,
                args: ['mousedown', ['$event']]
            }], preventKeyboardInteraction: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

class TuiSliderThumbLabelComponent {
    get size() {
        var _a;
        return ((_a = this.slider) === null || _a === void 0 ? void 0 : _a.size) || 'm';
    }
    get ratio() {
        var _a;
        return (((_a = this.slider) === null || _a === void 0 ? void 0 : _a.valuePercentage) || 0) / 100;
    }
    get ghostLeft() {
        var _a;
        return this.ratio * (((_a = this.slider) === null || _a === void 0 ? void 0 : _a.el.nativeElement.offsetWidth) || 0);
    }
    ngAfterContentInit() {
        var _a;
        ngDevMode &&
            tuiAssert.assert(Boolean((_a = this.control) === null || _a === void 0 ? void 0 : _a.valueChanges), '\n[tuiSliderThumbLabel] expected <input tuiSlider type="range" /> to use Angular Forms.\n' +
                'Use [(ngModel)] or [formControl] or formControlName for correct work.');
    }
}
TuiSliderThumbLabelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderThumbLabelComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TuiSliderThumbLabelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: TuiSliderThumbLabelComponent, selector: "[tuiSliderThumbLabel]", queries: [{ propertyName: "slider", first: true, predicate: TuiSliderComponent, descendants: true }, { propertyName: "control", first: true, predicate: NgControl, descendants: true }], ngImport: i0, template: "<ng-container *ngIf=\"control?.valueChanges | async\"></ng-container>\n\n<div\n    class=\"t-ghost\"\n    [attr.data-size]=\"size\"\n    [style.left.px]=\"ghostLeft\"\n    [style.--tui-slider-thumb-ratio]=\"ratio\"\n>\n    <ng-content></ng-content>\n</div>\n\n<ng-content select=\"input[type=range]\"></ng-content>\n", styles: [":host{position:relative}.t-ghost{position:absolute;top:0;bottom:0;margin:auto;border-radius:50%;pointer-events:none}.t-ghost[data-size=s]{width:.5rem;height:.5rem;transform:translate(calc(var(--tui-slider-thumb-ratio) * -.5rem))}.t-ghost[data-size=m]{width:1rem;height:1rem;transform:translate(calc(var(--tui-slider-thumb-ratio) * -1rem))}\n"], directives: [{ type: i1$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i1$2.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderThumbLabelComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[tuiSliderThumbLabel]',
                    templateUrl: './slider-thumb-label.template.html',
                    styleUrls: ['./slider-thumb-label.style.less'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { slider: [{
                type: ContentChild,
                args: [TuiSliderComponent]
            }], control: [{
                type: ContentChild,
                args: [NgControl]
            }] } });

class TuiSliderModule {
}
TuiSliderModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TuiSliderModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderModule, declarations: [TuiSliderComponent,
        TuiSliderThumbLabelComponent,
        TuiSliderKeyStepsDirective,
        TuiSliderReadonlyDirective], imports: [CommonModule], exports: [TuiSliderComponent,
        TuiSliderThumbLabelComponent,
        TuiSliderKeyStepsDirective,
        TuiSliderReadonlyDirective] });
TuiSliderModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [
                        TuiSliderComponent,
                        TuiSliderThumbLabelComponent,
                        TuiSliderKeyStepsDirective,
                        TuiSliderReadonlyDirective,
                    ],
                    exports: [
                        TuiSliderComponent,
                        TuiSliderThumbLabelComponent,
                        TuiSliderKeyStepsDirective,
                        TuiSliderReadonlyDirective,
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { TUI_SLIDER_DEFAULT_OPTIONS, TUI_SLIDER_OPTIONS, TuiSliderComponent, TuiSliderKeyStepsDirective, TuiSliderModule, TuiSliderReadonlyDirective, TuiSliderThumbLabelComponent, tuiSliderOptionsProvider };
//# sourceMappingURL=taiga-ui-kit-components-slider.js.map
