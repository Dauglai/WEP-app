import { __decorate } from 'tslib';
import * as i0 from '@angular/core';
import { ChangeDetectorRef, ElementRef, Component, ChangeDetectionStrategy, Optional, Self, Inject, Input, HostBinding, ViewChildren, HostListener, EventEmitter, Directive, Output, NgModule } from '@angular/core';
import * as i2 from '@angular/forms';
import { NgControl, FormsModule } from '@angular/forms';
import * as i3 from '@taiga-ui/cdk';
import { AbstractTuiControl, EMPTY_QUERY, tuiIsNativeFocusedIn, tuiClamp, tuiQuantize, tuiDefaultProp, tuiPure, tuiTypedFromEvent, tuiRound, TuiDestroyService, TuiFocusableModule } from '@taiga-ui/cdk';
import * as i1 from '@taiga-ui/kit/components/slider';
import { TuiSliderComponent, TuiSliderModule } from '@taiga-ui/kit/components/slider';
import { tuiPercentageToKeyStepValue, tuiKeyStepValueToPercentage } from '@taiga-ui/kit/utils';
import { DOCUMENT, CommonModule } from '@angular/common';
import { TUI_FLOATING_PRECISION } from '@taiga-ui/kit/constants';
import * as i2$1 from 'rxjs';
import { merge } from 'rxjs';
import { filter, map, tap, switchMap, startWith, takeUntil, repeat } from 'rxjs/operators';

class TuiRangeComponent extends AbstractTuiControl {
    constructor(control, cdr, el) {
        super(control, cdr);
        this.el = el;
        this.min = 0;
        this.max = 100;
        this.step = 1;
        this.size = 'm';
        this.segments = 1;
        this.keySteps = null;
        this.slidersRefs = EMPTY_QUERY;
        this.lastActiveThumb = 'right';
    }
    get nativeFocusableElement() {
        const [sliderLeftRef, sliderRightRef] = this.slidersRefs;
        if (this.computedDisabled ||
            !this.focusable ||
            !sliderLeftRef ||
            !sliderRightRef) {
            return null;
        }
        const isLeftThumbLocked = this.right === 100;
        return isLeftThumbLocked
            ? sliderRightRef.nativeElement
            : sliderLeftRef.nativeElement;
    }
    get focused() {
        return tuiIsNativeFocusedIn(this.el.nativeElement);
    }
    get fractionStep() {
        return this.step / (this.max - this.min);
    }
    get computedKeySteps() {
        return this.computePureKeySteps(this.keySteps, this.min, this.max);
    }
    get segmentWidthRatio() {
        return 1 / this.segments;
    }
    get left() {
        return this.getPercentageFromValue(this.value[0]);
    }
    get right() {
        return 100 - this.getPercentageFromValue(this.value[1]);
    }
    onFocused(focused) {
        this.updateFocused(focused);
    }
    changeByStep(coefficient, target) {
        const [sliderLeftRef, sliderRightRef] = this.slidersRefs;
        const leftThumbElement = sliderLeftRef.nativeElement;
        const rightThumbElement = sliderRightRef.nativeElement;
        const isRightThumb = target === this.el.nativeElement
            ? this.lastActiveThumb === 'right'
            : target === rightThumbElement;
        const activeThumbElement = isRightThumb ? rightThumbElement : leftThumbElement;
        const previousValue = isRightThumb ? this.value[1] : this.value[0];
        /** @bad TODO think about a solution without twice conversion */
        const previousFraction = this.getPercentageFromValue(previousValue) / 100;
        const newFractionValue = previousFraction + coefficient * this.fractionStep;
        this.processValue(this.getValueFromFraction(newFractionValue), isRightThumb);
        if (activeThumbElement) {
            activeThumbElement.focus();
        }
    }
    processValue(value, right) {
        if (right) {
            this.updateEnd(value);
        }
        else {
            this.updateStart(value);
        }
        this.lastActiveThumb = right ? 'right' : 'left';
    }
    getValueFromFraction(fraction) {
        const guardedFraction = tuiClamp(tuiQuantize(fraction, this.fractionStep), 0, 1);
        return tuiPercentageToKeyStepValue(guardedFraction * 100, this.computedKeySteps);
    }
    getPercentageFromValue(value) {
        return tuiKeyStepValueToPercentage(value, this.computedKeySteps);
    }
    getFallbackValue() {
        return [0, 0];
    }
    computePureKeySteps(keySteps, min, max) {
        return (keySteps || [
            [0, min],
            [100, max],
        ]);
    }
    updateStart(value) {
        this.value = [Math.min(value, this.value[1]), this.value[1]];
    }
    updateEnd(value) {
        this.value = [this.value[0], Math.max(value, this.value[0])];
    }
}
TuiRangeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiRangeComponent, deps: [{ token: NgControl, optional: true, self: true }, { token: ChangeDetectorRef }, { token: ElementRef }], target: i0.ɵɵFactoryTarget.Component });
TuiRangeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: TuiRangeComponent, selector: "tui-range", inputs: { min: "min", max: "max", step: "step", size: "size", segments: "segments", keySteps: "keySteps" }, host: { listeners: { "focusin": "onFocused(true)", "focusout": "onFocused(false)", "keydown.arrowUp.prevent": "changeByStep(1,$event.target)", "keydown.arrowRight.prevent": "changeByStep(1,$event.target)", "keydown.arrowLeft.prevent": "changeByStep(-1,$event.target)", "keydown.arrowDown.prevent": "changeByStep(-1,$event.target)" }, properties: { "attr.tabindex": "-1", "attr.aria-disabled": "computedDisabled", "attr.data-size": "this.size", "style.--left.%": "this.left", "style.--right.%": "this.right" } }, viewQueries: [{ propertyName: "slidersRefs", predicate: TuiSliderComponent, descendants: true, read: ElementRef }], usesInheritance: true, ngImport: i0, template: "<div\n    class=\"t-track\"\n    [style.--segment-width.%]=\"segmentWidthRatio * 100\"\n    [style.--bg-size-ratio]=\"1 - segmentWidthRatio\"\n>\n    <input\n        tuiSlider\n        readonly\n        type=\"range\"\n        step=\"any\"\n        automation-id=\"tui-range__left\"\n        class=\"t-thumb\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [ngModel]=\"value[0]\"\n        [size]=\"size\"\n        [keySteps]=\"computedKeySteps\"\n        [tuiFocusable]=\"focusable\"\n        [attr.disabled]=\"computedDisabled || null\"\n    />\n    <input\n        tuiSlider\n        readonly\n        type=\"range\"\n        step=\"any\"\n        automation-id=\"tui-range__right\"\n        class=\"t-thumb\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [ngModel]=\"value[1]\"\n        [size]=\"size\"\n        [keySteps]=\"computedKeySteps\"\n        [tuiFocusable]=\"focusable\"\n        [attr.disabled]=\"computedDisabled || null\"\n    />\n</div>\n", styles: [":host{position:relative;display:block;height:.125rem;border-radius:var(--tui-radius-m);background:var(--tui-base-03);cursor:pointer;outline:none;margin:.4375rem 0;touch-action:pan-x}:host:active{cursor:ew-resize}:host:after{content:\"\";position:absolute;top:-.4375rem;bottom:-.4375rem;width:100%}:host._disabled{opacity:var(--tui-disabled-opacity);cursor:auto}:host[data-size=s] .t-track{position:relative;margin:0 .25rem;height:100%}:host[data-size=s] .t-track:before{content:\"\";position:absolute;top:0;left:var(--left);right:var(--right);height:100%;background:var(--tui-primary);margin:0 -.25rem}:host[data-size=s] .t-track:after{position:absolute;top:0;left:0;bottom:0;right:0;content:\"\";left:.125rem;right:.375rem;background-image:repeating-linear-gradient(to right,var(--tui-base-07) 0 .25rem,transparent 0 calc(var(--segment-width) / var(--bg-size-ratio)));background-position-x:right;background-repeat:no-repeat;background-size:calc(100% * var(--bg-size-ratio))}:host[data-size=m] .t-track{position:relative;margin:0 .5rem;height:100%}:host[data-size=m] .t-track:before{content:\"\";position:absolute;top:0;left:var(--left);right:var(--right);height:100%;background:var(--tui-primary);margin:0 -.5rem}:host[data-size=m] .t-track:after{position:absolute;top:0;left:0;bottom:0;right:0;content:\"\";left:.375rem;right:.625rem;background-image:repeating-linear-gradient(to right,var(--tui-base-07) 0 .25rem,transparent 0 calc(var(--segment-width) / var(--bg-size-ratio)));background-position-x:right;background-repeat:no-repeat;background-size:calc(100% * var(--bg-size-ratio))}.t-thumb{pointer-events:none;position:absolute;top:.0625rem;left:0;right:0;z-index:1;transform:translateY(-50%);margin:0}.t-thumb::-webkit-slider-thumb{pointer-events:all}.t-thumb::-moz-range-thumb{pointer-events:all}input[type=range].t-thumb::-webkit-slider-runnable-track{background:transparent}input[type=range].t-thumb::-moz-range-track{background:transparent}input[type=range].t-thumb::-moz-range-progress{background:transparent}input[type=range].t-thumb::-ms-track{background:transparent}input[type=range].t-thumb::-ms-fill-lower{background:transparent}.t-thumb:last-of-type::-webkit-slider-thumb{transform:translate(50%)}.t-thumb:first-of-type::-webkit-slider-thumb{transform:translate(-50%)}.t-thumb:last-of-type::-moz-range-thumb{transform:translate(50%)}.t-thumb:first-of-type::-moz-range-thumb{transform:translate(-50%)}:host._disabled .t-thumb{opacity:1}\n"], components: [{ type: i1.TuiSliderComponent, selector: "input[type=range][tuiSlider]", inputs: ["size", "segments"] }], directives: [{ type: i1.TuiSliderReadonlyDirective, selector: "input[tuiSlider][readonly]", inputs: ["readonly"] }, { type: i1.TuiSliderKeyStepsDirective, selector: "input[tuiSlider][keySteps]", inputs: ["keySteps"] }, { type: i2.RangeValueAccessor, selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]" }, { type: i2.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i3.TuiFocusableDirective, selector: "[tuiFocusable]", inputs: ["tuiFocusable"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
__decorate([
    tuiDefaultProp()
], TuiRangeComponent.prototype, "min", void 0);
__decorate([
    tuiDefaultProp()
], TuiRangeComponent.prototype, "max", void 0);
__decorate([
    tuiDefaultProp(s => s > 0, 'Step must be a non-negative number')
], TuiRangeComponent.prototype, "step", void 0);
__decorate([
    tuiDefaultProp()
], TuiRangeComponent.prototype, "size", void 0);
__decorate([
    tuiDefaultProp(s => s > 0 && Number.isInteger(s), 'Segments must be positive integer')
], TuiRangeComponent.prototype, "segments", void 0);
__decorate([
    tuiDefaultProp()
], TuiRangeComponent.prototype, "keySteps", void 0);
__decorate([
    tuiPure
], TuiRangeComponent.prototype, "computePureKeySteps", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiRangeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'tui-range',
                    templateUrl: './range.template.html',
                    styleUrls: ['./range.style.less'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        '[attr.tabindex]': '-1',
                        '[attr.aria-disabled]': 'computedDisabled',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i2.NgControl, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }, {
                    type: Inject,
                    args: [NgControl]
                }] }, { type: i0.ChangeDetectorRef, decorators: [{
                    type: Inject,
                    args: [ChangeDetectorRef]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }]; }, propDecorators: { min: [{
                type: Input
            }], max: [{
                type: Input
            }], step: [{
                type: Input
            }], size: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.data-size']
            }], segments: [{
                type: Input
            }], keySteps: [{
                type: Input
            }], slidersRefs: [{
                type: ViewChildren,
                args: [TuiSliderComponent, { read: ElementRef }]
            }], left: [{
                type: HostBinding,
                args: ['style.--left.%']
            }], right: [{
                type: HostBinding,
                args: ['style.--right.%']
            }], onFocused: [{
                type: HostListener,
                args: ['focusin', ['true']]
            }, {
                type: HostListener,
                args: ['focusout', ['false']]
            }], changeByStep: [{
                type: HostListener,
                args: ['keydown.arrowUp.prevent', ['1', '$event.target']]
            }, {
                type: HostListener,
                args: ['keydown.arrowRight.prevent', ['1', '$event.target']]
            }, {
                type: HostListener,
                args: ['keydown.arrowLeft.prevent', ['-1', '$event.target']]
            }, {
                type: HostListener,
                args: ['keydown.arrowDown.prevent', ['-1', '$event.target']]
            }], computePureKeySteps: [] } });

class TuiRangeChangeDirective {
    constructor(doc, el, range, destroy$) {
        this.doc = doc;
        this.el = el;
        this.range = range;
        /**
         * TODO replace with pointer events (when all supported browsers can handle them).
         * Don't forget to use setPointerCapture instead of listening all doc events
         */
        this.pointerDown$ = merge(tuiTypedFromEvent(this.el.nativeElement, 'touchstart', {
            passive: true,
        }).pipe(filter(({ touches }) => touches.length === 1), map(({ touches }) => touches[0])), tuiTypedFromEvent(this.el.nativeElement, 'mousedown', { passive: true }));
        this.pointerMove$ = merge(tuiTypedFromEvent(this.doc, 'touchmove').pipe(filter(({ touches }) => touches.length === 1), map(({ touches }) => touches[0])), tuiTypedFromEvent(this.doc, 'mousemove'));
        this.pointerUp$ = merge(tuiTypedFromEvent(this.doc, 'touchend', { passive: true }), tuiTypedFromEvent(this.doc, 'mouseup', { passive: true }));
        this.activeThumbChange = new EventEmitter();
        let activeThumb;
        this.pointerDown$
            .pipe(tap(({ clientX, target }) => {
            activeThumb = this.detectActiveThumb(clientX, target);
            this.activeThumbChange.emit(activeThumb);
            if (this.range.focusable) {
                el.nativeElement.focus();
            }
        }), switchMap(event => this.pointerMove$.pipe(startWith(event))), map(({ clientX }) => this.getFractionFromEvents(clientX)), takeUntil(this.pointerUp$), repeat(), takeUntil(destroy$))
            .subscribe(fraction => {
            const value = this.range.getValueFromFraction(fraction);
            this.range.processValue(value, activeThumb === 'right');
        });
    }
    getFractionFromEvents(clickClientX) {
        const hostRect = this.el.nativeElement.getBoundingClientRect();
        const value = clickClientX - hostRect.left;
        const total = hostRect.width;
        return tuiClamp(tuiRound(value / total, TUI_FLOATING_PRECISION), 0, 1);
    }
    detectActiveThumb(clientX, target) {
        const [leftSliderRef, rightSliderRef] = this.range.slidersRefs;
        switch (target) {
            case leftSliderRef.nativeElement:
                return 'left';
            case rightSliderRef.nativeElement:
                return 'right';
            default:
                return this.findNearestActiveThumb(clientX);
        }
    }
    findNearestActiveThumb(clientX) {
        const fraction = this.getFractionFromEvents(clientX);
        const deltaLeft = fraction * 100 - this.range.left;
        const deltaRight = fraction * 100 - 100 + this.range.right;
        return Math.abs(deltaLeft) > Math.abs(deltaRight) ||
            deltaRight > 0 ||
            (this.range.left === 0 && this.range.right === 100)
            ? 'right'
            : 'left';
    }
}
TuiRangeChangeDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiRangeChangeDirective, deps: [{ token: DOCUMENT }, { token: ElementRef }, { token: TuiRangeComponent }, { token: TuiDestroyService, self: true }], target: i0.ɵɵFactoryTarget.Directive });
TuiRangeChangeDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiRangeChangeDirective, selector: "tui-range", outputs: { activeThumbChange: "activeThumbChange" }, providers: [TuiDestroyService], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiRangeChangeDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'tui-range',
                    providers: [TuiDestroyService],
                }]
        }], ctorParameters: function () { return [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: TuiRangeComponent, decorators: [{
                    type: Inject,
                    args: [TuiRangeComponent]
                }] }, { type: i2$1.Observable, decorators: [{
                    type: Self
                }, {
                    type: Inject,
                    args: [TuiDestroyService]
                }] }]; }, propDecorators: { activeThumbChange: [{
                type: Output
            }] } });

class TuiRangeModule {
}
TuiRangeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiRangeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TuiRangeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiRangeModule, declarations: [TuiRangeComponent, TuiRangeChangeDirective], imports: [CommonModule, TuiFocusableModule, TuiSliderModule, FormsModule], exports: [TuiRangeComponent, TuiRangeChangeDirective] });
TuiRangeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiRangeModule, imports: [[CommonModule, TuiFocusableModule, TuiSliderModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiRangeModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, TuiFocusableModule, TuiSliderModule, FormsModule],
                    declarations: [TuiRangeComponent, TuiRangeChangeDirective],
                    exports: [TuiRangeComponent, TuiRangeChangeDirective],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { TuiRangeChangeDirective, TuiRangeComponent, TuiRangeModule };
//# sourceMappingURL=taiga-ui-kit-components-range.js.map
