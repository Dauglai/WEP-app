(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taiga-ui/cdk')) :
    typeof define === 'function' && define.amd ? define('@taiga-ui/core/utils/dom', ['exports', '@taiga-ui/cdk'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global["taiga-ui"] = global["taiga-ui"] || {}, global["taiga-ui"].core = global["taiga-ui"].core || {}, global["taiga-ui"].core.utils = global["taiga-ui"].core.utils || {}, global["taiga-ui"].core.utils.dom = {}), global.cdk));
})(this, (function (exports, cdk) { 'use strict';

    function tuiCheckFixedPosition(element) {
        if (!element || typeof getComputedStyle === "undefined") {
            return false;
        }
        var style = getComputedStyle(element);
        return (style.getPropertyValue("position") === "fixed" ||
            tuiCheckFixedPosition(element.parentElement));
    }

    /**
     * Calculates size of safe area on mobile devices (status bars)
     *
     * ATTENTION: Only use in browser environment
     */
    function tuiGetSafeAreaSize() {
        if (!CSS.supports("padding-top: env(safe-area-inset-top)")) {
            return 0;
        }
        var div = document.createElement("div");
        div.style.paddingTop = "env(safe-area-inset-top)";
        document.body.appendChild(div);
        var safeAreaSize = parseInt(window.getComputedStyle(div).paddingTop, 10) || 0;
        document.body.removeChild(div);
        return safeAreaSize;
    }

    function tuiGetScreenWidth(doc) {
        return Math.max(doc.documentElement.clientWidth, doc.defaultView ? doc.defaultView.innerWidth : 0);
    }

    /**
     * @description:
     * Cross-browser @media (height)
     *
     * 1. window.innerWidth
     * 1.1. gets CSS viewport @media (height) which include scrollbars
     * 1.2. initial-scale and zoom variations may cause mobile values to
     *      wrongly scale down to what PPK calls the visual
     *      viewport and be smaller than the @media values
     *  1.3. zoom may cause values to be 1px off due to native rounding
     *
     *  2. document.documentElement.clientHeight
     *  2.1. equals CSS viewport width minus scrollbar width
     *  2.2. matches @media (height) when there is no scrollbar
     *  2.3. available cross-browser
     *  2.4. inaccurate if doctype is missing
     */
    function tuiGetViewportHeight(_a) {
        var document = _a.document, innerHeight = _a.innerHeight;
        return Math.max(document.documentElement.clientHeight || 0, innerHeight || 0);
    }

    /**
     * @description:
     * Cross-browser @media (width)
     *
     * 1. window.innerWidth
     * 1.1. gets CSS viewport @media (width) which include scrollbars
     * 1.2. initial-scale and zoom variations may cause mobile values to
     *      wrongly scale down to what PPK calls the visual
     *      viewport and be smaller than the @media values
     *  1.3. zoom may cause values to be 1px off due to native rounding
     *
     *  2. document.documentElement.clientWidth
     *  2.1. equals CSS viewport width minus scrollbar width
     *  2.2. matches @media (width) when there is no scrollbar
     *  2.3. available cross-browser
     *  2.4. inaccurate if doctype is missing
     */
    function tuiGetViewportWidth(_a) {
        var document = _a.document, innerWidth = _a.innerWidth;
        return Math.max(document.documentElement.clientWidth || 0, innerWidth || 0);
    }

    /**
     * Creates a cloned range with its boundaries set at word boundaries
     *
     * @param currentRange a range to clone
     * @return modified range
     */
    // eslint-disable-next-line max-statements
    function tuiGetWordRange(currentRange) {
        var range = currentRange.cloneRange();
        var startContainer = range.startContainer, startOffset = range.startOffset, endContainer = range.endContainer, endOffset = range.endOffset;
        var ownerDocument = startContainer.ownerDocument;
        if (!ownerDocument) {
            return range;
        }
        var treeWalker = ownerDocument.createTreeWalker(ownerDocument.body, NodeFilter.SHOW_TEXT, cdk.svgNodeFilter);
        treeWalker.currentNode = startContainer;
        do {
            var container = treeWalker.currentNode;
            var textContent = container.textContent || "";
            var content = container === startContainer
                ? textContent.slice(0, Math.max(0, startOffset + 1))
                : textContent;
            var offset = Math.max(content.lastIndexOf(" "), content.lastIndexOf(cdk.CHAR_NO_BREAK_SPACE), content.lastIndexOf(cdk.CHAR_ZERO_WIDTH_SPACE)) + 1;
            range.setStart(container, 0);
            if (offset) {
                range.setStart(container, offset);
                break;
            }
        } while (treeWalker.previousNode());
        treeWalker.currentNode = endContainer;
        do {
            var container = treeWalker.currentNode;
            var textContent = container.textContent || "";
            var content = container === endContainer ? textContent.slice(endOffset + 1) : textContent;
            var offset = [
                content.indexOf(" "),
                content.indexOf(cdk.CHAR_NO_BREAK_SPACE),
                content.indexOf(cdk.CHAR_ZERO_WIDTH_SPACE),
            ].reduce(function (result, item) { return result === -1 || item === -1
                ? Math.max(result, item)
                : Math.min(result, item); }, -1);
            range.setEnd(container, textContent.length);
            if (offset !== -1) {
                range.setEnd(container, offset + textContent.length - content.length);
                break;
            }
        } while (treeWalker.nextNode());
        return range;
    }

    var WIDTH_SEARCH = "width=\"";
    var HEIGHT_SEARCH = "height=\"";
    var START = "<svg";
    function tuiProcessIcon(source, name) {
        if (source.includes("id=\"" + name + "\"")) {
            return source;
        }
        var src = source.slice(Math.max(0, source.indexOf(START)));
        var attributes = src.slice(0, Math.max(0, src.indexOf(">")));
        if (!(attributes === null || attributes === void 0 ? void 0 : attributes.includes(WIDTH_SEARCH)) || !attributes.includes(HEIGHT_SEARCH)) {
            return src.replace(START, "<svg xmlns=\"http://www.w3.org/2000/svg\"><g id=\"" + name + "\" xmlns=\"http://www.w3.org/2000/svg\"><svg") + "</g></svg>";
        }
        var indexOfWidth = attributes.indexOf(WIDTH_SEARCH);
        var indexOfHeight = attributes.indexOf(HEIGHT_SEARCH);
        var widthOffset = indexOfWidth + WIDTH_SEARCH.length;
        var heightOffset = indexOfHeight + HEIGHT_SEARCH.length;
        var widthString = attributes.slice(widthOffset, attributes.indexOf("\"", widthOffset));
        var heightString = attributes.slice(heightOffset, attributes.indexOf("\"", heightOffset));
        if (!heightString ||
            !widthString ||
            widthString.includes("%") ||
            heightString.includes("%") ||
            widthString.includes("em") ||
            heightString.includes("em")) {
            return src.replace(START, "<svg id=\"" + name + "\"");
        }
        var width = parseInt(widthString, 10);
        var height = parseInt(heightString, 10);
        return "<g id=\"" + name + "\" xmlns=\"http://www.w3.org/2000/svg\"><svg  x=\"50%\" y=\"50%\" width=\"" + width / 16 + "em\" height=\"" + height / 16 + "em\" overflow=\"visible\" viewBox=\"0 0 " + width + " " + height + "\"><svg x=\"" + -width / 2 + "\" y=\"" + -height / 2 + "\">" + src + "</svg></svg></g>";
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.tuiCheckFixedPosition = tuiCheckFixedPosition;
    exports.tuiGetSafeAreaSize = tuiGetSafeAreaSize;
    exports.tuiGetScreenWidth = tuiGetScreenWidth;
    exports.tuiGetViewportHeight = tuiGetViewportHeight;
    exports.tuiGetViewportWidth = tuiGetViewportWidth;
    exports.tuiGetWordRange = tuiGetWordRange;
    exports.tuiProcessIcon = tuiProcessIcon;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=taiga-ui-core-utils-dom.umd.js.map
