import { Inject, Injectable } from '@angular/core';
import { WINDOW } from '@ng-web-apis/common';
import { TUI_MEDIA } from '@taiga-ui/core/tokens';
import { fromEvent, merge, Observable } from 'rxjs';
import { map, shareReplay, startWith } from 'rxjs/operators';
import * as i0 from "@angular/core";
/**
 * Service to provide the current breakpoint based on Taiga UI's media queries
 */
export class TuiBreakpointService extends Observable {
    constructor(media, win) {
        const breakpoints = getBreakpoints(media);
        const events$ = breakpoints.map(({ query }) => fromEvent(win.matchMedia(query), `change`));
        const media$ = merge(...events$).pipe(map(() => currentBreakpoint(breakpoints, win.innerWidth).name), startWith(currentBreakpoint(breakpoints, win.innerWidth).name), shareReplay({ bufferSize: 1, refCount: true }));
        super(subscriber => media$.subscribe(subscriber));
    }
}
TuiBreakpointService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiBreakpointService, deps: [{ token: TUI_MEDIA }, { token: WINDOW }], target: i0.ɵɵFactoryTarget.Injectable });
TuiBreakpointService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiBreakpointService, providedIn: `root` });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiBreakpointService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: `root`,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_MEDIA]
                }] }, { type: Window, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }]; } });
function getBreakpoints(media) {
    return Object.entries(media).map(([name, width]) => ({
        name: name,
        /**
         * @note:
         * min-width query in css is inclusive, but in window.matchMedia it is exclusive
         * so we need to subtract 1px to get the same result
         */
        query: `(max-width: ${width - 1}px)`,
        width,
    }));
}
function currentBreakpoint(breakpoints, innerWidth) {
    var _a;
    return (_a = breakpoints.find(({ width }) => innerWidth < width)) !== null && _a !== void 0 ? _a : breakpoints.slice(-1)[0];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJlYWtwb2ludC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZS9zZXJ2aWNlcy9icmVha3BvaW50LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDakQsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBRTNDLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUNoRCxPQUFPLEVBQUMsU0FBUyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDbEQsT0FBTyxFQUFDLEdBQUcsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7O0FBVTNEOztHQUVHO0FBSUgsTUFBTSxPQUFPLG9CQUFxQixTQUFRLFVBQXdDO0lBQzlFLFlBQStCLEtBQWUsRUFBa0IsR0FBVztRQUN2RSxNQUFNLFdBQVcsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDMUMsTUFBTSxPQUFPLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUMsS0FBSyxFQUFDLEVBQUUsRUFBRSxDQUN4QyxTQUFTLENBQXNCLEdBQUcsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQ2xFLENBQUM7UUFDRixNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQ2pDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUM5RCxTQUFTLENBQUMsaUJBQWlCLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFDOUQsV0FBVyxDQUFDLEVBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FDL0MsQ0FBQztRQUVGLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUN0RCxDQUFDOztrSEFiUSxvQkFBb0Isa0JBQ1QsU0FBUyxhQUEyQixNQUFNO3NIQURyRCxvQkFBb0IsY0FGakIsTUFBTTs0RkFFVCxvQkFBb0I7a0JBSGhDLFVBQVU7bUJBQUM7b0JBQ1IsVUFBVSxFQUFFLE1BQU07aUJBQ3JCOzswQkFFZ0IsTUFBTTsyQkFBQyxTQUFTOzhCQUF3QyxNQUFNOzBCQUExQixNQUFNOzJCQUFDLE1BQU07O0FBZWxFLFNBQVMsY0FBYyxDQUFDLEtBQWU7SUFDbkMsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2pELElBQUksRUFBRSxJQUE2QjtRQUNuQzs7OztXQUlHO1FBQ0gsS0FBSyxFQUFFLGVBQWUsS0FBSyxHQUFHLENBQUMsS0FBSztRQUNwQyxLQUFLO0tBQ1IsQ0FBQyxDQUFDLENBQUM7QUFDUixDQUFDO0FBRUQsU0FBUyxpQkFBaUIsQ0FDdEIsV0FBNEIsRUFDNUIsVUFBa0I7O0lBRWxCLE9BQU8sTUFBQSxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBQyxLQUFLLEVBQUMsRUFBRSxFQUFFLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQyxtQ0FBSSxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDekYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0LCBJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7V0lORE9XfSBmcm9tICdAbmctd2ViLWFwaXMvY29tbW9uJztcbmltcG9ydCB7VHVpTWVkaWF9IGZyb20gJ0B0YWlnYS11aS9jb3JlL2ludGVyZmFjZXMnO1xuaW1wb3J0IHtUVUlfTUVESUF9IGZyb20gJ0B0YWlnYS11aS9jb3JlL3Rva2Vucyc7XG5pbXBvcnQge2Zyb21FdmVudCwgbWVyZ2UsIE9ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHttYXAsIHNoYXJlUmVwbGF5LCBzdGFydFdpdGh9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZXhwb3J0IHR5cGUgVHVpQnJlYWtwb2ludE1lZGlhS2V5ID0ga2V5b2YgT21pdDxUdWlNZWRpYSwgJ3RhYmxldCc+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFR1aUJyZWFrcG9pbnQge1xuICAgIG5hbWU6IFR1aUJyZWFrcG9pbnRNZWRpYUtleTtcbiAgICBxdWVyeTogc3RyaW5nO1xuICAgIHdpZHRoOiBudW1iZXI7XG59XG5cbi8qKlxuICogU2VydmljZSB0byBwcm92aWRlIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgYmFzZWQgb24gVGFpZ2EgVUkncyBtZWRpYSBxdWVyaWVzXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiBgcm9vdGAsXG59KVxuZXhwb3J0IGNsYXNzIFR1aUJyZWFrcG9pbnRTZXJ2aWNlIGV4dGVuZHMgT2JzZXJ2YWJsZTxUdWlCcmVha3BvaW50TWVkaWFLZXkgfCBudWxsPiB7XG4gICAgY29uc3RydWN0b3IoQEluamVjdChUVUlfTUVESUEpIG1lZGlhOiBUdWlNZWRpYSwgQEluamVjdChXSU5ET1cpIHdpbjogV2luZG93KSB7XG4gICAgICAgIGNvbnN0IGJyZWFrcG9pbnRzID0gZ2V0QnJlYWtwb2ludHMobWVkaWEpO1xuICAgICAgICBjb25zdCBldmVudHMkID0gYnJlYWtwb2ludHMubWFwKCh7cXVlcnl9KSA9PlxuICAgICAgICAgICAgZnJvbUV2ZW50PE1lZGlhUXVlcnlMaXN0RXZlbnQ+KHdpbi5tYXRjaE1lZGlhKHF1ZXJ5KSwgYGNoYW5nZWApLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBtZWRpYSQgPSBtZXJnZSguLi5ldmVudHMkKS5waXBlKFxuICAgICAgICAgICAgbWFwKCgpID0+IGN1cnJlbnRCcmVha3BvaW50KGJyZWFrcG9pbnRzLCB3aW4uaW5uZXJXaWR0aCkubmFtZSksXG4gICAgICAgICAgICBzdGFydFdpdGgoY3VycmVudEJyZWFrcG9pbnQoYnJlYWtwb2ludHMsIHdpbi5pbm5lcldpZHRoKS5uYW1lKSxcbiAgICAgICAgICAgIHNoYXJlUmVwbGF5KHtidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZX0pLFxuICAgICAgICApO1xuXG4gICAgICAgIHN1cGVyKHN1YnNjcmliZXIgPT4gbWVkaWEkLnN1YnNjcmliZShzdWJzY3JpYmVyKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRCcmVha3BvaW50cyhtZWRpYTogVHVpTWVkaWEpOiBUdWlCcmVha3BvaW50W10ge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhtZWRpYSkubWFwKChbbmFtZSwgd2lkdGhdKSA9PiAoe1xuICAgICAgICBuYW1lOiBuYW1lIGFzIFR1aUJyZWFrcG9pbnRNZWRpYUtleSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBub3RlOlxuICAgICAgICAgKiBtaW4td2lkdGggcXVlcnkgaW4gY3NzIGlzIGluY2x1c2l2ZSwgYnV0IGluIHdpbmRvdy5tYXRjaE1lZGlhIGl0IGlzIGV4Y2x1c2l2ZVxuICAgICAgICAgKiBzbyB3ZSBuZWVkIHRvIHN1YnRyYWN0IDFweCB0byBnZXQgdGhlIHNhbWUgcmVzdWx0XG4gICAgICAgICAqL1xuICAgICAgICBxdWVyeTogYChtYXgtd2lkdGg6ICR7d2lkdGggLSAxfXB4KWAsXG4gICAgICAgIHdpZHRoLFxuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gY3VycmVudEJyZWFrcG9pbnQoXG4gICAgYnJlYWtwb2ludHM6IFR1aUJyZWFrcG9pbnRbXSxcbiAgICBpbm5lcldpZHRoOiBudW1iZXIsXG4pOiBUdWlCcmVha3BvaW50IHtcbiAgICByZXR1cm4gYnJlYWtwb2ludHMuZmluZCgoe3dpZHRofSkgPT4gaW5uZXJXaWR0aCA8IHdpZHRoKSA/PyBicmVha3BvaW50cy5zbGljZSgtMSlbMF07XG59XG4iXX0=