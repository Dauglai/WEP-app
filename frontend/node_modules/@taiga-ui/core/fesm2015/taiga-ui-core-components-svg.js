import { __decorate } from 'tslib';
import * as i2 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { InjectionToken, inject, SkipSelf, Optional, SecurityContext, ElementRef, Component, ChangeDetectionStrategy, Inject, Input, NgModule } from '@angular/core';
import * as i4 from '@angular/platform-browser';
import { DomSanitizer } from '@angular/platform-browser';
import { WINDOW } from '@ng-web-apis/common';
import * as i1 from '@taiga-ui/cdk';
import { tuiSvgLinearGradientProcessor, tuiIsString, tuiAssert, tuiGetDocumentOrShadowRoot, TuiStaticRequestService, tuiRequiredSetter, tuiPure, TuiLetModule } from '@taiga-ui/cdk';
import { TUI_CACHE_BUSTING_PAYLOAD, TUI_ICON_ERROR } from '@taiga-ui/core/constants';
import * as i3 from '@taiga-ui/core/services';
import { TuiSvgService } from '@taiga-ui/core/services';
import { TUI_ICONS_PATH, TUI_SVG_SRC_PROCESSOR, TUI_SVG_CONTENT_PROCESSOR, TUI_SANITIZER } from '@taiga-ui/core/tokens';
import { tuiIsPresumedHTMLString } from '@taiga-ui/core/utils/miscellaneous';
import { identity, ReplaySubject, of } from 'rxjs';
import { switchMap, startWith, catchError, map } from 'rxjs/operators';
import { tuiIconsPathFactory } from '@taiga-ui/core/utils';

const TUI_DEPRECATED_ICONS = {
    tuiIconAttach: `tuiIconPaperclip`,
    tuiIconAttention: `tuiIconAlertCircle`,
    tuiIconBackCircle: `tuiIconArrowLeftCircle`,
    tuiIconCall: `tuiIconPhone`,
    tuiIconCallIn: `tuiIconPhoneIncoming`,
    tuiIconCallOut: `tuiIconPhoneOutgoing`,
    tuiIconCallTransfer: `tuiIconPhoneForwarded`,
    tuiIconCancel: `tuiIconXCircle`,
    tuiIconCancelCircle: `tuiIconSlash`,
    tuiIconCard: `tuiIconCreditCard`,
    tuiIconCards: `tuiIconCreditCard`,
    tuiIconChartBar: `tuiIconBarChart`,
    tuiIconChart: `tuiIconBarChart`,
    tuiIconCheckList: `tuiIconClipboard`,
    tuiIconCloseCircle: `tuiIconXCircle`,
    tuiIconCollapse: `tuiIconMinimize`,
    tuiIconComment: `tuiIconMessageSquare`,
    tuiIconCommentFw: `tuiIconMessageForward`,
    tuiIconCompany: `tuiIconBriefcase`,
    tuiIconDefaultDoc: `tuiIconFile`,
    tuiIconDesktop: `tuiIconMonitor`,
    tuiIconDesktopOff: `tuiIconMonitorOff`,
    tuiIconDislike: `tuiIconThumbsDown`,
    tuiIconDone: `tuiIconCheckCircle`,
    tuiIconDraft: `tuiIconEdit2`,
    tuiIconEyeOpen: `tuiIconEye`,
    tuiIconEyeClosed: `tuiIconEyeOff`,
    tuiIconExpand: `tuiIconMaximize`,
    tuiIconExternal: `tuiIconExternalLink`,
    tuiIconFrame: `tuiIconLayout`,
    tuiIconGeo: `tuiIconMapPin`,
    tuiIconHeartFilled: `tuiIconHeart`,
    tuiIconHide: `tuiIconEyeOff`,
    tuiIconImg: `tuiIconImage`,
    tuiIconInfoCircle: `tuiIconInfo`,
    tuiIconLike: `tuiIconThumbsUp`,
    tuiIconLockOpen: `tuiIconUnlock`,
    tuiIconMobile: `tuiIconSmartphone`,
    tuiIconMoreHor: `tuiIconMoreHorizontal`,
    tuiIconMoreVer: `tuiIconMoreVertical`,
    tuiIconMoreVert: `tuiIconMoreVertical`,
    tuiIconPicture: `tuiIconImage`,
    tuiIconPin: `tuiIconMapPin`,
    tuiIconPrint: `tuiIconPrinter`,
    tuiIconRefresh: `tuiIconRefreshCw`,
    tuiIconRemove: `tuiIconX`,
    tuiIconShow: `tuiIconEye`,
    tuiIconSound: `tuiIconVolume`,
    tuiIconSoundOff: `tuiIconVolumeX`,
    tuiIconStarFilled: `tuiIconStar`,
    tuiIconStop: `tuiIconSquare`,
    tuiIconStructure: `tuiIconGrid`,
    tuiIconTime: `tuiIconClock`,
    tuiIconTooltip: `tuiIconHelpCircle`,
    tuiIconViewList: `tuiIconList`,
    tuiIconWifiOn: `tuiIconWifi`,
};

const TUI_SVG_DEFAULT_OPTIONS = {
    path: tuiIconsPathFactory(`assets/taiga-ui/icons`),
    srcProcessor: identity,
    contentProcessor: tuiSvgLinearGradientProcessor,
    deprecated: src => {
        const oldIcon = src.replace(`Large`, ``).replace(`Outline`, ``);
        const newIcon = TUI_DEPRECATED_ICONS[oldIcon];
        return newIcon
            ? `${oldIcon}/(Large|Outline) is deprecated, use ${newIcon}/(Large|Outline) instead`
            : ``;
    },
};
/**
 * SVG component options
 */
const TUI_SVG_OPTIONS = new InjectionToken(`[TUI_SVG_OPTIONS]`, {
    factory: () => ({
        path: inject(TUI_ICONS_PATH),
        deprecated: TUI_SVG_DEFAULT_OPTIONS.deprecated,
        srcProcessor: inject(TUI_SVG_SRC_PROCESSOR),
        contentProcessor: inject(TUI_SVG_CONTENT_PROCESSOR),
    }),
});
const tuiSvgOptionsProvider = options => ({
    provide: TUI_SVG_OPTIONS,
    deps: [[new SkipSelf(), new Optional(), TUI_SVG_OPTIONS]],
    useFactory: (fallback) => (Object.assign(Object.assign(Object.assign({}, (fallback || TUI_SVG_DEFAULT_OPTIONS)), options), { path: tuiIsString(options.path)
            ? tuiIconsPathFactory(options.path)
            : options.path || (fallback === null || fallback === void 0 ? void 0 : fallback.path) || TUI_SVG_DEFAULT_OPTIONS.path })),
});

const UNDEFINED_NAMED_ICON = 'Attempted to use undefined named icon';
const MISSING_EXTERNAL_ICON = 'External icon is missing on the given URL';
const FAILED_EXTERNAL_ICON = 'Failed to load external SVG';
// TODO: Consider moving to CDK along with SvgService and SvgDefsHostComponent
class TuiSvgComponent {
    constructor(doc, win, options, tuiSanitizer, svgService, staticRequestService, sanitizer, el) {
        this.doc = doc;
        this.win = win;
        this.options = options;
        this.tuiSanitizer = tuiSanitizer;
        this.svgService = svgService;
        this.staticRequestService = staticRequestService;
        this.sanitizer = sanitizer;
        this.el = el;
        this.src$ = new ReplaySubject(1);
        this.icon = '';
        this.innerHTML$ = this.src$.pipe(switchMap(() => {
            if (tuiIsString(this.icon)) {
                return this.isExternal
                    ? this.getExternalIcon(this.icon)
                    : of(this.getSafeHtml(this.icon));
            }
            return of(this.icon);
        }), startWith(''));
    }
    set src(src) {
        const deprecated = this.options.deprecated(String(src));
        ngDevMode && tuiAssert.assert(!deprecated, deprecated);
        this.icon = this.options.srcProcessor(src);
        this.src$.next();
    }
    get src() {
        return this.icon;
    }
    get use() {
        if (tuiIsString(this.icon)) {
            return this.icon.includes('.svg#')
                ? this.icon
                : this.resolveName(this.icon, this.options.path);
        }
        return '';
    }
    get isInnerHTML() {
        return (!tuiIsString(this.icon) ||
            this.isSrc ||
            this.isExternal ||
            (this.isName && this.isShadowDOM));
    }
    get isShadowDOM() {
        return tuiGetDocumentOrShadowRoot(this.el.nativeElement) !== this.doc;
    }
    get isUse() {
        return this.use.replace(TUI_CACHE_BUSTING_PAYLOAD, '').includes('.svg#');
    }
    get isExternal() {
        return this.isUrl || this.isCrossDomain;
    }
    get isUrl() {
        return tuiIsString(this.icon) && this.icon.endsWith('.svg');
    }
    get isSrc() {
        return tuiIsString(this.icon) && tuiIsPresumedHTMLString(this.icon);
    }
    get isName() {
        return !this.isUrl && !this.isUse && !this.isSrc;
    }
    get isCrossDomain() {
        const { use, isUse, win } = this;
        return (isUse && use.startsWith('http') && !!win.origin && !use.startsWith(win.origin));
    }
    onError(message = MISSING_EXTERNAL_ICON) {
        const { icon } = this;
        const event = new CustomEvent(TUI_ICON_ERROR, {
            bubbles: true,
            detail: {
                message,
                icon: icon,
            },
        });
        ngDevMode && tuiAssert.assert(false, message, icon);
        this.el.nativeElement.dispatchEvent(event);
    }
    resolveName(name, iconsPath) {
        return iconsPath(name);
    }
    getSafeHtml(src) {
        return this.isSrc ? this.sanitize(src) : this.process(src);
    }
    process(src) {
        const icon = this.svgService.getOriginal(src);
        if (this.isName && !icon && !!src) {
            this.onError(UNDEFINED_NAMED_ICON);
        }
        // Empty line for innerHTML when icon is shown through USE tag
        return !this.isShadowDOM || !this.isName ? '' : this.sanitize(icon || '');
    }
    sanitize(src) {
        src = this.options.contentProcessor(src);
        return this.tuiSanitizer && tuiIsString(src)
            ? this.sanitizer.bypassSecurityTrustHtml(this.tuiSanitizer.sanitize(SecurityContext.HTML, src) || '')
            : src;
    }
    getExternalIcon(src) {
        const url = src.includes('.svg') ? src : this.use;
        return this.staticRequestService.request(url).pipe(catchError(() => {
            this.onError(FAILED_EXTERNAL_ICON);
            return of('');
        }), map(response => this.sanitize(response.replace('<svg', '<svg focusable="false"'))));
    }
}
TuiSvgComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSvgComponent, deps: [{ token: DOCUMENT }, { token: WINDOW }, { token: TUI_SVG_OPTIONS }, { token: TUI_SANITIZER, optional: true }, { token: TuiSvgService }, { token: TuiStaticRequestService }, { token: DomSanitizer }, { token: ElementRef }], target: i0.ɵɵFactoryTarget.Component });
TuiSvgComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: TuiSvgComponent, selector: "tui-svg", inputs: { src: "src" }, ngImport: i0, template: "<ng-container *tuiLet=\"innerHTML$ | async as innerHTML\">\n    <div\n        *ngIf=\"isInnerHTML; else useTemplate\"\n        class=\"t-src\"\n        [innerHTML]=\"innerHTML\"\n    ></div>\n    <ng-template #useTemplate>\n        <svg\n            version=\"1.1\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n            focusable=\"false\"\n            width=\"100%\"\n            height=\"100%\"\n            class=\"t-svg\"\n            (error)=\"onError()\"\n        >\n            <use [attr.xlink:href]=\"use\"></use>\n        </svg>\n    </ng-template>\n</ng-container>\n", styles: [":host{display:inline-flex;vertical-align:middle;flex-shrink:0;align-items:center;justify-content:center;line-height:0;height:1.5rem;width:1.5rem;fill:transparent;stroke:transparent;font-size:1rem}.t-src{display:flex;width:100%;height:100%;align-items:center;justify-content:center}.t-svg{overflow:visible}\n"], directives: [{ type: i1.TuiLetDirective, selector: "[tuiLet]", inputs: ["tuiLet"] }, { type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i2.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
__decorate([
    tuiRequiredSetter()
], TuiSvgComponent.prototype, "src", null);
__decorate([
    tuiPure
], TuiSvgComponent.prototype, "resolveName", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSvgComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'tui-svg',
                    templateUrl: './svg.template.html',
                    styleUrls: ['./svg.style.less'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: Window, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_SVG_OPTIONS]
                }] }, { type: i0.Sanitizer, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TUI_SANITIZER]
                }] }, { type: i3.TuiSvgService, decorators: [{
                    type: Inject,
                    args: [TuiSvgService]
                }] }, { type: i1.TuiStaticRequestService, decorators: [{
                    type: Inject,
                    args: [TuiStaticRequestService]
                }] }, { type: i4.DomSanitizer, decorators: [{
                    type: Inject,
                    args: [DomSanitizer]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }]; }, propDecorators: { src: [{
                type: Input
            }], resolveName: [] } });

class TuiSvgModule {
}
TuiSvgModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSvgModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TuiSvgModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSvgModule, declarations: [TuiSvgComponent], imports: [CommonModule, TuiLetModule], exports: [TuiSvgComponent] });
TuiSvgModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSvgModule, imports: [[CommonModule, TuiLetModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSvgModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, TuiLetModule],
                    declarations: [TuiSvgComponent],
                    exports: [TuiSvgComponent],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { TUI_DEPRECATED_ICONS, TUI_SVG_DEFAULT_OPTIONS, TUI_SVG_OPTIONS, TuiSvgComponent, TuiSvgModule, tuiSvgOptionsProvider };
//# sourceMappingURL=taiga-ui-core-components-svg.js.map
