import * as i0 from '@angular/core';
import { Injectable, Inject, LOCALE_ID, ElementRef, NgZone, Optional, Self, SecurityContext } from '@angular/core';
import { WINDOW, ANIMATION_FRAME } from '@ng-web-apis/common';
import { TUI_MEDIA, TUI_SANITIZER, TUI_ICONS } from '@taiga-ui/core/tokens';
import * as i1 from 'rxjs';
import { Observable, fromEvent, merge, of, BehaviorSubject, timer, EMPTY } from 'rxjs';
import { map, startWith, shareReplay, share, distinctUntilChanged, takeUntil } from 'rxjs/operators';
import * as i3 from '@taiga-ui/cdk';
import { tuiZonefree, tuiZoneOptimized, TuiDestroyService, tuiAssert, TUI_IS_WEBKIT } from '@taiga-ui/cdk';
import * as i2 from '@taiga-ui/core/abstract';
import { TuiPositionAccessor } from '@taiga-ui/core/abstract';
import * as i1$1 from '@angular/router';
import { RouterLinkActive } from '@angular/router';
import * as i1$2 from '@angular/platform-browser';
import { DomSanitizer } from '@angular/platform-browser';
import { tuiProcessIcon } from '@taiga-ui/core/utils/dom';

/**
 * Service to provide the current breakpoint based on Taiga UI's media queries
 */
class TuiBreakpointService extends Observable {
    constructor(media, win) {
        const breakpoints = getBreakpoints(media);
        const events$ = breakpoints.map(({ query }) => fromEvent(win.matchMedia(query), `change`));
        const media$ = merge(...events$).pipe(map(() => currentBreakpoint(breakpoints, win.innerWidth).name), startWith(currentBreakpoint(breakpoints, win.innerWidth).name), shareReplay({ bufferSize: 1, refCount: true }));
        super(subscriber => media$.subscribe(subscriber));
    }
}
TuiBreakpointService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiBreakpointService, deps: [{ token: TUI_MEDIA }, { token: WINDOW }], target: i0.ɵɵFactoryTarget.Injectable });
TuiBreakpointService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiBreakpointService, providedIn: `root` });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiBreakpointService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: `root`,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_MEDIA]
                }] }, { type: Window, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }]; } });
function getBreakpoints(media) {
    return Object.entries(media).map(([name, width]) => ({
        name: name,
        /**
         * @note:
         * min-width query in css is inclusive, but in window.matchMedia it is exclusive
         * so we need to subtract 1px to get the same result
         */
        query: `(max-width: ${width - 1}px)`,
        width,
    }));
}
function currentBreakpoint(breakpoints, innerWidth) {
    var _a;
    return (_a = breakpoints.find(({ width }) => innerWidth < width)) !== null && _a !== void 0 ? _a : breakpoints.slice(-1)[0];
}

class TuiFormatDateService {
    constructor(locale) {
        this.locale = locale;
    }
    format(timestamp) {
        return of(new Date(timestamp).toLocaleTimeString(this.locale, {
            hour: `numeric`,
            minute: `2-digit`,
        }));
    }
}
TuiFormatDateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiFormatDateService, deps: [{ token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Injectable });
TuiFormatDateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiFormatDateService, providedIn: `root` });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiFormatDateService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: `root`,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; } });

/**
 * Service for displaying hints/tooltips
 */
class TuiHintService extends BehaviorSubject {
    constructor() {
        super([]);
    }
    add(directive) {
        this.next(this.value.concat(directive));
    }
    remove(directive) {
        if (this.value.includes(directive)) {
            this.next(this.value.filter(hint => hint !== directive));
        }
    }
}
TuiHintService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiHintService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
TuiHintService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiHintService, providedIn: `root` });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiHintService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: `root`,
                }]
        }], ctorParameters: function () { return []; } });

class TuiNightThemeService extends Observable {
    constructor(win) {
        const media = win.matchMedia(`(prefers-color-scheme: dark)`);
        const media$ = fromEvent(media, `change`).pipe(startWith(null), map(() => media.matches), share());
        super(subscriber => media$.subscribe(subscriber));
    }
}
TuiNightThemeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiNightThemeService, deps: [{ token: WINDOW }], target: i0.ɵɵFactoryTarget.Injectable });
TuiNightThemeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiNightThemeService, providedIn: `root` });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiNightThemeService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: `root`,
                }]
        }], ctorParameters: function () { return [{ type: Window, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }]; } });

class TuiPositionService extends Observable {
    constructor({ nativeElement }, animationFrame, ngZone, accessor) {
        super(subscriber => animationFrame
            .pipe(map(() => nativeElement.getBoundingClientRect()), map(rect => accessor.getPosition(rect)), tuiZonefree(ngZone))
            .subscribe(subscriber));
    }
}
TuiPositionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiPositionService, deps: [{ token: ElementRef }, { token: ANIMATION_FRAME }, { token: NgZone }, { token: TuiPositionAccessor }], target: i0.ɵɵFactoryTarget.Injectable });
TuiPositionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiPositionService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiPositionService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i1.Observable, decorators: [{
                    type: Inject,
                    args: [ANIMATION_FRAME]
                }] }, { type: i0.NgZone, decorators: [{
                    type: Inject,
                    args: [NgZone]
                }] }, { type: i2.TuiPositionAccessor, decorators: [{
                    type: Inject,
                    args: [TuiPositionAccessor]
                }] }]; } });

// TODO: Remove when Angular is update and `RouterLinkActive` has output
class TuiRouterLinkActiveService extends Observable {
    constructor(routerLinkActive, ngZone, animationFrame$, destroy$) {
        const stream$ = routerLinkActive
            ? merge(timer(0), // SSR (animationFrame$ never emits value during SSR)
            animationFrame$).pipe(map(() => routerLinkActive.isActive), distinctUntilChanged(), tuiZoneOptimized(ngZone), takeUntil(destroy$))
            : EMPTY;
        super(subscriber => stream$.subscribe(subscriber));
    }
}
TuiRouterLinkActiveService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiRouterLinkActiveService, deps: [{ token: RouterLinkActive, optional: true }, { token: NgZone }, { token: ANIMATION_FRAME }, { token: TuiDestroyService, self: true }], target: i0.ɵɵFactoryTarget.Injectable });
TuiRouterLinkActiveService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiRouterLinkActiveService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiRouterLinkActiveService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.RouterLinkActive, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [RouterLinkActive]
                }] }, { type: i0.NgZone, decorators: [{
                    type: Inject,
                    args: [NgZone]
                }] }, { type: i1.Observable, decorators: [{
                    type: Inject,
                    args: [ANIMATION_FRAME]
                }] }, { type: i3.TuiDestroyService, decorators: [{
                    type: Self
                }, {
                    type: Inject,
                    args: [TuiDestroyService]
                }] }]; } });

/**
 * Service for reusing SVGs without inlining each instance
 */
class TuiSvgService {
    constructor(tuiSanitizer, sanitizer, icons) {
        this.tuiSanitizer = tuiSanitizer;
        this.sanitizer = sanitizer;
        this.originals = {};
        this.items$ = new BehaviorSubject(new Map());
        this.define(icons);
    }
    define(icons) {
        const { value } = this.items$;
        Object.keys(icons).forEach(key => {
            this.defineIcon(key, icons[key], value);
        });
        this.items$.next(value);
    }
    getOriginal(name) {
        return this.originals[name] || null;
    }
    defineIcon(name, src, map) {
        if (map.has(name)) {
            return;
        }
        const parsed = this.parseSrc(name, src);
        if (!parsed) {
            ngDevMode && tuiAssert.assert(false, `Unable to parse given SVG src`);
            return;
        }
        map.set(name, parsed);
        this.originals = Object.assign(Object.assign({}, this.originals), { [name]: src });
    }
    parseSrc(name, src) {
        return this.sanitize(tuiProcessIcon(src, name));
    }
    sanitize(src) {
        return this.sanitizer.bypassSecurityTrustHtml((this.tuiSanitizer
            ? this.tuiSanitizer.sanitize(SecurityContext.HTML, src)
            : this.sanitizer.sanitize(SecurityContext.HTML, src)) || ``);
    }
}
TuiSvgService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSvgService, deps: [{ token: TUI_SANITIZER, optional: true }, { token: DomSanitizer }, { token: TUI_ICONS }], target: i0.ɵɵFactoryTarget.Injectable });
TuiSvgService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSvgService, providedIn: `root` });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSvgService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: `root`,
                }]
        }], ctorParameters: function () { return [{ type: i0.Sanitizer, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TUI_SANITIZER]
                }] }, { type: i1$2.DomSanitizer, decorators: [{
                    type: Inject,
                    args: [DomSanitizer]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_ICONS]
                }] }]; } });

class TuiVisualViewportService {
    constructor(win, isWebkit) {
        this.win = win;
        this.isWebkit = isWebkit;
    }
    // https://bugs.webkit.org/show_bug.cgi?id=207089
    correct(point) {
        var _a, _b, _c, _d;
        return this.isWebkit
            ? [
                point[0] + ((_b = (_a = this.win.visualViewport) === null || _a === void 0 ? void 0 : _a.offsetTop) !== null && _b !== void 0 ? _b : 0),
                point[1] + ((_d = (_c = this.win.visualViewport) === null || _c === void 0 ? void 0 : _c.offsetLeft) !== null && _d !== void 0 ? _d : 0),
            ]
            : point;
    }
}
TuiVisualViewportService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiVisualViewportService, deps: [{ token: WINDOW }, { token: TUI_IS_WEBKIT }], target: i0.ɵɵFactoryTarget.Injectable });
TuiVisualViewportService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiVisualViewportService, providedIn: `root` });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiVisualViewportService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: `root`,
                }]
        }], ctorParameters: function () { return [{ type: Window, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_IS_WEBKIT]
                }] }]; } });

/**
 * Generated bundle index. Do not edit.
 */

export { TuiBreakpointService, TuiFormatDateService, TuiHintService, TuiNightThemeService, TuiPositionService, TuiRouterLinkActiveService, TuiSvgService, TuiVisualViewportService };
//# sourceMappingURL=taiga-ui-core-services.js.map
