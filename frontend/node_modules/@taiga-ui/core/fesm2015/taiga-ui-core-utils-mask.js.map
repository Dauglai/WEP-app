{"version":3,"file":"taiga-ui-core-utils-mask.js","sources":["../../../projects/core/utils/mask/create-auto-corrected-money-pipe.ts","../../../projects/core/utils/mask/create-correction-mask.ts","../../../projects/core/utils/mask/create-number-mask.ts","../../../projects/core/utils/mask/enable-auto-correct-decimal-symbol.ts","../../../projects/core/utils/mask/masked-money-value-is-empty.ts","../../../projects/core/utils/mask/masked-number-string-to-number.ts","../../../projects/core/utils/mask/taiga-ui-core-utils-mask.ts"],"sourcesContent":["import {\n    CHAR_HYPHEN,\n    CHAR_NO_BREAK_SPACE,\n    tuiAssert,\n    tuiGetDocumentOrShadowRoot,\n    tuiIsNativeFocused,\n    tuiIsSafari,\n} from '@taiga-ui/cdk';\nimport {TuiTextMaskPipeHandler} from '@taiga-ui/core/mask';\nimport {TuiDecimalSymbol} from '@taiga-ui/core/types';\n\n/**\n * Used to finish a number with zeros to a given precision\n */\nexport function tuiCreateAutoCorrectedNumberPipe(\n    decimalLimit: number = 0,\n    decimalSymbol: TuiDecimalSymbol = `,`,\n    thousandSymbol: string = CHAR_NO_BREAK_SPACE,\n    nativeInput?: HTMLInputElement | null,\n    allowNegative?: boolean,\n    isIOS = false,\n): TuiTextMaskPipeHandler {\n    ngDevMode && tuiAssert.assert(decimalLimit >= 0);\n\n    // Guess for which browser I need this :)\n    let previousCaret = -1;\n    const unlucky = (!!nativeInput && tuiIsSafari(nativeInput)) || isIOS;\n\n    if (nativeInput && unlucky) {\n        nativeInput.addEventListener(`beforeinput`, () => {\n            previousCaret = nativeInput.selectionStart || 0;\n        });\n    }\n\n    return (conformedValue, config) => {\n        // Removing everything by selecting and pressing '-'\n        if (!conformedValue && config.rawValue === CHAR_HYPHEN && allowNegative) {\n            return CHAR_HYPHEN;\n        }\n\n        // remove these hacks after text mask library has changed\n        if (nativeInput && unlucky && tuiIsNativeFocused(nativeInput)) {\n            const caret = calculateSafariCaret(\n                config.previousConformedValue,\n                conformedValue,\n                previousCaret,\n            );\n\n            setTimeout(() => {\n                nativeInput.setSelectionRange(caret, caret);\n            });\n        }\n\n        if (\n            nativeInput &&\n            nativeInput.ownerDocument !== tuiGetDocumentOrShadowRoot(nativeInput) &&\n            tuiIsNativeFocused(nativeInput) &&\n            config.currentCaretPosition\n        ) {\n            const realCaretPosition =\n                config.currentCaretPosition +\n                calculateCaretGap(\n                    config.previousConformedValue,\n                    conformedValue,\n                    thousandSymbol,\n                );\n\n            setTimeout(() => {\n                nativeInput.setSelectionRange(realCaretPosition, realCaretPosition);\n            });\n        }\n\n        if (conformedValue === `` || !decimalLimit || !Number.isInteger(decimalLimit)) {\n            return {value: conformedValue};\n        }\n\n        const withDecimalSymbol = addDecimalSymbolIfNeeded(conformedValue, decimalSymbol);\n        const decimalPart = withDecimalSymbol.split(decimalSymbol)[1];\n        const zeroPaddingSize = decimalLimit - decimalPart.length;\n\n        return {\n            value: withDecimalSymbol + `0`.repeat(zeroPaddingSize),\n        };\n    };\n}\n\nfunction addDecimalSymbolIfNeeded(\n    value: string,\n    decimalSymbol: TuiDecimalSymbol = `,`,\n): string {\n    return !value.includes(decimalSymbol) ? value + decimalSymbol : value;\n}\n\nfunction calculateSafariCaret(\n    previousValue: string = ``,\n    current: string,\n    previousCaret: number,\n    decimalSymbol: string = `,`,\n): number {\n    const tailRegex = new RegExp(`${decimalSymbol}.+`);\n    const previousWithoutTail = previousValue.replace(tailRegex, ``);\n    const currentWithoutTail = current.replace(tailRegex, ``);\n\n    const pasteOrCutOperation =\n        Math.abs(previousWithoutTail.length - currentWithoutTail.length) > 2;\n\n    if (pasteOrCutOperation) {\n        return current.length;\n    }\n\n    if (previousValue.length === current.length) {\n        if (previousValue.indexOf(decimalSymbol) <= previousCaret) {\n            return calculateChangedTailIndex(previousValue, current);\n        }\n\n        return previousWithoutTail === currentWithoutTail\n            ? previousCaret - 1\n            : previousCaret + 1;\n    }\n\n    if (previousValue.length === 0) {\n        return 1;\n    }\n\n    const changeLength = current.length - previousValue.length;\n\n    return previousCaret + changeLength;\n}\n\nfunction calculateChangedTailIndex(previous: string, current: string): number {\n    for (let i = 0; i < current.length; i++) {\n        if (previous[i] !== current[i]) {\n            return current[i] === `0` ? i : i + 1;\n        }\n    }\n\n    return current.length;\n}\n\nfunction calculateCaretGap(\n    previousValue: string = ``,\n    current: string,\n    thousandSymbol: string,\n): number {\n    const pasteOrCutOperation = Math.abs(previousValue.length - current.length) > 2;\n\n    if (pasteOrCutOperation) {\n        return 0;\n    }\n\n    const wereSpaces = previousValue.split(thousandSymbol).length;\n    const nowSpaces = current.split(thousandSymbol).length;\n\n    return nowSpaces - wereSpaces;\n}\n","import {tuiAssert} from '@taiga-ui/cdk';\nimport {MASK_CARET_TRAP} from '@taiga-ui/core/constants';\nimport {\n    TuiTextMaskCorrectionHandler,\n    TuiTextMaskList,\n    TuiTextMaskListHandler,\n} from '@taiga-ui/core/mask';\n\nconst ASSERTION = `Correction function must return single char or null`;\n\nexport function tuiCreateCorrectionMask(\n    allowed: RegExp,\n    correctionHandler: TuiTextMaskCorrectionHandler,\n): TuiTextMaskListHandler {\n    return rawValue => {\n        const mask = rawValue.split(``).reduce<TuiTextMaskList>((result, char, index) => {\n            const corrected = correctionHandler(char, index);\n\n            ngDevMode &&\n                tuiAssert.assert(corrected === null || corrected.length === 1, ASSERTION);\n\n            if (!allowed.test(char) && !corrected) {\n                return result;\n            }\n\n            if (allowed.test(char)) {\n                return [...result, allowed];\n            }\n\n            if (corrected) {\n                return [...result, corrected, MASK_CARET_TRAP];\n            }\n\n            return result;\n        }, []);\n        const lastIndex = mask.lastIndexOf(MASK_CARET_TRAP);\n        const filtered = mask.filter(\n            (item, index) => item !== MASK_CARET_TRAP || index === lastIndex,\n        );\n\n        return filtered.some(item => item !== allowed)\n            ? [...filtered, allowed]\n            : filtered;\n    };\n}\n","import {CHAR_EN_DASH, CHAR_HYPHEN, CHAR_NO_BREAK_SPACE, tuiAssert} from '@taiga-ui/cdk';\nimport {\n    MASK_CARET_TRAP,\n    TUI_DIGIT_REGEXP,\n    TUI_LEADING_ZEROES_REGEXP,\n    TUI_NON_DIGITS_REGEXP,\n} from '@taiga-ui/core/constants';\nimport {TuiNumberMaskOptions, TuiTextMaskListHandler} from '@taiga-ui/core/mask';\nimport {TuiDecimalSymbol} from '@taiga-ui/core/types';\nimport {tuiOtherDecimalSymbol} from '@taiga-ui/core/utils/format';\n\nconst NON_ZERO_DIGIT = /[1-9]/;\n\n/**\n * Adaptation for {@link https://github.com/text-mask/text-mask/tree/master/addons#createnumbermask `createNumberMask`}\n */\nexport function tuiCreateNumberMask({\n    allowDecimal = false,\n    decimalSymbol = `,`,\n    thousandSymbol = CHAR_NO_BREAK_SPACE,\n    autoCorrectDecimalSymbol = true,\n    decimalLimit = 2,\n    requireDecimal = false,\n    allowNegative = false,\n    integerLimit = 0,\n}: TuiNumberMaskOptions = {}): TuiTextMaskListHandler {\n    ngDevMode && tuiAssert.assert(decimalLimit >= 0);\n    ngDevMode && tuiAssert.assert(Number.isInteger(integerLimit));\n    ngDevMode && tuiAssert.assert(integerLimit >= 0);\n\n    // eslint-disable-next-line max-statements\n    return (rawValue, {previousConformedValue}) => {\n        if (previousConformedValue && requireDecimal) {\n            const conformedWithoutSeparator = rawValue.split(thousandSymbol).join(``);\n            const previousConformedValueWithoutDecimalSymbolAndSeparator =\n                previousConformedValue\n                    .split(thousandSymbol)\n                    .join(``)\n                    .split(decimalSymbol)\n                    .join(``);\n\n            // Forbid removal of decimal separator if decimal part is required\n            if (\n                conformedWithoutSeparator ===\n                previousConformedValueWithoutDecimalSymbolAndSeparator\n            ) {\n                rawValue = previousConformedValue;\n            }\n        }\n\n        const isNegative =\n            (rawValue?.startsWith(CHAR_HYPHEN) || rawValue?.startsWith(CHAR_EN_DASH)) &&\n            allowNegative;\n\n        if (\n            isDecimalSymbol(rawValue, decimalSymbol, autoCorrectDecimalSymbol) &&\n            allowDecimal\n        ) {\n            return [`0`, decimalSymbol, TUI_DIGIT_REGEXP];\n        }\n\n        if (isNegative) {\n            rawValue = rawValue.slice(1);\n        }\n\n        const decimalIndex = getDecimalSymbolIndex(\n            rawValue,\n            decimalSymbol,\n            autoCorrectDecimalSymbol,\n        );\n        const hasDecimal = decimalIndex !== -1;\n        const integer = hasDecimal ? rawValue.slice(0, decimalIndex) : rawValue;\n        const thousandSeparators = integer.match(new RegExp(thousandSymbol, `g`)) || [];\n        const integerCapped = integerLimit\n            ? integer.slice(0, integerLimit + thousandSeparators.length)\n            : integer;\n        const integerCappedClean = integerCapped.replace(TUI_NON_DIGITS_REGEXP, ``);\n        const [leadingZerosMatch] = integerCappedClean.match(\n            TUI_LEADING_ZEROES_REGEXP,\n        ) || [``];\n        const leadingZerosAmount = leadingZerosMatch.length;\n        const integerCappedZerosClean = integerCappedClean\n            .replace(/^0+(?!\\.|$)/, ``)\n            .trim();\n        const withSeparator = addThousandsSeparator(\n            integerCappedZerosClean,\n            thousandSymbol,\n        );\n        const mask = convertToMask(withSeparator);\n\n        if ((hasDecimal && allowDecimal) || requireDecimal) {\n            const fraction = hasDecimal\n                ? convertToMask(\n                      rawValue.slice(decimalIndex + 1).replace(TUI_NON_DIGITS_REGEXP, ``),\n                  )\n                : [];\n            const fractionCapped = decimalLimit\n                ? fraction.slice(0, decimalLimit)\n                : fraction;\n\n            if (rawValue[decimalIndex] !== tuiOtherDecimalSymbol(decimalSymbol)) {\n                mask.push(MASK_CARET_TRAP);\n            }\n\n            mask.push(decimalSymbol, MASK_CARET_TRAP, ...fractionCapped);\n\n            for (let i = 0; i < Math.min(decimalLimit - fractionCapped.length, 20); i++) {\n                mask.push(TUI_DIGIT_REGEXP);\n            }\n        }\n\n        const isOnlyZeroDigit = mask.length === 1 && integerCappedZerosClean === `0`;\n\n        if (isNegative) {\n            if (mask.length === 0) {\n                mask.push(TUI_DIGIT_REGEXP);\n            }\n\n            mask.unshift(CHAR_HYPHEN);\n        }\n\n        return preventLeadingZeroes(mask, isOnlyZeroDigit, leadingZerosAmount);\n    };\n}\n\nfunction preventLeadingZeroes(\n    mask: Array<RegExp | string>,\n    isOnlyZeroDigit: boolean = false,\n    leadingZerosAmount: number = 0,\n): Array<RegExp | string> {\n    if (isOnlyZeroDigit || leadingZerosAmount === 0) {\n        return mask;\n    }\n\n    const firstDigitIndex = mask.indexOf(TUI_DIGIT_REGEXP);\n\n    if (firstDigitIndex === -1) {\n        return mask;\n    }\n\n    const secondMaskDigit = mask[firstDigitIndex + 1];\n    const isCaretTrap = secondMaskDigit === MASK_CARET_TRAP;\n\n    if (isCaretTrap && leadingZerosAmount === 1) {\n        return mask;\n    }\n\n    if (isCaretTrap) {\n        mask.unshift(NON_ZERO_DIGIT);\n\n        return mask;\n    }\n\n    mask[firstDigitIndex] = NON_ZERO_DIGIT;\n\n    return mask;\n}\n\nfunction getDecimalSymbolIndex(\n    str: string,\n    decimalSymbol: TuiDecimalSymbol,\n    autoCorrectDecimalSymbol: boolean,\n): number {\n    if (!autoCorrectDecimalSymbol) {\n        return str.lastIndexOf(decimalSymbol);\n    }\n\n    return Math.max(\n        str.lastIndexOf(decimalSymbol),\n        str.lastIndexOf(tuiOtherDecimalSymbol(decimalSymbol)),\n    );\n}\n\nfunction isDecimalSymbol(\n    str: string,\n    decimalSymbol: TuiDecimalSymbol,\n    autoCorrectDecimalSymbol: boolean,\n): boolean {\n    if (autoCorrectDecimalSymbol) {\n        return /^[,.]$/.test(str);\n    }\n\n    return str === decimalSymbol;\n}\n\nfunction convertToMask(strNumber: string): Array<RegExp | string> {\n    return strNumber\n        .split(``)\n        .map(char => (TUI_DIGIT_REGEXP.test(char) ? TUI_DIGIT_REGEXP : char));\n}\n\nfunction addThousandsSeparator(strNumber: string, thousandSymbol: string): string {\n    return strNumber.length > 3\n        ? // TODO: investigate to disallow potentially catastrophic exponential-time regular expressions.\n          // eslint-disable-next-line unicorn/no-unsafe-regex\n          strNumber.replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousandSymbol)\n        : strNumber;\n}\n","import {TUI_DECIMAL_SYMBOLS} from '@taiga-ui/core/constants';\nimport {TuiNumberFormatSettings} from '@taiga-ui/core/interfaces';\n\nexport function tuiEnableAutoCorrectDecimalSymbol({\n    thousandSeparator,\n}: TuiNumberFormatSettings): boolean {\n    return !TUI_DECIMAL_SYMBOLS.includes(thousandSeparator);\n}\n","import {CHAR_HYPHEN} from '@taiga-ui/cdk';\n\nexport function tuiMaskedMoneyValueIsEmpty(value: string): boolean {\n    switch (value) {\n        case ``:\n        case CHAR_HYPHEN:\n        case `,`:\n        case `${CHAR_HYPHEN},`:\n            return true;\n        default:\n            return false;\n    }\n}\n","import {TuiDecimalSymbol} from '@taiga-ui/core/types';\n\nexport function tuiMaskedNumberStringToNumber(\n    value: string,\n    decimalsSymbol: TuiDecimalSymbol,\n    thousandSymbol: string,\n): number {\n    return parseFloat(\n        value.split(thousandSymbol).join(``).split(decimalsSymbol).join(`.`),\n    );\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}