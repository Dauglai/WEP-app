import * as i0 from '@angular/core';
import { InjectionToken, ElementRef, INJECTOR, Directive, Inject, Input, Optional, SkipSelf, forwardRef, Component, ChangeDetectionStrategy, Self, HostBinding, HostListener, ViewContainerRef, NgModule } from '@angular/core';
import { WINDOW } from '@ng-web-apis/common';
import * as i2 from '@taiga-ui/cdk';
import { TuiDropdownPortalService, tuiPure, TuiHoveredService, tuiDefaultProp, tuiPx, tuiGetClosestFocusable, TuiDestroyService, AbstractTuiPortalHostComponent, EMPTY_CLIENT_RECT, tuiPointToClientRect, TuiActiveZoneDirective, ALWAYS_TRUE_HANDLER, tuiIsTextNode, tuiIsString, tuiIsElement, tuiGetNativeFocused, tuiIsTextfield, CHAR_ZERO_WIDTH_SPACE, CHAR_NO_BREAK_SPACE, TUI_RANGE, TuiActiveZoneModule, TuiOverscrollModule, TuiHoveredModule } from '@taiga-ui/cdk';
import * as i1$2 from '@taiga-ui/core/abstract';
import { tuiAsRectAccessor, tuiAsVehicle, TuiDriver, tuiAsDriver, TuiRectAccessor, tuiPositionAccessorFor, tuiRectAccessorFor, AbstractTuiDriverDirective, TuiVehicle, TuiPositionAccessor, tuiFallbackRectAccessor, tuiAsPositionAccessor } from '@taiga-ui/core/abstract';
import { tuiDropdownAnimation } from '@taiga-ui/core/animations';
import * as i9 from '@taiga-ui/core/services';
import { TuiPositionService, TuiVisualViewportService } from '@taiga-ui/core/services';
import { TUI_ANIMATION_OPTIONS, TUI_VIEWPORT, TUI_SELECTION_STREAM } from '@taiga-ui/core/tokens';
import { switchMap, delay, tap, share, map, takeUntil, distinctUntilChanged } from 'rxjs/operators';
import { __decorate } from 'tslib';
import { tuiCheckFixedPosition, tuiOverrideOptions, tuiGetWordRange } from '@taiga-ui/core/utils';
import * as i4 from '@tinkoff/ng-polymorpheus';
import { PolymorpheusComponent, PolymorpheusModule } from '@tinkoff/ng-polymorpheus';
import * as i1 from 'rxjs';
import { Subject, merge, of, BehaviorSubject, combineLatest } from 'rxjs';
import * as i1$1 from '@taiga-ui/core/components/scrollbar';
import { TuiScrollbarModule } from '@taiga-ui/core/components/scrollbar';
import * as i3 from '@taiga-ui/core/directives/mode';
import { TuiModeModule } from '@taiga-ui/core/directives/mode';
import { shouldCall } from '@tinkoff/ng-event-plugins';
import { DOCUMENT } from '@angular/common';

/**
 * A component to display a dropdown
 */
const TUI_DROPDOWN_COMPONENT = new InjectionToken(`[TUI_DROPDOWN_COMPONENT]`, {
    factory: () => TuiDropdownComponent,
});

class TuiDropdownDirective {
    constructor(el, hapica, injector, dropdownService) {
        this.el = el;
        this.hapica = hapica;
        this.injector = injector;
        this.dropdownService = dropdownService;
        this.dropdownBoxRef = null;
        this.type = 'dropdown';
        this.component = new PolymorpheusComponent(this.hapica, this.injector);
    }
    get position() {
        return tuiCheckFixedPosition(this.el.nativeElement) ? 'fixed' : 'absolute';
    }
    ngAfterViewChecked() {
        var _a, _b;
        (_a = this.dropdownBoxRef) === null || _a === void 0 ? void 0 : _a.changeDetectorRef.detectChanges();
        (_b = this.dropdownBoxRef) === null || _b === void 0 ? void 0 : _b.changeDetectorRef.markForCheck();
    }
    ngOnChanges() {
        if (!this.content) {
            this.toggle(false);
        }
    }
    ngOnDestroy() {
        this.toggle(false);
    }
    getClientRect() {
        return this.el.nativeElement.getBoundingClientRect();
    }
    toggle(show) {
        if (show && this.content && !this.dropdownBoxRef) {
            this.dropdownBoxRef = this.dropdownService.add(this.component);
        }
        else if (!show && this.dropdownBoxRef) {
            this.dropdownService.remove(this.dropdownBoxRef);
            this.dropdownBoxRef = null;
        }
    }
}
TuiDropdownDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownDirective, deps: [{ token: ElementRef }, { token: TUI_DROPDOWN_COMPONENT }, { token: INJECTOR }, { token: TuiDropdownPortalService }], target: i0.ɵɵFactoryTarget.Directive });
TuiDropdownDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiDropdownDirective, selector: "[tuiDropdown]:not(ng-container)", inputs: { content: ["tuiDropdown", "content"] }, providers: [
        tuiAsRectAccessor(TuiDropdownDirective),
        tuiAsVehicle(TuiDropdownDirective),
    ], exportAs: ["tuiDropdown"], usesOnChanges: true, ngImport: i0 });
__decorate([
    tuiPure
], TuiDropdownDirective.prototype, "position", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiDropdown]:not(ng-container)',
                    exportAs: 'tuiDropdown',
                    providers: [
                        tuiAsRectAccessor(TuiDropdownDirective),
                        tuiAsVehicle(TuiDropdownDirective),
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i0.Type, decorators: [{
                    type: Inject,
                    args: [TUI_DROPDOWN_COMPONENT]
                }] }, { type: i0.Injector, decorators: [{
                    type: Inject,
                    args: [INJECTOR]
                }] }, { type: i2.TuiDropdownPortalService, decorators: [{
                    type: Inject,
                    args: [TuiDropdownPortalService]
                }] }]; }, propDecorators: { content: [{
                type: Input,
                args: ['tuiDropdown']
            }], position: [] } });

/** Default values for hint options */
const TUI_DROPDOWN_HOVER_DEFAULT_OPTIONS = {
    showDelay: 200,
    hideDelay: 500,
};
/**
 * Default parameters for dropdown hover directive
 */
const TUI_DROPDOWN_HOVER_OPTIONS = new InjectionToken('[TUI_DROPDOWN_HOVER_OPTIONS]', {
    factory: () => TUI_DROPDOWN_HOVER_DEFAULT_OPTIONS,
});
const tuiDropdownHoverOptionsProvider = (options) => ({
    provide: TUI_DROPDOWN_HOVER_DEFAULT_OPTIONS,
    useValue: Object.assign(Object.assign({}, TUI_DROPDOWN_HOVER_DEFAULT_OPTIONS), options),
});

class TuiDropdownHoverDirective extends TuiDriver {
    constructor(hovered$, options) {
        super(subscriber => this.stream$.subscribe(subscriber));
        this.hovered$ = hovered$;
        this.options = options;
        this.toggle$ = new Subject();
        this.stream$ = merge(this.toggle$, this.hovered$).pipe(switchMap(visible => of(visible).pipe(delay(visible ? this.showDelay : this.hideDelay))), tap(visible => {
            this.hovered = visible;
        }), share());
        this.showDelay = this.options.showDelay;
        this.hideDelay = this.options.hideDelay;
        this.hovered = false;
        this.type = 'dropdown';
    }
    toggle(visible) {
        this.toggle$.next(visible);
    }
}
TuiDropdownHoverDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownHoverDirective, deps: [{ token: TuiHoveredService }, { token: TUI_DROPDOWN_HOVER_OPTIONS }], target: i0.ɵɵFactoryTarget.Directive });
TuiDropdownHoverDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiDropdownHoverDirective, selector: "[tuiDropdownHover]:not(ng-container)", inputs: { showDelay: ["tuiDropdownShowDelay", "showDelay"], hideDelay: ["tuiDropdownHideDelay", "hideDelay"] }, providers: [tuiAsDriver(TuiDropdownHoverDirective), TuiHoveredService], usesInheritance: true, ngImport: i0 });
__decorate([
    tuiDefaultProp()
], TuiDropdownHoverDirective.prototype, "showDelay", void 0);
__decorate([
    tuiDefaultProp()
], TuiDropdownHoverDirective.prototype, "hideDelay", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownHoverDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiDropdownHover]:not(ng-container)',
                    providers: [tuiAsDriver(TuiDropdownHoverDirective), TuiHoveredService],
                }]
        }], ctorParameters: function () { return [{ type: i1.Observable, decorators: [{
                    type: Inject,
                    args: [TuiHoveredService]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_DROPDOWN_HOVER_OPTIONS]
                }] }]; }, propDecorators: { showDelay: [{
                type: Input,
                args: ['tuiDropdownShowDelay']
            }], hideDelay: [{
                type: Input,
                args: ['tuiDropdownHideDelay']
            }] } });

/** Default values for dropdown options */
const TUI_DROPDOWN_DEFAULT_OPTIONS = {
    align: 'left',
    direction: null,
    limitWidth: 'auto',
    maxHeight: 400,
    minHeight: 80,
    offset: 4,
};
/**
 * Default parameters for dropdown directive
 */
const TUI_DROPDOWN_OPTIONS = new InjectionToken('[TUI_DROPDOWN_OPTIONS]', {
    factory: () => TUI_DROPDOWN_DEFAULT_OPTIONS,
});
const tuiDropdownOptionsProvider = (override) => ({
    provide: TUI_DROPDOWN_OPTIONS,
    deps: [
        [new Optional(), TuiDropdownOptionsDirective],
        [new SkipSelf(), TUI_DROPDOWN_OPTIONS],
    ],
    useFactory: tuiOverrideOptions(override),
});
class TuiDropdownOptionsDirective {
    constructor(options) {
        this.options = options;
        this.align = this.options.align;
        this.direction = this.options.direction;
        this.limitWidth = this.options.limitWidth;
        this.minHeight = this.options.minHeight;
        this.maxHeight = this.options.maxHeight;
        this.offset = this.options.offset;
    }
}
TuiDropdownOptionsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownOptionsDirective, deps: [{ token: TUI_DROPDOWN_OPTIONS, skipSelf: true }], target: i0.ɵɵFactoryTarget.Directive });
TuiDropdownOptionsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiDropdownOptionsDirective, selector: "[tuiDropdownAlign], [tuiDropdownDirection], [tuiDropdownLimitWidth], [tuiDropdownMinHeight], [tuiDropdownMaxHeight], [tuiDropdownOffset]", inputs: { align: ["tuiDropdownAlign", "align"], direction: ["tuiDropdownDirection", "direction"], limitWidth: ["tuiDropdownLimitWidth", "limitWidth"], minHeight: ["tuiDropdownMinHeight", "minHeight"], maxHeight: ["tuiDropdownMaxHeight", "maxHeight"], offset: ["tuiDropdownOffset", "offset"] }, providers: [
        {
            provide: TUI_DROPDOWN_OPTIONS,
            useExisting: forwardRef(() => TuiDropdownOptionsDirective),
        },
    ], ngImport: i0 });
__decorate([
    tuiDefaultProp()
], TuiDropdownOptionsDirective.prototype, "align", void 0);
__decorate([
    tuiDefaultProp()
], TuiDropdownOptionsDirective.prototype, "direction", void 0);
__decorate([
    tuiDefaultProp()
], TuiDropdownOptionsDirective.prototype, "limitWidth", void 0);
__decorate([
    tuiDefaultProp()
], TuiDropdownOptionsDirective.prototype, "minHeight", void 0);
__decorate([
    tuiDefaultProp()
], TuiDropdownOptionsDirective.prototype, "maxHeight", void 0);
__decorate([
    tuiDefaultProp()
], TuiDropdownOptionsDirective.prototype, "offset", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownOptionsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiDropdownAlign], [tuiDropdownDirection], [tuiDropdownLimitWidth], [tuiDropdownMinHeight], [tuiDropdownMaxHeight], [tuiDropdownOffset]',
                    providers: [
                        {
                            provide: TUI_DROPDOWN_OPTIONS,
                            useExisting: forwardRef(() => TuiDropdownOptionsDirective),
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: SkipSelf
                }, {
                    type: Inject,
                    args: [TUI_DROPDOWN_OPTIONS]
                }] }]; }, propDecorators: { align: [{
                type: Input,
                args: ['tuiDropdownAlign']
            }], direction: [{
                type: Input,
                args: ['tuiDropdownDirection']
            }], limitWidth: [{
                type: Input,
                args: ['tuiDropdownLimitWidth']
            }], minHeight: [{
                type: Input,
                args: ['tuiDropdownMinHeight']
            }], maxHeight: [{
                type: Input,
                args: ['tuiDropdownMaxHeight']
            }], offset: [{
                type: Input,
                args: ['tuiDropdownOffset']
            }] } });

/**
 * @description:
 * This component is used to show template in a portal
 * using default style of white rounded box with a shadow
 */
class TuiDropdownComponent {
    constructor(position$, destroy$, directive, el, host, accessor, win, animationOptions, options, hoverDirective, visualViewportService) {
        this.directive = directive;
        this.el = el;
        this.host = host;
        this.accessor = accessor;
        this.win = win;
        this.animationOptions = animationOptions;
        this.options = options;
        this.hoverDirective = hoverDirective;
        this.dropdownAnimation = Object.assign({ value: "fadeInTop" /* FadeInTop */ }, this.animationOptions);
        position$
            .pipe(map(point => this.directive.position === 'fixed'
            ? visualViewportService.correct(point)
            : point), takeUntil(destroy$))
            .subscribe(([top, left]) => {
            this.update(top, left);
        });
        this.updateWidth(this.accessor.getClientRect().width);
    }
    ngOnDestroy() {
        this.onHoveredChange(false);
    }
    onHoveredChange(hovered) {
        if (this.hoverDirective) {
            this.hoverDirective.toggle(hovered);
        }
    }
    onTopFocus() {
        this.moveFocusOutside(true);
    }
    onBottomFocus() {
        this.moveFocusOutside(false);
    }
    update(top, left) {
        const { style } = this.el.nativeElement;
        const { right } = this.el.nativeElement.getBoundingClientRect();
        const { maxHeight, offset } = this.options;
        const { innerHeight } = this.win;
        const { clientRect } = this.host;
        const { position } = this.directive;
        const rect = this.accessor.getClientRect();
        const offsetX = position === 'fixed' ? 0 : -clientRect.left;
        const offsetY = position === 'fixed' ? 0 : -clientRect.top;
        top += offsetY;
        left += offsetX;
        const isIntersecting = left < rect.right && right > rect.left && top < offsetY + 2 * offset;
        const available = isIntersecting
            ? rect.top - 2 * offset
            : offsetY + innerHeight - top - offset;
        style.position = position;
        style.top = tuiPx(Math.max(top, offsetY + offset));
        style.left = tuiPx(left);
        style.maxHeight = tuiPx(Math.min(maxHeight, available));
        style.width = '';
        style.minWidth = '';
        this.updateWidth(rect.width);
    }
    updateWidth(width) {
        const { style } = this.el.nativeElement;
        switch (this.options.limitWidth) {
            case 'min':
                style.minWidth = tuiPx(width);
                break;
            case 'fixed':
                style.width = tuiPx(width);
                break;
            case 'auto':
                break;
        }
    }
    moveFocusOutside(previous) {
        const { nativeElement } = this.directive.el;
        const { ownerDocument } = nativeElement;
        const root = ownerDocument ? ownerDocument.body : nativeElement;
        let focusable = tuiGetClosestFocusable({ initial: nativeElement, root, previous });
        while (focusable !== null && nativeElement.contains(focusable)) {
            focusable = tuiGetClosestFocusable({ initial: focusable, root, previous });
        }
        focusable === null || focusable === void 0 ? void 0 : focusable.focus();
    }
}
TuiDropdownComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownComponent, deps: [{ token: TuiPositionService }, { token: TuiDestroyService, self: true }, { token: TuiDropdownDirective }, { token: ElementRef }, { token: AbstractTuiPortalHostComponent }, { token: TuiRectAccessor }, { token: WINDOW }, { token: TUI_ANIMATION_OPTIONS }, { token: TUI_DROPDOWN_OPTIONS }, { token: TuiDropdownHoverDirective, optional: true }, { token: TuiVisualViewportService }], target: i0.ɵɵFactoryTarget.Component });
TuiDropdownComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: TuiDropdownComponent, selector: "tui-dropdown", host: { properties: { "@tuiDropdownAnimation": "this.dropdownAnimation" } }, providers: [
        TuiDestroyService,
        TuiPositionService,
        tuiPositionAccessorFor('dropdown'),
        tuiRectAccessorFor('dropdown', TuiDropdownDirective),
    ], ngImport: i0, template: "<div\n    #activeZone=\"tuiActiveZone\"\n    tuiActiveZone\n    tuiOverscroll=\"all\"\n    class=\"t-wrapper\"\n    [tuiMode]=\"null\"\n    (tuiHoveredChange)=\"onHoveredChange($event)\"\n>\n    <tui-scrollbar class=\"t-scroll\">\n        <div\n            tabindex=\"0\"\n            (focus)=\"onTopFocus()\"\n        ></div>\n        <div\n            *polymorpheusOutlet=\"directive.content as text; context: {$implicit: activeZone}\"\n            class=\"t-primitive\"\n        >\n            {{ text }}\n        </div>\n        <div\n            tabindex=\"0\"\n            (focus)=\"onBottomFocus()\"\n        ></div>\n    </tui-scrollbar>\n</div>\n", styles: [":host{position:relative;z-index:0;box-shadow:0 1.5rem 1rem #00000008,0 .75rem .75rem #0000000a,0 .25rem .375rem #0000000d;position:absolute;display:flex;background-color:var(--tui-elevation-01);border-radius:var(--tui-radius-m);overflow:hidden;border:1px solid var(--tui-base-04);box-sizing:border-box;max-width:calc(100% - 8px)}:host.ng-animating{pointer-events:none}:host:not([style*=\"top\"]){visibility:hidden}.t-wrapper{flex-grow:1;max-width:100%;max-height:inherit;overflow:visible}.t-scroll{height:100%}.t-primitive{padding:1rem}\n"], components: [{ type: i1$1.TuiScrollbarComponent, selector: "tui-scrollbar", inputs: ["hidden"] }], directives: [{ type: i2.TuiActiveZoneDirective, selector: "[tuiActiveZone]:not(ng-container), [tuiActiveZoneChange]:not(ng-container), [tuiActiveZoneParent]:not(ng-container)", inputs: ["tuiActiveZoneParent"], outputs: ["tuiActiveZoneChange"], exportAs: ["tuiActiveZone"] }, { type: i2.TuiOverscrollDirective, selector: "[tuiOverscroll]", inputs: ["tuiOverscroll"] }, { type: i3.TuiModeDirective, selector: "[tuiMode]", inputs: ["tuiMode"] }, { type: i2.TuiHoveredDirective, selector: "[tuiHoveredChange]", outputs: ["tuiHoveredChange"] }, { type: i4.PolymorpheusOutletDirective, selector: "[polymorpheusOutlet]", inputs: ["polymorpheusOutlet", "polymorpheusOutletContext"] }], animations: [tuiDropdownAnimation], changeDetection: i0.ChangeDetectionStrategy.Default });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'tui-dropdown',
                    templateUrl: './dropdown.template.html',
                    styleUrls: ['./dropdown.style.less'],
                    providers: [
                        TuiDestroyService,
                        TuiPositionService,
                        tuiPositionAccessorFor('dropdown'),
                        tuiRectAccessorFor('dropdown', TuiDropdownDirective),
                    ],
                    animations: [tuiDropdownAnimation],
                    // @bad TODO: OnPush
                    // eslint-disable-next-line @angular-eslint/prefer-on-push-component-change-detection
                    changeDetection: ChangeDetectionStrategy.Default,
                }]
        }], ctorParameters: function () { return [{ type: i1.Observable, decorators: [{
                    type: Inject,
                    args: [TuiPositionService]
                }] }, { type: i1.Observable, decorators: [{
                    type: Self
                }, {
                    type: Inject,
                    args: [TuiDestroyService]
                }] }, { type: TuiDropdownDirective, decorators: [{
                    type: Inject,
                    args: [TuiDropdownDirective]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i2.AbstractTuiPortalHostComponent, decorators: [{
                    type: Inject,
                    args: [AbstractTuiPortalHostComponent]
                }] }, { type: i1$2.TuiRectAccessor, decorators: [{
                    type: Inject,
                    args: [TuiRectAccessor]
                }] }, { type: Window, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_ANIMATION_OPTIONS]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_DROPDOWN_OPTIONS]
                }] }, { type: TuiDropdownHoverDirective, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TuiDropdownHoverDirective]
                }] }, { type: i9.TuiVisualViewportService, decorators: [{
                    type: Inject,
                    args: [TuiVisualViewportService]
                }] }]; }, propDecorators: { dropdownAnimation: [{
                type: HostBinding,
                args: ['@tuiDropdownAnimation']
            }] } });

function activeZoneFilter(target) {
    return !this.activeZone.contains(target);
}
class TuiDropdownContextDirective extends TuiDriver {
    constructor(activeZone) {
        super(subscriber => this.stream$.subscribe(subscriber));
        this.activeZone = activeZone;
        this.stream$ = new Subject();
        this.currentRect = EMPTY_CLIENT_RECT;
        this.type = 'dropdown';
    }
    onContextMenu(x, y) {
        this.currentRect = tuiPointToClientRect(x, y);
        this.stream$.next(true);
    }
    closeDropdown() {
        this.stream$.next(false);
    }
    getClientRect() {
        return this.currentRect;
    }
}
TuiDropdownContextDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownContextDirective, deps: [{ token: TuiActiveZoneDirective }], target: i0.ɵɵFactoryTarget.Directive });
TuiDropdownContextDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiDropdownContextDirective, selector: "[tuiDropdown][tuiDropdownContext]", host: { listeners: { "contextmenu.prevent.stop": "onContextMenu($event.clientX,$event.clientY)", "document:click.silent": "closeDropdown($event.target)", "document:contextmenu.capture.silent": "closeDropdown($event.target)", "document:keydown.esc": "closeDropdown($event.currentTarget)" } }, providers: [
        TuiActiveZoneDirective,
        tuiAsDriver(TuiDropdownContextDirective),
        tuiAsRectAccessor(TuiDropdownContextDirective),
    ], usesInheritance: true, ngImport: i0 });
__decorate([
    shouldCall(activeZoneFilter)
], TuiDropdownContextDirective.prototype, "closeDropdown", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownContextDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiDropdown][tuiDropdownContext]',
                    providers: [
                        TuiActiveZoneDirective,
                        tuiAsDriver(TuiDropdownContextDirective),
                        tuiAsRectAccessor(TuiDropdownContextDirective),
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i2.TuiActiveZoneDirective, decorators: [{
                    type: Inject,
                    args: [TuiActiveZoneDirective]
                }] }]; }, propDecorators: { onContextMenu: [{
                type: HostListener,
                args: ['contextmenu.prevent.stop', ['$event.clientX', '$event.clientY']]
            }], closeDropdown: [{
                type: HostListener,
                args: ['document:click.silent', ['$event.target']]
            }, {
                type: HostListener,
                args: ['document:contextmenu.capture.silent', ['$event.target']]
            }, {
                type: HostListener,
                args: ['document:keydown.esc', ['$event.currentTarget']]
            }] } });

class TuiDropdownDriverDirective extends AbstractTuiDriverDirective {
    // TODO: Figure out why this is necessary under nx test runner
    constructor(destroy$, drivers, vehicles) {
        super(destroy$, drivers, vehicles);
        this.type = 'dropdown';
    }
}
TuiDropdownDriverDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownDriverDirective, deps: [{ token: TuiDestroyService, self: true }, { token: TuiDriver }, { token: TuiVehicle }], target: i0.ɵɵFactoryTarget.Directive });
TuiDropdownDriverDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiDropdownDriverDirective, selector: "[tuiDropdown]", providers: [TuiDestroyService], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownDriverDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiDropdown]',
                    providers: [TuiDestroyService],
                }]
        }], ctorParameters: function () { return [{ type: i1.Observable, decorators: [{
                    type: Self
                }, {
                    type: Inject,
                    args: [TuiDestroyService]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TuiDriver]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TuiVehicle]
                }] }]; } });

class TuiDropdownHostDirective extends TuiRectAccessor {
    constructor() {
        super(...arguments);
        this.type = 'dropdown';
    }
    getClientRect() {
        var _a;
        return ((_a = this.tuiDropdownHost) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || EMPTY_CLIENT_RECT;
    }
}
TuiDropdownHostDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownHostDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
TuiDropdownHostDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiDropdownHostDirective, selector: "[tuiDropdown][tuiDropdownHost]", inputs: { tuiDropdownHost: "tuiDropdownHost" }, providers: [tuiAsRectAccessor(TuiDropdownHostDirective)], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownHostDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiDropdown][tuiDropdownHost]',
                    providers: [tuiAsRectAccessor(TuiDropdownHostDirective)],
                }]
        }], propDecorators: { tuiDropdownHost: [{
                type: Input
            }] } });

class TuiDropdownManualDirective extends TuiDriver {
    constructor() {
        super(subscriber => this.stream$.subscribe(subscriber));
        this.stream$ = new BehaviorSubject(false);
        this.tuiDropdownManual = false;
        this.type = 'dropdown';
    }
    ngOnChanges() {
        this.stream$.next(this.tuiDropdownManual);
    }
}
TuiDropdownManualDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownManualDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
TuiDropdownManualDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiDropdownManualDirective, selector: "[tuiDropdown][tuiDropdownManual]", inputs: { tuiDropdownManual: "tuiDropdownManual" }, providers: [tuiAsDriver(TuiDropdownManualDirective)], usesInheritance: true, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownManualDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiDropdown][tuiDropdownManual]',
                    providers: [tuiAsDriver(TuiDropdownManualDirective)],
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { tuiDropdownManual: [{
                type: Input
            }] } });

class TuiDropdownPositionDirective extends TuiPositionAccessor {
    constructor(options, viewport, accessors, directive) {
        super();
        this.options = options;
        this.viewport = viewport;
        this.accessors = accessors;
        this.directive = directive;
        this.type = 'dropdown';
    }
    getPosition({ width, height }) {
        var _a, _b;
        const hostRect = (_b = (_a = this.accessor) === null || _a === void 0 ? void 0 : _a.getClientRect()) !== null && _b !== void 0 ? _b : EMPTY_CLIENT_RECT;
        const viewport = this.viewport.getClientRect();
        const { minHeight, align, direction, offset } = this.options;
        const previous = this.previous || direction || 'bottom';
        const right = Math.max(hostRect.right - width, offset);
        const available = {
            top: hostRect.top - 2 * offset - viewport.top,
            bottom: viewport.bottom - hostRect.bottom - 2 * offset,
        };
        const position = {
            top: hostRect.top - offset - height,
            bottom: hostRect.bottom + offset,
            right,
            center: hostRect.left + hostRect.width / 2 + width / 2 < viewport.right - offset
                ? hostRect.left + hostRect.width / 2 - width / 2
                : right,
            left: hostRect.left + width < viewport.right - offset ? hostRect.left : right,
        };
        const better = available.top > available.bottom ? 'top' : 'bottom';
        if ((available[previous] > minHeight && direction) ||
            available[previous] > height) {
            return [position[previous], position[align]];
        }
        this.previous = better;
        return [position[better], position[align]];
    }
    get accessor() {
        return tuiFallbackRectAccessor('dropdown')(this.accessors, this.directive);
    }
}
TuiDropdownPositionDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownPositionDirective, deps: [{ token: TUI_DROPDOWN_OPTIONS }, { token: TUI_VIEWPORT }, { token: TuiRectAccessor }, { token: TuiDropdownDirective }], target: i0.ɵɵFactoryTarget.Directive });
TuiDropdownPositionDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiDropdownPositionDirective, selector: "[tuiDropdown]:not([tuiDropdownCustomPosition]):not([tuiDropdownSided])", providers: [tuiAsPositionAccessor(TuiDropdownPositionDirective)], usesInheritance: true, ngImport: i0 });
__decorate([
    tuiPure
], TuiDropdownPositionDirective.prototype, "accessor", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownPositionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiDropdown]:not([tuiDropdownCustomPosition]):not([tuiDropdownSided])',
                    providers: [tuiAsPositionAccessor(TuiDropdownPositionDirective)],
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_DROPDOWN_OPTIONS]
                }] }, { type: i1$2.TuiRectAccessor, decorators: [{
                    type: Inject,
                    args: [TUI_VIEWPORT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TuiRectAccessor]
                }] }, { type: TuiDropdownDirective, decorators: [{
                    type: Inject,
                    args: [TuiDropdownDirective]
                }] }]; }, propDecorators: { accessor: [] } });

class TuiDropdownPositionSidedDirective extends TuiPositionAccessor {
    constructor(options, viewport, vertical) {
        super();
        this.options = options;
        this.viewport = viewport;
        this.vertical = vertical;
        this.previous = this.options.direction || 'bottom';
        this.tuiDropdownSided = '';
        this.tuiDropdownSidedOffset = 4;
        this.type = 'dropdown';
    }
    getPosition(rect) {
        var _a, _b;
        if (this.tuiDropdownSided === false) {
            return this.vertical.getPosition(rect);
        }
        const { height, width } = rect;
        const hostRect = (_b = (_a = this.vertical.accessor) === null || _a === void 0 ? void 0 : _a.getClientRect()) !== null && _b !== void 0 ? _b : EMPTY_CLIENT_RECT;
        const viewport = this.viewport.getClientRect();
        const { direction, minHeight, offset } = this.options;
        const align = this.options.align === 'center' ? 'left' : this.options.align;
        const available = {
            top: hostRect.bottom - viewport.top,
            left: hostRect.left - offset - viewport.left,
            right: viewport.right - hostRect.right - offset,
            bottom: viewport.bottom - hostRect.top,
        };
        const position = {
            top: hostRect.bottom - height + this.tuiDropdownSidedOffset + 1,
            left: hostRect.left - width - offset,
            right: hostRect.right + offset,
            bottom: hostRect.top - this.tuiDropdownSidedOffset - 1, // 1 for border
        };
        const better = available.top > available.bottom ? 'top' : 'bottom';
        const maxLeft = available.left > available.right ? position.left : position.right;
        const left = available[align] > width ? position[align] : maxLeft;
        if ((available[this.previous] > minHeight && direction) ||
            this.previous === better) {
            return [position[this.previous], left];
        }
        this.previous = better;
        return [position[better], left];
    }
}
TuiDropdownPositionSidedDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownPositionSidedDirective, deps: [{ token: TUI_DROPDOWN_OPTIONS }, { token: TUI_VIEWPORT }, { token: TuiDropdownPositionDirective }], target: i0.ɵɵFactoryTarget.Directive });
TuiDropdownPositionSidedDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiDropdownPositionSidedDirective, selector: "[tuiDropdownSided]", inputs: { tuiDropdownSided: "tuiDropdownSided", tuiDropdownSidedOffset: "tuiDropdownSidedOffset" }, providers: [
        TuiDropdownPositionDirective,
        tuiAsPositionAccessor(TuiDropdownPositionSidedDirective),
    ], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownPositionSidedDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiDropdownSided]',
                    providers: [
                        TuiDropdownPositionDirective,
                        tuiAsPositionAccessor(TuiDropdownPositionSidedDirective),
                    ],
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_DROPDOWN_OPTIONS]
                }] }, { type: i1$2.TuiRectAccessor, decorators: [{
                    type: Inject,
                    args: [TUI_VIEWPORT]
                }] }, { type: TuiDropdownPositionDirective, decorators: [{
                    type: Inject,
                    args: [TuiDropdownPositionDirective]
                }] }]; }, propDecorators: { tuiDropdownSided: [{
                type: Input
            }], tuiDropdownSidedOffset: [{
                type: Input
            }] } });

class TuiDropdownSelectionDirective extends TuiDriver {
    constructor(range, doc, selection$, el, vcr, dropdown) {
        super(subscriber => this.stream$.subscribe(subscriber));
        this.range = range;
        this.doc = doc;
        this.selection$ = selection$;
        this.el = el;
        this.vcr = vcr;
        this.dropdown = dropdown;
        this.handler$ = new BehaviorSubject(ALWAYS_TRUE_HANDLER);
        this.stream$ = combineLatest([
            this.handler$,
            this.selection$.pipe(map(() => this.getRange()), distinctUntilChanged()),
        ]).pipe(map(([handler, range]) => {
            const contained = this.el.nativeElement.contains(range.commonAncestorContainer);
            this.range =
                contained && tuiIsTextNode(range.commonAncestorContainer)
                    ? range
                    : this.range;
            return (contained && handler(this.range)) || this.inDropdown(range);
        }));
        this.position = 'selection';
        this.type = 'dropdown';
    }
    set tuiDropdownSelection(visible) {
        if (!tuiIsString(visible)) {
            this.handler$.next(visible);
        }
    }
    getClientRect() {
        switch (this.position) {
            case 'tag': {
                const { commonAncestorContainer } = this.range;
                const element = tuiIsElement(commonAncestorContainer)
                    ? commonAncestorContainer
                    : commonAncestorContainer.parentNode;
                return element && tuiIsElement(element)
                    ? element.getBoundingClientRect()
                    : EMPTY_CLIENT_RECT;
            }
            case 'word':
                return tuiGetWordRange(this.range).getBoundingClientRect();
            default:
                return this.range.getBoundingClientRect();
        }
    }
    ngOnDestroy() {
        if (this.ghost) {
            this.vcr.element.nativeElement.removeChild(this.ghost);
        }
    }
    getRange() {
        const active = tuiGetNativeFocused(this.doc);
        const selection = this.doc.getSelection();
        if (active && tuiIsTextfield(active) && this.el.nativeElement.contains(active)) {
            return this.veryVerySadInputFix(active);
        }
        return (selection === null || selection === void 0 ? void 0 : selection.rangeCount) ? selection.getRangeAt(0) : this.range;
    }
    /**
     * Check if Node is inside dropdown
     */
    boxContains(node) {
        var _a;
        return !!((_a = this.dropdown.dropdownBoxRef) === null || _a === void 0 ? void 0 : _a.location.nativeElement.contains(node));
    }
    /**
     * Check if given range is at least partially inside dropdown
     */
    inDropdown(range) {
        const { startContainer, endContainer } = range;
        const { nativeElement } = this.el;
        const inDropdown = this.boxContains(range.commonAncestorContainer);
        const hostToDropdown = this.boxContains(endContainer) && nativeElement.contains(startContainer);
        const dropdownToHost = this.boxContains(startContainer) && nativeElement.contains(endContainer);
        return inDropdown || hostToDropdown || dropdownToHost;
    }
    veryVerySadInputFix(element) {
        const { ghost = this.initGhost(element) } = this;
        const { top, left, width, height } = element.getBoundingClientRect();
        const { selectionStart, selectionEnd, value } = element;
        const range = this.doc.createRange();
        const hostRect = this.el.nativeElement.getBoundingClientRect();
        ghost.style.top = tuiPx(top - hostRect.top);
        ghost.style.left = tuiPx(left - hostRect.left);
        ghost.style.width = tuiPx(width);
        ghost.style.height = tuiPx(height);
        ghost.textContent = CHAR_ZERO_WIDTH_SPACE + value + CHAR_NO_BREAK_SPACE;
        range.setStart(ghost.firstChild, selectionStart || 0);
        range.setEnd(ghost.firstChild, selectionEnd || 0);
        return range;
    }
    /**
     * Create an invisible DIV styled exactly like input/textarea element inside directive
     */
    initGhost(element) {
        const ghost = this.doc.createElement('div');
        const { font, letterSpacing, textTransform, padding } = getComputedStyle(element);
        ghost.style.position = 'absolute';
        ghost.style.pointerEvents = 'none';
        ghost.style.opacity = '0';
        ghost.style.whiteSpace = 'pre-wrap';
        ghost.style.font = font;
        ghost.style.letterSpacing = letterSpacing;
        ghost.style.textTransform = textTransform;
        ghost.style.padding = padding;
        this.vcr.element.nativeElement.appendChild(ghost);
        this.ghost = ghost;
        return ghost;
    }
}
TuiDropdownSelectionDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownSelectionDirective, deps: [{ token: TUI_RANGE }, { token: DOCUMENT }, { token: TUI_SELECTION_STREAM }, { token: ElementRef }, { token: ViewContainerRef }, { token: TuiDropdownDirective }], target: i0.ɵɵFactoryTarget.Directive });
TuiDropdownSelectionDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiDropdownSelectionDirective, selector: "[tuiDropdown][tuiDropdownSelection]", inputs: { position: ["tuiDropdownSelectionPosition", "position"], tuiDropdownSelection: "tuiDropdownSelection" }, providers: [
        tuiAsDriver(TuiDropdownSelectionDirective),
        tuiAsRectAccessor(TuiDropdownSelectionDirective),
    ], usesInheritance: true, ngImport: i0 });
__decorate([
    tuiDefaultProp()
], TuiDropdownSelectionDirective.prototype, "position", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownSelectionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiDropdown][tuiDropdownSelection]',
                    providers: [
                        tuiAsDriver(TuiDropdownSelectionDirective),
                        tuiAsRectAccessor(TuiDropdownSelectionDirective),
                    ],
                }]
        }], ctorParameters: function () { return [{ type: Range, decorators: [{
                    type: Inject,
                    args: [TUI_RANGE]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i1.Observable, decorators: [{
                    type: Inject,
                    args: [TUI_SELECTION_STREAM]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i0.ViewContainerRef, decorators: [{
                    type: Inject,
                    args: [ViewContainerRef]
                }] }, { type: TuiDropdownDirective, decorators: [{
                    type: Inject,
                    args: [TuiDropdownDirective]
                }] }]; }, propDecorators: { position: [{
                type: Input,
                args: ['tuiDropdownSelectionPosition']
            }], tuiDropdownSelection: [{
                type: Input
            }] } });

class TuiDropdownModule {
}
TuiDropdownModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TuiDropdownModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownModule, declarations: [TuiDropdownDirective,
        TuiDropdownComponent,
        TuiDropdownOptionsDirective,
        TuiDropdownHostDirective,
        TuiDropdownDriverDirective,
        TuiDropdownManualDirective,
        TuiDropdownHoverDirective,
        TuiDropdownContextDirective,
        TuiDropdownPositionDirective,
        TuiDropdownPositionSidedDirective,
        TuiDropdownSelectionDirective], imports: [PolymorpheusModule,
        TuiActiveZoneModule,
        TuiOverscrollModule,
        TuiScrollbarModule,
        TuiModeModule,
        TuiHoveredModule], exports: [TuiDropdownDirective,
        TuiDropdownComponent,
        TuiDropdownOptionsDirective,
        TuiDropdownHostDirective,
        TuiDropdownDriverDirective,
        TuiDropdownManualDirective,
        TuiDropdownHoverDirective,
        TuiDropdownContextDirective,
        TuiDropdownPositionDirective,
        TuiDropdownPositionSidedDirective,
        TuiDropdownSelectionDirective] });
TuiDropdownModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownModule, imports: [[
            PolymorpheusModule,
            TuiActiveZoneModule,
            TuiOverscrollModule,
            TuiScrollbarModule,
            TuiModeModule,
            TuiHoveredModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiDropdownModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        PolymorpheusModule,
                        TuiActiveZoneModule,
                        TuiOverscrollModule,
                        TuiScrollbarModule,
                        TuiModeModule,
                        TuiHoveredModule,
                    ],
                    declarations: [
                        TuiDropdownDirective,
                        TuiDropdownComponent,
                        TuiDropdownOptionsDirective,
                        TuiDropdownHostDirective,
                        TuiDropdownDriverDirective,
                        TuiDropdownManualDirective,
                        TuiDropdownHoverDirective,
                        TuiDropdownContextDirective,
                        TuiDropdownPositionDirective,
                        TuiDropdownPositionSidedDirective,
                        TuiDropdownSelectionDirective,
                    ],
                    exports: [
                        TuiDropdownDirective,
                        TuiDropdownComponent,
                        TuiDropdownOptionsDirective,
                        TuiDropdownHostDirective,
                        TuiDropdownDriverDirective,
                        TuiDropdownManualDirective,
                        TuiDropdownHoverDirective,
                        TuiDropdownContextDirective,
                        TuiDropdownPositionDirective,
                        TuiDropdownPositionSidedDirective,
                        TuiDropdownSelectionDirective,
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { TUI_DROPDOWN_COMPONENT, TUI_DROPDOWN_DEFAULT_OPTIONS, TUI_DROPDOWN_HOVER_DEFAULT_OPTIONS, TUI_DROPDOWN_HOVER_OPTIONS, TUI_DROPDOWN_OPTIONS, TuiDropdownComponent, TuiDropdownContextDirective, TuiDropdownDirective, TuiDropdownDriverDirective, TuiDropdownHostDirective, TuiDropdownHoverDirective, TuiDropdownManualDirective, TuiDropdownModule, TuiDropdownOptionsDirective, TuiDropdownPositionDirective, TuiDropdownPositionSidedDirective, TuiDropdownSelectionDirective, tuiDropdownHoverOptionsProvider, tuiDropdownOptionsProvider };
//# sourceMappingURL=taiga-ui-core-directives-dropdown.js.map
