import { __awaiter } from 'tslib';
import { rollup } from 'rollup';
import typescript from 'rollup-plugin-typescript2';
import { createFilter } from '@rollup/pluginutils';
import { optimize } from 'svgo';
import fs, { readFileSync, writeFileSync, readdirSync } from 'fs';
import prettier from 'prettier';
import { parse } from 'path';

function tuiRollupSvgo({ include = `**/*.svg`, exclude, options, } = {}) {
    const filter = createFilter(include, exclude);
    return {
        name: `rollupSvgo`,
        transform(svgString, path) {
            var _a, _b;
            const skip = !filter(path);
            if (skip) {
                console.info(`\x1B[33m%s\x1B[0m`, `[skip]`, path);
                return;
            }
            let data;
            let errorMessage;
            try {
                const result = optimize(svgString, Object.assign({ path }, options));
                data = ((_a = result) === null || _a === void 0 ? void 0 : _a.data) || {};
                errorMessage = result.error;
            }
            catch (err) {
                errorMessage = (_b = err) === null || _b === void 0 ? void 0 : _b.message;
            }
            if (errorMessage) {
                console.error(`\x1B[31m%s\x1B[0m`, `[error]`, path, `\n${svgString}`, `\n${errorMessage}`);
                process.exit(1);
            }
            console.info(`\x1B[32m%s\x1B[0m`, `[success]`, path);
            return {
                code: `export default ${JSON.stringify(data)}`,
                map: { mappings: `` },
            };
        },
    };
}

const banner = `
/**
 * @description:
 * DO NOT CHANGE THIS FILE. AUTOGENERATED
 *
 * This file contains inline svg icons
 * for users who wants insert into js bundle
 */
`;
function tuiConvertAllCompileFileToAllFile(config) {
    return __awaiter(this, void 0, void 0, function* () {
        const { from, to, prt2Options, include } = config;
        const inputOptions = {
            input: from,
            output: {
                generatedCode: {
                    constBindings: true,
                },
            },
            plugins: [
                typescript(prt2Options),
                tuiRollupSvgo({
                    include,
                    options: {
                        plugins: [
                            {
                                name: `preset-default`,
                                params: {
                                    overrides: {
                                        removeViewBox: false,
                                        collapseGroups: false,
                                        cleanupIDs: false,
                                        removeUnknownsAndDefaults: false,
                                    },
                                },
                            },
                        ],
                    },
                }),
            ],
        };
        console.info(`\x1B[36m%s\x1B[0m`, `TypeScript options: `, prt2Options);
        const bundle = yield rollup(inputOptions);
        yield bundle.write({
            banner,
            file: to,
            format: `es`,
            generatedCode: {
                constBindings: true,
            },
        });
        /**
         * @note:
         * The rollup bundle must be closed once `write` is finished to let plugins clean up their external
         * processes or services via the `closeBundle` hook, otherwise it can lead to memory leaks.
         */
        yield bundle.close();
    });
}

function tuiPostPrettierFormat({ file, config }) {
    console.info(`\x1B[36m%s\x1B[0m`, `format: ${file} by parser - ${config.parser}`);
    const bundledBody = readFileSync(file, `utf8`);
    const formatted = prettier.format(bundledBody, config);
    writeFileSync(file, formatted);
}

function tuiPrepareAllToCompileFile(iconsSrc, entryPointTs) {
    const icons = readdirSync(iconsSrc).filter(file => file.endsWith(`.svg`));
    console.info(`\x1B[36m%s\x1B[0m`, `Combine all svg icons into one file for bundling: ${icons.length}`);
    let importDeclarations = ``;
    let exportDeclarations = ``;
    for (const iconPath of icons) {
        const fileName = iconPath.split(`.`).shift();
        const filePath = `./src/${fileName}.svg`;
        importDeclarations += `import ${fileName} from '${filePath}';\n`;
        exportDeclarations += `${fileName}, `;
    }
    writeFileSync(entryPointTs, `${importDeclarations} \n export { ${exportDeclarations} }`);
}

const START = `<svg`;
const WIDTH_SEARCH = `width="`;
const HEIGHT_SEARCH = `height="`;
function tuiProcessIcons(files, interceptor) {
    for (const file of files) {
        const baseContent = String(fs.readFileSync(file));
        const src = interceptor ? interceptor(baseContent) : baseContent;
        const name = parse(file).base.replace(`.svg`, ``);
        if (src.includes(`id="${name}"`)) {
            console.info(`\x1B[33m%s\x1B[0m`, `[skip]:`, file);
            continue;
        }
        const wrapped = wrapIcon(src, name);
        const final = 
        // eslint-disable-next-line @taiga-ui/no-typeof
        typeof wrapped === `string`
            ? `${wrapped.replace(START, `<svg xmlns="http://www.w3.org/2000/svg"><g id="${name}" xmlns="http://www.w3.org/2000/svg"><svg`)}</g></svg>`
            : `<svg xmlns="http://www.w3.org/2000/svg" width="${wrapped.width}" height="${wrapped.height}">${wrapped.src}</svg>`;
        fs.writeFileSync(file, final);
        console.info(`\x1B[32m%s\x1B[0m`, `[preprocessed]:`, file);
    }
}
function wrapIcon(source, name) {
    const src = source.slice(Math.max(0, source.indexOf(START)));
    const attributes = src.slice(0, Math.max(0, src.indexOf(`>`)));
    if (!(attributes === null || attributes === void 0 ? void 0 : attributes.includes(WIDTH_SEARCH)) || !attributes.includes(HEIGHT_SEARCH)) {
        return src;
    }
    const indexOfWidth = attributes.indexOf(WIDTH_SEARCH);
    const indexOfHeight = attributes.indexOf(HEIGHT_SEARCH);
    const widthOffset = indexOfWidth + WIDTH_SEARCH.length;
    const heightOffset = indexOfHeight + HEIGHT_SEARCH.length;
    const widthString = attributes.slice(widthOffset, attributes.indexOf(`"`, widthOffset));
    const heightString = attributes.slice(heightOffset, attributes.indexOf(`"`, heightOffset));
    if (!heightString ||
        !widthString ||
        widthString.includes(`%`) ||
        heightString.includes(`%`)) {
        return src.replace(START, `<svg id="${name}"`);
    }
    const width = parseInt(widthString, 10);
    const height = parseInt(heightString, 10);
    const emWidth = width / 16;
    const emHeight = height / 16;
    return {
        width: `${emWidth}em`,
        height: `${emHeight}em`,
        src: `
        <g id="${name}" xmlns="http://www.w3.org/2000/svg">
            <svg x="50%" y="50%" width="${emWidth}em" height="${emHeight}em" overflow="visible" viewBox="0 0 ${width} ${height}">
                <svg x="${-width / 2}" y="${-height / 2}">${src}</svg>
            </svg>
        </g>`.trim(),
    };
}
/**
 * @deprecated:
 * use @{link tuiProcessIcons}
 */
const processIcons = tuiProcessIcons;

/**
 * Generated bundle index. Do not edit.
 */

export { processIcons, tuiConvertAllCompileFileToAllFile, tuiPostPrettierFormat, tuiPrepareAllToCompileFile, tuiProcessIcons, tuiRollupSvgo };
//# sourceMappingURL=taiga-ui-icons-scripts.js.map
