import * as i0 from '@angular/core';
import { InjectionToken, Directive, Optional, Inject, Attribute, ElementRef, Injectable, NgModule, inject } from '@angular/core';
import * as i1 from 'rxjs';
import { Observable } from 'rxjs';
import { share } from 'rxjs/operators';
import { WINDOW } from '@ng-web-apis/common';

const INTERSECTION_ROOT = new InjectionToken('Root element for IntersectionObserver');

const INTERSECTION_ROOT_MARGIN_DEFAULT = '0px 0px 0px 0px';
const INTERSECTION_ROOT_MARGIN = new InjectionToken('rootMargin for IntersectionObserver', {
    providedIn: 'root',
    factory: () => INTERSECTION_ROOT_MARGIN_DEFAULT,
});

function rootMarginFactory(rootMargin) {
    return rootMargin || INTERSECTION_ROOT_MARGIN_DEFAULT;
}

const INTERSECTION_THRESHOLD_DEFAULT = 0;
const INTERSECTION_THRESHOLD = new InjectionToken('threshold for IntersectionObserver', {
    providedIn: 'root',
    factory: () => INTERSECTION_THRESHOLD_DEFAULT,
});

function thresholdFactory(threshold) {
    return (threshold === null || threshold === void 0 ? void 0 : threshold.split(',').map(parseFloat)) || INTERSECTION_THRESHOLD_DEFAULT;
}

class IntersectionObserverDirective extends IntersectionObserver {
    constructor(root, rootMargin, threshold) {
        super(entries => {
            this.callbacks.forEach((callback, element) => {
                const filtered = entries.filter(({ target }) => target === element);
                return filtered.length && callback(filtered, this);
            });
        }, {
            root: root && root.nativeElement,
            rootMargin: rootMarginFactory(rootMargin),
            threshold: thresholdFactory(threshold),
        });
        this.callbacks = new Map();
    }
    observe(target, callback = () => { }) {
        super.observe(target);
        this.callbacks.set(target, callback);
    }
    unobserve(target) {
        super.unobserve(target);
        this.callbacks.delete(target);
    }
    ngOnDestroy() {
        this.disconnect();
    }
}
/** @nocollapse */ IntersectionObserverDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserverDirective, deps: [{ token: INTERSECTION_ROOT, optional: true }, { token: 'waIntersectionRootMargin', attribute: true }, { token: 'waIntersectionThreshold', attribute: true }], target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ IntersectionObserverDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: IntersectionObserverDirective, selector: "[waIntersectionObserver]", exportAs: ["IntersectionObserver"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserverDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[waIntersectionObserver]',
                    exportAs: 'IntersectionObserver',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [INTERSECTION_ROOT]
                }] }, { type: undefined, decorators: [{
                    type: Attribute,
                    args: ['waIntersectionRootMargin']
                }] }, { type: undefined, decorators: [{
                    type: Attribute,
                    args: ['waIntersectionThreshold']
                }] }]; } });

class IntersectionObserveeService extends Observable {
    constructor({ nativeElement }, observer) {
        super(subscriber => {
            observer.observe(nativeElement, entries => {
                subscriber.next(entries);
            });
            return () => {
                observer.unobserve(nativeElement);
            };
        });
        return this.pipe(share());
    }
}
/** @nocollapse */ IntersectionObserveeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserveeService, deps: [{ token: ElementRef }, { token: IntersectionObserverDirective }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ IntersectionObserveeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserveeService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserveeService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: IntersectionObserverDirective, decorators: [{
                    type: Inject,
                    args: [IntersectionObserverDirective]
                }] }]; } });

class IntersectionObserveeDirective {
    constructor(waIntersectionObservee) {
        this.waIntersectionObservee = waIntersectionObservee;
    }
}
/** @nocollapse */ IntersectionObserveeDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserveeDirective, deps: [{ token: IntersectionObserveeService }], target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ IntersectionObserveeDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: IntersectionObserveeDirective, selector: "[waIntersectionObservee]", outputs: { waIntersectionObservee: "waIntersectionObservee" }, providers: [IntersectionObserveeService], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserveeDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[waIntersectionObservee]',
                    outputs: ['waIntersectionObservee'],
                    providers: [IntersectionObserveeService],
                }]
        }], ctorParameters: function () { return [{ type: i1.Observable, decorators: [{
                    type: Inject,
                    args: [IntersectionObserveeService]
                }] }]; } });

class IntersectionRootDirective {
}
/** @nocollapse */ IntersectionRootDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionRootDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ IntersectionRootDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: IntersectionRootDirective, selector: "[waIntersectionRoot]", providers: [
        {
            provide: INTERSECTION_ROOT,
            useExisting: ElementRef,
        },
    ], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionRootDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[waIntersectionRoot]',
                    providers: [
                        {
                            provide: INTERSECTION_ROOT,
                            useExisting: ElementRef,
                        },
                    ],
                }]
        }] });

class IntersectionObserverModule {
}
/** @nocollapse */ IntersectionObserverModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserverModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ IntersectionObserverModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserverModule, declarations: [IntersectionObserverDirective,
        IntersectionObserveeDirective,
        IntersectionRootDirective], exports: [IntersectionObserverDirective,
        IntersectionObserveeDirective,
        IntersectionRootDirective] });
/** @nocollapse */ IntersectionObserverModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserverModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserverModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        IntersectionObserverDirective,
                        IntersectionObserveeDirective,
                        IntersectionRootDirective,
                    ],
                    exports: [
                        IntersectionObserverDirective,
                        IntersectionObserveeDirective,
                        IntersectionRootDirective,
                    ],
                }]
        }] });

const INTERSECTION_OBSERVER_SUPPORT = new InjectionToken('Intersection Observer API support', {
    providedIn: 'root',
    factory: () => !!inject(WINDOW).IntersectionObserver,
});

class IntersectionObserverService extends Observable {
    constructor({ nativeElement }, support, rootMargin, threshold, root) {
        super(subscriber => {
            if (!support) {
                subscriber.error('IntersectionObserver is not supported in your browser');
                return;
            }
            const observer = new IntersectionObserver(entries => {
                subscriber.next(entries);
            }, {
                root: root && root.nativeElement,
                rootMargin,
                threshold,
            });
            observer.observe(nativeElement);
            return () => {
                observer.disconnect();
            };
        });
        return this.pipe(share());
    }
}
/** @nocollapse */ IntersectionObserverService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserverService, deps: [{ token: ElementRef }, { token: INTERSECTION_OBSERVER_SUPPORT }, { token: INTERSECTION_ROOT_MARGIN }, { token: INTERSECTION_THRESHOLD }, { token: INTERSECTION_ROOT, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ IntersectionObserverService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserverService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IntersectionObserverService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [INTERSECTION_OBSERVER_SUPPORT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [INTERSECTION_ROOT_MARGIN]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [INTERSECTION_THRESHOLD]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [INTERSECTION_ROOT]
                }] }]; } });

/**
 * Public API Surface of @ng-web-apis/intersection-observer
 */

/**
 * Generated bundle index. Do not edit.
 */

export { INTERSECTION_OBSERVER_SUPPORT, INTERSECTION_ROOT, INTERSECTION_ROOT_MARGIN, INTERSECTION_ROOT_MARGIN_DEFAULT, INTERSECTION_THRESHOLD, INTERSECTION_THRESHOLD_DEFAULT, IntersectionObserveeDirective, IntersectionObserveeService, IntersectionObserverDirective, IntersectionObserverModule, IntersectionObserverService, IntersectionRootDirective };
//# sourceMappingURL=ng-web-apis-intersection-observer.js.map
