import { EVENT_MANAGER_PLUGINS } from '@angular/platform-browser';
import * as i0 from '@angular/core';
import { Injectable, NgModule, Inject } from '@angular/core';
import { EMPTY, concat, defer } from 'rxjs';
import { takeWhile } from 'rxjs/operators';

function dasharize(camel) {
    return camel.replace(/[a-z][A-Z]/g, letterLetter => {
        return `${letterLetter[0]}-${letterLetter[1].toLowerCase()}`;
    });
}

class AbstractEventPlugin {
    supports(event) {
        return event.includes(this.modifier);
    }
    /** This is not used in Ivy anymore */
    addGlobalEventListener() {
        return () => { };
    }
    unwrap(event) {
        return event
            .split('.')
            .filter(v => !this.modifier.includes(v))
            .join('.');
    }
}

class BindEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = '$';
    }
    addEventListener(element, event) {
        element[event] = element[event] || EMPTY;
        const method = this.getMethod(element, event);
        const zone$ = this.manager.getZone().onStable;
        const sub = concat(zone$.pipe(takeWhile(() => element[event] === EMPTY)), defer(() => element[event])).subscribe(method);
        return () => sub.unsubscribe();
    }
    getMethod(element, event) {
        const [, key, value, unit = ''] = event.split('.');
        if (event.endsWith('.attr')) {
            return v => v === null
                ? element.removeAttribute(key)
                : element.setAttribute(key, String(v));
        }
        if (key === 'class') {
            return v => element.classList.toggle(value, !!v);
        }
        if (key === 'style') {
            return v => element.style.setProperty(dasharize(value), `${v}${unit}`);
        }
        return v => (element[key] = v);
    }
}
/** @nocollapse */ BindEventPlugin.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BindEventPlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ BindEventPlugin.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BindEventPlugin });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BindEventPlugin, decorators: [{
            type: Injectable
        }] });

class OptionsEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = 'capture.once.passive';
    }
    supports(event) {
        return event.includes('.') && !this.unwrap(event).includes('.');
    }
    addEventListener(element, event, handler) {
        element.addEventListener(this.unwrap(event), handler, {
            once: event.includes('.once'),
            passive: event.includes('.passive'),
            capture: event.includes('.capture'),
        });
        return () => element.removeEventListener(this.unwrap(event), handler);
    }
}
/** @nocollapse */ OptionsEventPlugin.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: OptionsEventPlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ OptionsEventPlugin.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: OptionsEventPlugin });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: OptionsEventPlugin, decorators: [{
            type: Injectable
        }] });

class PreventEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = '.prevent';
    }
    addEventListener(element, event, handler) {
        const wrapped = (event) => {
            event.preventDefault();
            handler(event);
        };
        return this.manager.addEventListener(element, this.unwrap(event), wrapped);
    }
}
/** @nocollapse */ PreventEventPlugin.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PreventEventPlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ PreventEventPlugin.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PreventEventPlugin });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PreventEventPlugin, decorators: [{
            type: Injectable
        }] });

class SelfEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = '.self';
    }
    addEventListener(element, event, handler) {
        const wrapped = (event) => {
            if (event.target === event.currentTarget) {
                handler(event);
            }
        };
        return this.manager.addEventListener(element, this.unwrap(event), wrapped);
    }
}
/** @nocollapse */ SelfEventPlugin.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: SelfEventPlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ SelfEventPlugin.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: SelfEventPlugin });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: SelfEventPlugin, decorators: [{
            type: Injectable
        }] });

class SilentEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = '.silent';
    }
    addEventListener(element, event, handler) {
        SilentEventPlugin.ngZone = this.manager.getZone();
        return SilentEventPlugin.ngZone.runOutsideAngular(() => this.manager.addEventListener(element, this.unwrap(event), handler));
    }
}
/** @nocollapse */ SilentEventPlugin.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: SilentEventPlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ SilentEventPlugin.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: SilentEventPlugin });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: SilentEventPlugin, decorators: [{
            type: Injectable
        }] });

class StopEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = '.stop';
    }
    addEventListener(element, event, handler) {
        const wrapped = (event) => {
            event.stopPropagation();
            handler(event);
        };
        return this.manager.addEventListener(element, this.unwrap(event), wrapped);
    }
}
/** @nocollapse */ StopEventPlugin.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: StopEventPlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ StopEventPlugin.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: StopEventPlugin });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: StopEventPlugin, decorators: [{
            type: Injectable
        }] });

/**
 * TODO: Remove in v4.0.0
 * @deprecated
 */
class ZoneEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = '.init';
    }
    addEventListener() {
        console.warn('.init plugin is no longer necessary as of v3.1.0');
        return () => { };
    }
}
/** @nocollapse */ ZoneEventPlugin.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ZoneEventPlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ ZoneEventPlugin.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ZoneEventPlugin });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ZoneEventPlugin, decorators: [{
            type: Injectable
        }] });

const PLUGINS = [
    SilentEventPlugin,
    BindEventPlugin,
    OptionsEventPlugin,
    PreventEventPlugin,
    SelfEventPlugin,
    StopEventPlugin,
    ZoneEventPlugin,
];
const NG_EVENT_PLUGINS = PLUGINS.map(useClass => ({
    provide: EVENT_MANAGER_PLUGINS,
    multi: true,
    useClass,
}));

function shouldCall(predicate) {
    return (_target, _key, desc) => {
        const { value } = desc;
        desc.value = function (...args) {
            if (!predicate.apply(this, args)) {
                return;
            }
            if (SilentEventPlugin.ngZone) {
                SilentEventPlugin.ngZone.run(() => value.apply(this, args));
            }
            else {
                value.apply(this, args);
            }
        };
    };
}

function asCallable(a) {
    return a;
}

class EventPluginsModule {
    constructor([plugin]) {
        console.assert(!(plugin instanceof SilentEventPlugin) || EventPluginsModule.initialized, 'EventPluginsModule must come after BrowserModule in imports');
        EventPluginsModule.initialized = true;
    }
}
EventPluginsModule.initialized = false;
/** @nocollapse */ EventPluginsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: EventPluginsModule, deps: [{ token: EVENT_MANAGER_PLUGINS }], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ EventPluginsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: EventPluginsModule });
/** @nocollapse */ EventPluginsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: EventPluginsModule, providers: NG_EVENT_PLUGINS });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: EventPluginsModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: NG_EVENT_PLUGINS,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [EVENT_MANAGER_PLUGINS]
                }] }]; } });

/**
 * Public API Surface of @tinkoff/ng-event-plugins
 */

/**
 * Generated bundle index. Do not edit.
 */

export { BindEventPlugin, EventPluginsModule, NG_EVENT_PLUGINS, OptionsEventPlugin, PreventEventPlugin, SilentEventPlugin, StopEventPlugin, ZoneEventPlugin, asCallable, shouldCall };
//# sourceMappingURL=tinkoff-ng-event-plugins.js.map
