{"ast":null,"code":"import { TuiDay, DATE_FILLER_LENGTH, DATE_RANGE_FILLER_LENGTH, TuiDayRange, RANGE_SEPARATOR_CHAR, tuiIsString, tuiAssert, CHAR_NO_BREAK_SPACE, CHAR_EN_DASH } from '@taiga-ui/cdk';\nimport { MAX_TIME_VALUES, DATE_TIME_SEPARATOR } from '@taiga-ui/kit/constants';\nimport { TUI_DIGIT_REGEXP } from '@taiga-ui/core';\nfunction tuiNormalizeDateValue(dateValue, {\n  value,\n  min,\n  max,\n  dateFormat,\n  dateSeparator\n}) {\n  return value && value.toString(dateFormat, dateSeparator) === dateValue ? dateValue : TuiDay.normalizeParse(dateValue, dateFormat).dayLimit(min, max).toString(dateFormat, dateSeparator);\n}\nfunction tuiCreateAutoCorrectedDatePipe(config) {\n  return value => {\n    if (value.length !== DATE_FILLER_LENGTH) {\n      return {\n        value\n      };\n    }\n    return {\n      value: tuiNormalizeDateValue(value, config)\n    };\n  };\n}\nfunction parseWithLimit(value, config) {\n  return TuiDay.normalizeParse(value.slice(0, DATE_FILLER_LENGTH), config.dateFormat).dayLimit(config.min, config.max);\n}\nfunction processRawValue(value, config) {\n  const {\n    dateFormat,\n    dateSeparator\n  } = config;\n  switch (value.length) {\n    case DATE_FILLER_LENGTH:\n      return parseWithLimit(value, config).toString(dateFormat, dateSeparator);\n    case DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length:\n      return parseWithLimit(value, config).toString(dateFormat, dateSeparator) + RANGE_SEPARATOR_CHAR;\n    case DATE_RANGE_FILLER_LENGTH:\n      return config.value && config.value.toString(dateFormat, dateSeparator) === value ? value : TuiDayRange.sort(parseWithLimit(value.slice(0, DATE_FILLER_LENGTH), config), parseWithLimit(value.slice(DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length), config)).toString(dateFormat, dateSeparator);\n    default:\n      return value;\n  }\n}\n/**\n * Normalizes date in formatted string\n *\n * Normalizes when:\n *\n * 1. It is a single date\n * 2. It is a single date and a separator\n * 3. It is two dates and a separator between them\n *\n * In **other** cases, the value does not change.\n *\n * @param config with min and max date\n * @return mask pipe handler that handles `min` and `max`\n */\nfunction tuiCreateAutoCorrectedDateRangePipe(config) {\n  return value => ({\n    value: processRawValue(value, config)\n  });\n}\n\n/**\n * Adjusts the entered time by omitting only suitable values for hours and minutes\n * @returns time as a string\n */\nfunction tuiCreateAutoCorrectedTimePipe(timeMode = `HH:MM`, maxValues = {}) {\n  const timeFormatArray = [`HH`, `MM`, `SS`, `MS`];\n  const safeValues = Object.assign(Object.assign({}, MAX_TIME_VALUES), maxValues);\n  return conformedValue => {\n    const indexesOfPipedChars = [];\n    const conformedValueArr = conformedValue.split(``);\n    timeFormatArray.forEach(format => {\n      const position = timeMode.indexOf(format);\n      const maxFirstDigit = parseInt(String(safeValues[format]).slice(0, 1), 10);\n      if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {\n        conformedValueArr[position + 1] = conformedValueArr[position];\n        conformedValueArr[position] = `0`;\n        indexesOfPipedChars.push(position);\n      }\n    });\n    const isInvalid = timeFormatArray.some(format => parseInt(conformedValue.slice(timeMode.indexOf(format), 2), 10) > safeValues[format]);\n    return isInvalid ? false : {\n      value: conformedValueArr.join(``),\n      indexesOfPipedChars\n    };\n  };\n}\nfunction tuiCreateAutoCorrectedDateTimePipe(configs) {\n  const timePipe = tuiCreateAutoCorrectedTimePipe(configs.timeMode);\n  return value => {\n    if (value.length < DATE_FILLER_LENGTH) {\n      return {\n        value\n      };\n    }\n    const [date, time] = value.split(DATE_TIME_SEPARATOR);\n    const formattedDate = tuiNormalizeDateValue(date, configs);\n    if (!time) {\n      return {\n        value: formattedDate\n      };\n    }\n    const pipedTime = timePipe(time, {});\n    if (!pipedTime || tuiIsString(pipedTime)) {\n      return false;\n    }\n    return {\n      value: `${formattedDate}${DATE_TIME_SEPARATOR}${pipedTime.value}`,\n      indexesOfPipedChars: pipedTime.indexesOfPipedChars ? pipedTime.indexesOfPipedChars.map(i => i + date.length + 2) : undefined\n    };\n  };\n}\nconst TWO_DIGITS = new Array(2).fill(TUI_DIGIT_REGEXP);\nconst FOUR_DIGITS = new Array(4).fill(TUI_DIGIT_REGEXP);\nfunction tuiCreateDateMask(mode, separator) {\n  ngDevMode && tuiAssert.assert(separator.length === 1, `Separator should consist of only 1 symbol`);\n  switch (mode) {\n    case `YMD`:\n      return [...FOUR_DIGITS, separator, ...TWO_DIGITS, separator, ...TWO_DIGITS];\n    case `MDY`:\n    case `DMY`:\n    default:\n      return [...TWO_DIGITS, separator, ...TWO_DIGITS, separator, ...FOUR_DIGITS];\n  }\n}\nfunction tuiCreateDateRangeMask(dateMode, dateSeparator) {\n  ngDevMode && tuiAssert.assert(dateSeparator.length === 1, `Separator should consist of only 1 symbol`);\n  const dateMask = tuiCreateDateMask(dateMode, dateSeparator);\n  return [...dateMask, CHAR_NO_BREAK_SPACE, CHAR_EN_DASH, CHAR_NO_BREAK_SPACE, ...dateMask];\n}\nfunction tuiCreateTimePartMask(maxPartValue, prefix) {\n  const {\n    length\n  } = String(maxPartValue);\n  const regExp = new Array(length).fill(TUI_DIGIT_REGEXP);\n  if (prefix) {\n    regExp.unshift(prefix);\n  }\n  return regExp;\n}\nfunction tuiCreateTimeMask(mode, maxValues = {}) {\n  const {\n    HH,\n    MM,\n    SS,\n    MS\n  } = Object.assign(Object.assign({}, MAX_TIME_VALUES), maxValues);\n  return [...tuiCreateTimePartMask(HH), ...tuiCreateTimePartMask(MM, `:`), ...(mode.includes(`HH:MM:SS`) ? tuiCreateTimePartMask(SS, `:`) : []), ...(mode === `HH:MM:SS.MSS` ? tuiCreateTimePartMask(MS, `.`) : [])];\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiCreateAutoCorrectedDatePipe, tuiCreateAutoCorrectedDateRangePipe, tuiCreateAutoCorrectedDateTimePipe, tuiCreateAutoCorrectedTimePipe, tuiCreateDateMask, tuiCreateDateRangeMask, tuiCreateTimeMask, tuiNormalizeDateValue };","map":{"version":3,"names":["TuiDay","DATE_FILLER_LENGTH","DATE_RANGE_FILLER_LENGTH","TuiDayRange","RANGE_SEPARATOR_CHAR","tuiIsString","tuiAssert","CHAR_NO_BREAK_SPACE","CHAR_EN_DASH","MAX_TIME_VALUES","DATE_TIME_SEPARATOR","TUI_DIGIT_REGEXP","tuiNormalizeDateValue","dateValue","value","min","max","dateFormat","dateSeparator","toString","normalizeParse","dayLimit","tuiCreateAutoCorrectedDatePipe","config","length","parseWithLimit","slice","processRawValue","sort","tuiCreateAutoCorrectedDateRangePipe","tuiCreateAutoCorrectedTimePipe","timeMode","maxValues","timeFormatArray","safeValues","Object","assign","conformedValue","indexesOfPipedChars","conformedValueArr","split","forEach","format","position","indexOf","maxFirstDigit","parseInt","String","push","isInvalid","some","join","tuiCreateAutoCorrectedDateTimePipe","configs","timePipe","date","time","formattedDate","pipedTime","map","i","undefined","TWO_DIGITS","Array","fill","FOUR_DIGITS","tuiCreateDateMask","mode","separator","ngDevMode","assert","tuiCreateDateRangeMask","dateMode","dateMask","tuiCreateTimePartMask","maxPartValue","prefix","regExp","unshift","tuiCreateTimeMask","HH","MM","SS","MS","includes"],"sources":["C:/Users/denis/PycharmProjects/example_project/frontend/node_modules/@taiga-ui/kit/fesm2015/taiga-ui-kit-utils-mask.js"],"sourcesContent":["import { TuiDay, DATE_FILLER_LENGTH, DATE_RANGE_FILLER_LENGTH, TuiDayRange, RANGE_SEPARATOR_CHAR, tuiIsString, tuiAssert, CHAR_NO_BREAK_SPACE, CHAR_EN_DASH } from '@taiga-ui/cdk';\nimport { MAX_TIME_VALUES, DATE_TIME_SEPARATOR } from '@taiga-ui/kit/constants';\nimport { TUI_DIGIT_REGEXP } from '@taiga-ui/core';\n\nfunction tuiNormalizeDateValue(dateValue, { value, min, max, dateFormat, dateSeparator }) {\n    return value && value.toString(dateFormat, dateSeparator) === dateValue\n        ? dateValue\n        : TuiDay.normalizeParse(dateValue, dateFormat)\n            .dayLimit(min, max)\n            .toString(dateFormat, dateSeparator);\n}\nfunction tuiCreateAutoCorrectedDatePipe(config) {\n    return value => {\n        if (value.length !== DATE_FILLER_LENGTH) {\n            return { value };\n        }\n        return {\n            value: tuiNormalizeDateValue(value, config),\n        };\n    };\n}\n\nfunction parseWithLimit(value, config) {\n    return TuiDay.normalizeParse(value.slice(0, DATE_FILLER_LENGTH), config.dateFormat).dayLimit(config.min, config.max);\n}\nfunction processRawValue(value, config) {\n    const { dateFormat, dateSeparator } = config;\n    switch (value.length) {\n        case DATE_FILLER_LENGTH:\n            return parseWithLimit(value, config).toString(dateFormat, dateSeparator);\n        case DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length:\n            return (parseWithLimit(value, config).toString(dateFormat, dateSeparator) +\n                RANGE_SEPARATOR_CHAR);\n        case DATE_RANGE_FILLER_LENGTH:\n            return config.value &&\n                config.value.toString(dateFormat, dateSeparator) === value\n                ? value\n                : TuiDayRange.sort(parseWithLimit(value.slice(0, DATE_FILLER_LENGTH), config), parseWithLimit(value.slice(DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length), config)).toString(dateFormat, dateSeparator);\n        default:\n            return value;\n    }\n}\n/**\n * Normalizes date in formatted string\n *\n * Normalizes when:\n *\n * 1. It is a single date\n * 2. It is a single date and a separator\n * 3. It is two dates and a separator between them\n *\n * In **other** cases, the value does not change.\n *\n * @param config with min and max date\n * @return mask pipe handler that handles `min` and `max`\n */\nfunction tuiCreateAutoCorrectedDateRangePipe(config) {\n    return value => ({ value: processRawValue(value, config) });\n}\n\n/**\n * Adjusts the entered time by omitting only suitable values for hours and minutes\n * @returns time as a string\n */\nfunction tuiCreateAutoCorrectedTimePipe(timeMode = `HH:MM`, maxValues = {}) {\n    const timeFormatArray = [`HH`, `MM`, `SS`, `MS`];\n    const safeValues = Object.assign(Object.assign({}, MAX_TIME_VALUES), maxValues);\n    return conformedValue => {\n        const indexesOfPipedChars = [];\n        const conformedValueArr = conformedValue.split(``);\n        timeFormatArray.forEach(format => {\n            const position = timeMode.indexOf(format);\n            const maxFirstDigit = parseInt(String(safeValues[format]).slice(0, 1), 10);\n            if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {\n                conformedValueArr[position + 1] = conformedValueArr[position];\n                conformedValueArr[position] = `0`;\n                indexesOfPipedChars.push(position);\n            }\n        });\n        const isInvalid = timeFormatArray.some(format => parseInt(conformedValue.slice(timeMode.indexOf(format), 2), 10) >\n            safeValues[format]);\n        return isInvalid\n            ? false\n            : {\n                value: conformedValueArr.join(``),\n                indexesOfPipedChars,\n            };\n    };\n}\n\nfunction tuiCreateAutoCorrectedDateTimePipe(configs) {\n    const timePipe = tuiCreateAutoCorrectedTimePipe(configs.timeMode);\n    return value => {\n        if (value.length < DATE_FILLER_LENGTH) {\n            return { value };\n        }\n        const [date, time] = value.split(DATE_TIME_SEPARATOR);\n        const formattedDate = tuiNormalizeDateValue(date, configs);\n        if (!time) {\n            return { value: formattedDate };\n        }\n        const pipedTime = timePipe(time, {});\n        if (!pipedTime || tuiIsString(pipedTime)) {\n            return false;\n        }\n        return {\n            value: `${formattedDate}${DATE_TIME_SEPARATOR}${pipedTime.value}`,\n            indexesOfPipedChars: pipedTime.indexesOfPipedChars\n                ? pipedTime.indexesOfPipedChars.map(i => i + date.length + 2)\n                : undefined,\n        };\n    };\n}\n\nconst TWO_DIGITS = new Array(2).fill(TUI_DIGIT_REGEXP);\nconst FOUR_DIGITS = new Array(4).fill(TUI_DIGIT_REGEXP);\nfunction tuiCreateDateMask(mode, separator) {\n    ngDevMode &&\n        tuiAssert.assert(separator.length === 1, `Separator should consist of only 1 symbol`);\n    switch (mode) {\n        case `YMD`:\n            return [...FOUR_DIGITS, separator, ...TWO_DIGITS, separator, ...TWO_DIGITS];\n        case `MDY`:\n        case `DMY`:\n        default:\n            return [...TWO_DIGITS, separator, ...TWO_DIGITS, separator, ...FOUR_DIGITS];\n    }\n}\n\nfunction tuiCreateDateRangeMask(dateMode, dateSeparator) {\n    ngDevMode &&\n        tuiAssert.assert(dateSeparator.length === 1, `Separator should consist of only 1 symbol`);\n    const dateMask = tuiCreateDateMask(dateMode, dateSeparator);\n    return [\n        ...dateMask,\n        CHAR_NO_BREAK_SPACE,\n        CHAR_EN_DASH,\n        CHAR_NO_BREAK_SPACE,\n        ...dateMask,\n    ];\n}\n\nfunction tuiCreateTimePartMask(maxPartValue, prefix) {\n    const { length } = String(maxPartValue);\n    const regExp = new Array(length).fill(TUI_DIGIT_REGEXP);\n    if (prefix) {\n        regExp.unshift(prefix);\n    }\n    return regExp;\n}\nfunction tuiCreateTimeMask(mode, maxValues = {}) {\n    const { HH, MM, SS, MS } = Object.assign(Object.assign({}, MAX_TIME_VALUES), maxValues);\n    return [\n        ...tuiCreateTimePartMask(HH),\n        ...tuiCreateTimePartMask(MM, `:`),\n        ...(mode.includes(`HH:MM:SS`) ? tuiCreateTimePartMask(SS, `:`) : []),\n        ...(mode === `HH:MM:SS.MSS` ? tuiCreateTimePartMask(MS, `.`) : []),\n    ];\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiCreateAutoCorrectedDatePipe, tuiCreateAutoCorrectedDateRangePipe, tuiCreateAutoCorrectedDateTimePipe, tuiCreateAutoCorrectedTimePipe, tuiCreateDateMask, tuiCreateDateRangeMask, tuiCreateTimeMask, tuiNormalizeDateValue };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}