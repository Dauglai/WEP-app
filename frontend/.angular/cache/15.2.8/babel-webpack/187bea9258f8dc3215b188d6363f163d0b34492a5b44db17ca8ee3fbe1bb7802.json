{"ast":null,"code":"import { tuiAssert, tuiIsSafari, CHAR_HYPHEN, tuiIsNativeFocused, tuiGetDocumentOrShadowRoot, CHAR_NO_BREAK_SPACE, CHAR_EN_DASH } from '@taiga-ui/cdk';\nimport { MASK_CARET_TRAP, TUI_DIGIT_REGEXP, TUI_NON_DIGITS_REGEXP, TUI_LEADING_ZEROES_REGEXP, TUI_DECIMAL_SYMBOLS } from '@taiga-ui/core/constants';\nimport { tuiOtherDecimalSymbol } from '@taiga-ui/core/utils/format';\n\n/**\n * Used to finish a number with zeros to a given precision\n */\nfunction tuiCreateAutoCorrectedNumberPipe(decimalLimit = 0, decimalSymbol = `,`, thousandSymbol = CHAR_NO_BREAK_SPACE, nativeInput, allowNegative, isIOS = false) {\n  ngDevMode && tuiAssert.assert(decimalLimit >= 0);\n  // Guess for which browser I need this :)\n  let previousCaret = -1;\n  const unlucky = !!nativeInput && tuiIsSafari(nativeInput) || isIOS;\n  if (nativeInput && unlucky) {\n    nativeInput.addEventListener(`beforeinput`, () => {\n      previousCaret = nativeInput.selectionStart || 0;\n    });\n  }\n  return (conformedValue, config) => {\n    // Removing everything by selecting and pressing '-'\n    if (!conformedValue && config.rawValue === CHAR_HYPHEN && allowNegative) {\n      return CHAR_HYPHEN;\n    }\n    // remove these hacks after text mask library has changed\n    if (nativeInput && unlucky && tuiIsNativeFocused(nativeInput)) {\n      const caret = calculateSafariCaret(config.previousConformedValue, conformedValue, previousCaret);\n      setTimeout(() => {\n        nativeInput.setSelectionRange(caret, caret);\n      });\n    }\n    if (nativeInput && nativeInput.ownerDocument !== tuiGetDocumentOrShadowRoot(nativeInput) && tuiIsNativeFocused(nativeInput) && config.currentCaretPosition) {\n      const realCaretPosition = config.currentCaretPosition + calculateCaretGap(config.previousConformedValue, conformedValue, thousandSymbol);\n      setTimeout(() => {\n        nativeInput.setSelectionRange(realCaretPosition, realCaretPosition);\n      });\n    }\n    if (conformedValue === `` || !decimalLimit || !Number.isInteger(decimalLimit)) {\n      return {\n        value: conformedValue\n      };\n    }\n    const withDecimalSymbol = addDecimalSymbolIfNeeded(conformedValue, decimalSymbol);\n    const decimalPart = withDecimalSymbol.split(decimalSymbol)[1];\n    const zeroPaddingSize = decimalLimit - decimalPart.length;\n    return {\n      value: withDecimalSymbol + `0`.repeat(zeroPaddingSize)\n    };\n  };\n}\nfunction addDecimalSymbolIfNeeded(value, decimalSymbol = `,`) {\n  return !value.includes(decimalSymbol) ? value + decimalSymbol : value;\n}\nfunction calculateSafariCaret(previousValue = ``, current, previousCaret, decimalSymbol = `,`) {\n  const tailRegex = new RegExp(`${decimalSymbol}.+`);\n  const previousWithoutTail = previousValue.replace(tailRegex, ``);\n  const currentWithoutTail = current.replace(tailRegex, ``);\n  const pasteOrCutOperation = Math.abs(previousWithoutTail.length - currentWithoutTail.length) > 2;\n  if (pasteOrCutOperation) {\n    return current.length;\n  }\n  if (previousValue.length === current.length) {\n    if (previousValue.indexOf(decimalSymbol) <= previousCaret) {\n      return calculateChangedTailIndex(previousValue, current);\n    }\n    return previousWithoutTail === currentWithoutTail ? previousCaret - 1 : previousCaret + 1;\n  }\n  if (previousValue.length === 0) {\n    return 1;\n  }\n  const changeLength = current.length - previousValue.length;\n  return previousCaret + changeLength;\n}\nfunction calculateChangedTailIndex(previous, current) {\n  for (let i = 0; i < current.length; i++) {\n    if (previous[i] !== current[i]) {\n      return current[i] === `0` ? i : i + 1;\n    }\n  }\n  return current.length;\n}\nfunction calculateCaretGap(previousValue = ``, current, thousandSymbol) {\n  const pasteOrCutOperation = Math.abs(previousValue.length - current.length) > 2;\n  if (pasteOrCutOperation) {\n    return 0;\n  }\n  const wereSpaces = previousValue.split(thousandSymbol).length;\n  const nowSpaces = current.split(thousandSymbol).length;\n  return nowSpaces - wereSpaces;\n}\nconst ASSERTION = `Correction function must return single char or null`;\nfunction tuiCreateCorrectionMask(allowed, correctionHandler) {\n  return rawValue => {\n    const mask = rawValue.split(``).reduce((result, char, index) => {\n      const corrected = correctionHandler(char, index);\n      ngDevMode && tuiAssert.assert(corrected === null || corrected.length === 1, ASSERTION);\n      if (!allowed.test(char) && !corrected) {\n        return result;\n      }\n      if (allowed.test(char)) {\n        return [...result, allowed];\n      }\n      if (corrected) {\n        return [...result, corrected, MASK_CARET_TRAP];\n      }\n      return result;\n    }, []);\n    const lastIndex = mask.lastIndexOf(MASK_CARET_TRAP);\n    const filtered = mask.filter((item, index) => item !== MASK_CARET_TRAP || index === lastIndex);\n    return filtered.some(item => item !== allowed) ? [...filtered, allowed] : filtered;\n  };\n}\nconst NON_ZERO_DIGIT = /[1-9]/;\n/**\n * Adaptation for {@link https://github.com/text-mask/text-mask/tree/master/addons#createnumbermask `createNumberMask`}\n */\nfunction tuiCreateNumberMask({\n  allowDecimal = false,\n  decimalSymbol = `,`,\n  thousandSymbol = CHAR_NO_BREAK_SPACE,\n  autoCorrectDecimalSymbol = true,\n  decimalLimit = 2,\n  requireDecimal = false,\n  allowNegative = false,\n  integerLimit = 0\n} = {}) {\n  ngDevMode && tuiAssert.assert(decimalLimit >= 0);\n  ngDevMode && tuiAssert.assert(Number.isInteger(integerLimit));\n  ngDevMode && tuiAssert.assert(integerLimit >= 0);\n  // eslint-disable-next-line max-statements\n  return (rawValue, {\n    previousConformedValue\n  }) => {\n    if (previousConformedValue && requireDecimal) {\n      const conformedWithoutSeparator = rawValue.split(thousandSymbol).join(``);\n      const previousConformedValueWithoutDecimalSymbolAndSeparator = previousConformedValue.split(thousandSymbol).join(``).split(decimalSymbol).join(``);\n      // Forbid removal of decimal separator if decimal part is required\n      if (conformedWithoutSeparator === previousConformedValueWithoutDecimalSymbolAndSeparator) {\n        rawValue = previousConformedValue;\n      }\n    }\n    const isNegative = ((rawValue === null || rawValue === void 0 ? void 0 : rawValue.startsWith(CHAR_HYPHEN)) || (rawValue === null || rawValue === void 0 ? void 0 : rawValue.startsWith(CHAR_EN_DASH))) && allowNegative;\n    if (isDecimalSymbol(rawValue, decimalSymbol, autoCorrectDecimalSymbol) && allowDecimal) {\n      return [`0`, decimalSymbol, TUI_DIGIT_REGEXP];\n    }\n    if (isNegative) {\n      rawValue = rawValue.slice(1);\n    }\n    const decimalIndex = getDecimalSymbolIndex(rawValue, decimalSymbol, autoCorrectDecimalSymbol);\n    const hasDecimal = decimalIndex !== -1;\n    const integer = hasDecimal ? rawValue.slice(0, decimalIndex) : rawValue;\n    const thousandSeparators = integer.match(new RegExp(thousandSymbol, `g`)) || [];\n    const integerCapped = integerLimit ? integer.slice(0, integerLimit + thousandSeparators.length) : integer;\n    const integerCappedClean = integerCapped.replace(TUI_NON_DIGITS_REGEXP, ``);\n    const [leadingZerosMatch] = integerCappedClean.match(TUI_LEADING_ZEROES_REGEXP) || [``];\n    const leadingZerosAmount = leadingZerosMatch.length;\n    const integerCappedZerosClean = integerCappedClean.replace(/^0+(?!\\.|$)/, ``).trim();\n    const withSeparator = addThousandsSeparator(integerCappedZerosClean, thousandSymbol);\n    const mask = convertToMask(withSeparator);\n    if (hasDecimal && allowDecimal || requireDecimal) {\n      const fraction = hasDecimal ? convertToMask(rawValue.slice(decimalIndex + 1).replace(TUI_NON_DIGITS_REGEXP, ``)) : [];\n      const fractionCapped = decimalLimit ? fraction.slice(0, decimalLimit) : fraction;\n      if (rawValue[decimalIndex] !== tuiOtherDecimalSymbol(decimalSymbol)) {\n        mask.push(MASK_CARET_TRAP);\n      }\n      mask.push(decimalSymbol, MASK_CARET_TRAP, ...fractionCapped);\n      for (let i = 0; i < Math.min(decimalLimit - fractionCapped.length, 20); i++) {\n        mask.push(TUI_DIGIT_REGEXP);\n      }\n    }\n    const isOnlyZeroDigit = mask.length === 1 && integerCappedZerosClean === `0`;\n    if (isNegative) {\n      if (mask.length === 0) {\n        mask.push(TUI_DIGIT_REGEXP);\n      }\n      mask.unshift(CHAR_HYPHEN);\n    }\n    return preventLeadingZeroes(mask, isOnlyZeroDigit, leadingZerosAmount);\n  };\n}\nfunction preventLeadingZeroes(mask, isOnlyZeroDigit = false, leadingZerosAmount = 0) {\n  if (isOnlyZeroDigit || leadingZerosAmount === 0) {\n    return mask;\n  }\n  const firstDigitIndex = mask.indexOf(TUI_DIGIT_REGEXP);\n  if (firstDigitIndex === -1) {\n    return mask;\n  }\n  const secondMaskDigit = mask[firstDigitIndex + 1];\n  const isCaretTrap = secondMaskDigit === MASK_CARET_TRAP;\n  if (isCaretTrap && leadingZerosAmount === 1) {\n    return mask;\n  }\n  if (isCaretTrap) {\n    mask.unshift(NON_ZERO_DIGIT);\n    return mask;\n  }\n  mask[firstDigitIndex] = NON_ZERO_DIGIT;\n  return mask;\n}\nfunction getDecimalSymbolIndex(str, decimalSymbol, autoCorrectDecimalSymbol) {\n  if (!autoCorrectDecimalSymbol) {\n    return str.lastIndexOf(decimalSymbol);\n  }\n  return Math.max(str.lastIndexOf(decimalSymbol), str.lastIndexOf(tuiOtherDecimalSymbol(decimalSymbol)));\n}\nfunction isDecimalSymbol(str, decimalSymbol, autoCorrectDecimalSymbol) {\n  if (autoCorrectDecimalSymbol) {\n    return /^[,.]$/.test(str);\n  }\n  return str === decimalSymbol;\n}\nfunction convertToMask(strNumber) {\n  return strNumber.split(``).map(char => TUI_DIGIT_REGEXP.test(char) ? TUI_DIGIT_REGEXP : char);\n}\nfunction addThousandsSeparator(strNumber, thousandSymbol) {\n  return strNumber.length > 3 ?\n  // TODO: investigate to disallow potentially catastrophic exponential-time regular expressions.\n  // eslint-disable-next-line unicorn/no-unsafe-regex\n  strNumber.replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousandSymbol) : strNumber;\n}\nfunction tuiEnableAutoCorrectDecimalSymbol({\n  thousandSeparator\n}) {\n  return !TUI_DECIMAL_SYMBOLS.includes(thousandSeparator);\n}\nfunction tuiMaskedMoneyValueIsEmpty(value) {\n  switch (value) {\n    case ``:\n    case CHAR_HYPHEN:\n    case `,`:\n    case `${CHAR_HYPHEN},`:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction tuiMaskedNumberStringToNumber(value, decimalsSymbol, thousandSymbol) {\n  return parseFloat(value.split(thousandSymbol).join(``).split(decimalsSymbol).join(`.`));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiCreateAutoCorrectedNumberPipe, tuiCreateCorrectionMask, tuiCreateNumberMask, tuiEnableAutoCorrectDecimalSymbol, tuiMaskedMoneyValueIsEmpty, tuiMaskedNumberStringToNumber };","map":{"version":3,"names":["tuiAssert","tuiIsSafari","CHAR_HYPHEN","tuiIsNativeFocused","tuiGetDocumentOrShadowRoot","CHAR_NO_BREAK_SPACE","CHAR_EN_DASH","MASK_CARET_TRAP","TUI_DIGIT_REGEXP","TUI_NON_DIGITS_REGEXP","TUI_LEADING_ZEROES_REGEXP","TUI_DECIMAL_SYMBOLS","tuiOtherDecimalSymbol","tuiCreateAutoCorrectedNumberPipe","decimalLimit","decimalSymbol","thousandSymbol","nativeInput","allowNegative","isIOS","ngDevMode","assert","previousCaret","unlucky","addEventListener","selectionStart","conformedValue","config","rawValue","caret","calculateSafariCaret","previousConformedValue","setTimeout","setSelectionRange","ownerDocument","currentCaretPosition","realCaretPosition","calculateCaretGap","Number","isInteger","value","withDecimalSymbol","addDecimalSymbolIfNeeded","decimalPart","split","zeroPaddingSize","length","repeat","includes","previousValue","current","tailRegex","RegExp","previousWithoutTail","replace","currentWithoutTail","pasteOrCutOperation","Math","abs","indexOf","calculateChangedTailIndex","changeLength","previous","i","wereSpaces","nowSpaces","ASSERTION","tuiCreateCorrectionMask","allowed","correctionHandler","mask","reduce","result","char","index","corrected","test","lastIndex","lastIndexOf","filtered","filter","item","some","NON_ZERO_DIGIT","tuiCreateNumberMask","allowDecimal","autoCorrectDecimalSymbol","requireDecimal","integerLimit","conformedWithoutSeparator","join","previousConformedValueWithoutDecimalSymbolAndSeparator","isNegative","startsWith","isDecimalSymbol","slice","decimalIndex","getDecimalSymbolIndex","hasDecimal","integer","thousandSeparators","match","integerCapped","integerCappedClean","leadingZerosMatch","leadingZerosAmount","integerCappedZerosClean","trim","withSeparator","addThousandsSeparator","convertToMask","fraction","fractionCapped","push","min","isOnlyZeroDigit","unshift","preventLeadingZeroes","firstDigitIndex","secondMaskDigit","isCaretTrap","str","max","strNumber","map","tuiEnableAutoCorrectDecimalSymbol","thousandSeparator","tuiMaskedMoneyValueIsEmpty","tuiMaskedNumberStringToNumber","decimalsSymbol","parseFloat"],"sources":["C:/Users/denis/PycharmProjects/example_project/frontend/node_modules/@taiga-ui/core/fesm2015/taiga-ui-core-utils-mask.js"],"sourcesContent":["import { tuiAssert, tuiIsSafari, CHAR_HYPHEN, tuiIsNativeFocused, tuiGetDocumentOrShadowRoot, CHAR_NO_BREAK_SPACE, CHAR_EN_DASH } from '@taiga-ui/cdk';\nimport { MASK_CARET_TRAP, TUI_DIGIT_REGEXP, TUI_NON_DIGITS_REGEXP, TUI_LEADING_ZEROES_REGEXP, TUI_DECIMAL_SYMBOLS } from '@taiga-ui/core/constants';\nimport { tuiOtherDecimalSymbol } from '@taiga-ui/core/utils/format';\n\n/**\n * Used to finish a number with zeros to a given precision\n */\nfunction tuiCreateAutoCorrectedNumberPipe(decimalLimit = 0, decimalSymbol = `,`, thousandSymbol = CHAR_NO_BREAK_SPACE, nativeInput, allowNegative, isIOS = false) {\n    ngDevMode && tuiAssert.assert(decimalLimit >= 0);\n    // Guess for which browser I need this :)\n    let previousCaret = -1;\n    const unlucky = (!!nativeInput && tuiIsSafari(nativeInput)) || isIOS;\n    if (nativeInput && unlucky) {\n        nativeInput.addEventListener(`beforeinput`, () => {\n            previousCaret = nativeInput.selectionStart || 0;\n        });\n    }\n    return (conformedValue, config) => {\n        // Removing everything by selecting and pressing '-'\n        if (!conformedValue && config.rawValue === CHAR_HYPHEN && allowNegative) {\n            return CHAR_HYPHEN;\n        }\n        // remove these hacks after text mask library has changed\n        if (nativeInput && unlucky && tuiIsNativeFocused(nativeInput)) {\n            const caret = calculateSafariCaret(config.previousConformedValue, conformedValue, previousCaret);\n            setTimeout(() => {\n                nativeInput.setSelectionRange(caret, caret);\n            });\n        }\n        if (nativeInput &&\n            nativeInput.ownerDocument !== tuiGetDocumentOrShadowRoot(nativeInput) &&\n            tuiIsNativeFocused(nativeInput) &&\n            config.currentCaretPosition) {\n            const realCaretPosition = config.currentCaretPosition +\n                calculateCaretGap(config.previousConformedValue, conformedValue, thousandSymbol);\n            setTimeout(() => {\n                nativeInput.setSelectionRange(realCaretPosition, realCaretPosition);\n            });\n        }\n        if (conformedValue === `` || !decimalLimit || !Number.isInteger(decimalLimit)) {\n            return { value: conformedValue };\n        }\n        const withDecimalSymbol = addDecimalSymbolIfNeeded(conformedValue, decimalSymbol);\n        const decimalPart = withDecimalSymbol.split(decimalSymbol)[1];\n        const zeroPaddingSize = decimalLimit - decimalPart.length;\n        return {\n            value: withDecimalSymbol + `0`.repeat(zeroPaddingSize),\n        };\n    };\n}\nfunction addDecimalSymbolIfNeeded(value, decimalSymbol = `,`) {\n    return !value.includes(decimalSymbol) ? value + decimalSymbol : value;\n}\nfunction calculateSafariCaret(previousValue = ``, current, previousCaret, decimalSymbol = `,`) {\n    const tailRegex = new RegExp(`${decimalSymbol}.+`);\n    const previousWithoutTail = previousValue.replace(tailRegex, ``);\n    const currentWithoutTail = current.replace(tailRegex, ``);\n    const pasteOrCutOperation = Math.abs(previousWithoutTail.length - currentWithoutTail.length) > 2;\n    if (pasteOrCutOperation) {\n        return current.length;\n    }\n    if (previousValue.length === current.length) {\n        if (previousValue.indexOf(decimalSymbol) <= previousCaret) {\n            return calculateChangedTailIndex(previousValue, current);\n        }\n        return previousWithoutTail === currentWithoutTail\n            ? previousCaret - 1\n            : previousCaret + 1;\n    }\n    if (previousValue.length === 0) {\n        return 1;\n    }\n    const changeLength = current.length - previousValue.length;\n    return previousCaret + changeLength;\n}\nfunction calculateChangedTailIndex(previous, current) {\n    for (let i = 0; i < current.length; i++) {\n        if (previous[i] !== current[i]) {\n            return current[i] === `0` ? i : i + 1;\n        }\n    }\n    return current.length;\n}\nfunction calculateCaretGap(previousValue = ``, current, thousandSymbol) {\n    const pasteOrCutOperation = Math.abs(previousValue.length - current.length) > 2;\n    if (pasteOrCutOperation) {\n        return 0;\n    }\n    const wereSpaces = previousValue.split(thousandSymbol).length;\n    const nowSpaces = current.split(thousandSymbol).length;\n    return nowSpaces - wereSpaces;\n}\n\nconst ASSERTION = `Correction function must return single char or null`;\nfunction tuiCreateCorrectionMask(allowed, correctionHandler) {\n    return rawValue => {\n        const mask = rawValue.split(``).reduce((result, char, index) => {\n            const corrected = correctionHandler(char, index);\n            ngDevMode &&\n                tuiAssert.assert(corrected === null || corrected.length === 1, ASSERTION);\n            if (!allowed.test(char) && !corrected) {\n                return result;\n            }\n            if (allowed.test(char)) {\n                return [...result, allowed];\n            }\n            if (corrected) {\n                return [...result, corrected, MASK_CARET_TRAP];\n            }\n            return result;\n        }, []);\n        const lastIndex = mask.lastIndexOf(MASK_CARET_TRAP);\n        const filtered = mask.filter((item, index) => item !== MASK_CARET_TRAP || index === lastIndex);\n        return filtered.some(item => item !== allowed)\n            ? [...filtered, allowed]\n            : filtered;\n    };\n}\n\nconst NON_ZERO_DIGIT = /[1-9]/;\n/**\n * Adaptation for {@link https://github.com/text-mask/text-mask/tree/master/addons#createnumbermask `createNumberMask`}\n */\nfunction tuiCreateNumberMask({ allowDecimal = false, decimalSymbol = `,`, thousandSymbol = CHAR_NO_BREAK_SPACE, autoCorrectDecimalSymbol = true, decimalLimit = 2, requireDecimal = false, allowNegative = false, integerLimit = 0, } = {}) {\n    ngDevMode && tuiAssert.assert(decimalLimit >= 0);\n    ngDevMode && tuiAssert.assert(Number.isInteger(integerLimit));\n    ngDevMode && tuiAssert.assert(integerLimit >= 0);\n    // eslint-disable-next-line max-statements\n    return (rawValue, { previousConformedValue }) => {\n        if (previousConformedValue && requireDecimal) {\n            const conformedWithoutSeparator = rawValue.split(thousandSymbol).join(``);\n            const previousConformedValueWithoutDecimalSymbolAndSeparator = previousConformedValue\n                .split(thousandSymbol)\n                .join(``)\n                .split(decimalSymbol)\n                .join(``);\n            // Forbid removal of decimal separator if decimal part is required\n            if (conformedWithoutSeparator ===\n                previousConformedValueWithoutDecimalSymbolAndSeparator) {\n                rawValue = previousConformedValue;\n            }\n        }\n        const isNegative = ((rawValue === null || rawValue === void 0 ? void 0 : rawValue.startsWith(CHAR_HYPHEN)) || (rawValue === null || rawValue === void 0 ? void 0 : rawValue.startsWith(CHAR_EN_DASH))) &&\n            allowNegative;\n        if (isDecimalSymbol(rawValue, decimalSymbol, autoCorrectDecimalSymbol) &&\n            allowDecimal) {\n            return [`0`, decimalSymbol, TUI_DIGIT_REGEXP];\n        }\n        if (isNegative) {\n            rawValue = rawValue.slice(1);\n        }\n        const decimalIndex = getDecimalSymbolIndex(rawValue, decimalSymbol, autoCorrectDecimalSymbol);\n        const hasDecimal = decimalIndex !== -1;\n        const integer = hasDecimal ? rawValue.slice(0, decimalIndex) : rawValue;\n        const thousandSeparators = integer.match(new RegExp(thousandSymbol, `g`)) || [];\n        const integerCapped = integerLimit\n            ? integer.slice(0, integerLimit + thousandSeparators.length)\n            : integer;\n        const integerCappedClean = integerCapped.replace(TUI_NON_DIGITS_REGEXP, ``);\n        const [leadingZerosMatch] = integerCappedClean.match(TUI_LEADING_ZEROES_REGEXP) || [``];\n        const leadingZerosAmount = leadingZerosMatch.length;\n        const integerCappedZerosClean = integerCappedClean\n            .replace(/^0+(?!\\.|$)/, ``)\n            .trim();\n        const withSeparator = addThousandsSeparator(integerCappedZerosClean, thousandSymbol);\n        const mask = convertToMask(withSeparator);\n        if ((hasDecimal && allowDecimal) || requireDecimal) {\n            const fraction = hasDecimal\n                ? convertToMask(rawValue.slice(decimalIndex + 1).replace(TUI_NON_DIGITS_REGEXP, ``))\n                : [];\n            const fractionCapped = decimalLimit\n                ? fraction.slice(0, decimalLimit)\n                : fraction;\n            if (rawValue[decimalIndex] !== tuiOtherDecimalSymbol(decimalSymbol)) {\n                mask.push(MASK_CARET_TRAP);\n            }\n            mask.push(decimalSymbol, MASK_CARET_TRAP, ...fractionCapped);\n            for (let i = 0; i < Math.min(decimalLimit - fractionCapped.length, 20); i++) {\n                mask.push(TUI_DIGIT_REGEXP);\n            }\n        }\n        const isOnlyZeroDigit = mask.length === 1 && integerCappedZerosClean === `0`;\n        if (isNegative) {\n            if (mask.length === 0) {\n                mask.push(TUI_DIGIT_REGEXP);\n            }\n            mask.unshift(CHAR_HYPHEN);\n        }\n        return preventLeadingZeroes(mask, isOnlyZeroDigit, leadingZerosAmount);\n    };\n}\nfunction preventLeadingZeroes(mask, isOnlyZeroDigit = false, leadingZerosAmount = 0) {\n    if (isOnlyZeroDigit || leadingZerosAmount === 0) {\n        return mask;\n    }\n    const firstDigitIndex = mask.indexOf(TUI_DIGIT_REGEXP);\n    if (firstDigitIndex === -1) {\n        return mask;\n    }\n    const secondMaskDigit = mask[firstDigitIndex + 1];\n    const isCaretTrap = secondMaskDigit === MASK_CARET_TRAP;\n    if (isCaretTrap && leadingZerosAmount === 1) {\n        return mask;\n    }\n    if (isCaretTrap) {\n        mask.unshift(NON_ZERO_DIGIT);\n        return mask;\n    }\n    mask[firstDigitIndex] = NON_ZERO_DIGIT;\n    return mask;\n}\nfunction getDecimalSymbolIndex(str, decimalSymbol, autoCorrectDecimalSymbol) {\n    if (!autoCorrectDecimalSymbol) {\n        return str.lastIndexOf(decimalSymbol);\n    }\n    return Math.max(str.lastIndexOf(decimalSymbol), str.lastIndexOf(tuiOtherDecimalSymbol(decimalSymbol)));\n}\nfunction isDecimalSymbol(str, decimalSymbol, autoCorrectDecimalSymbol) {\n    if (autoCorrectDecimalSymbol) {\n        return /^[,.]$/.test(str);\n    }\n    return str === decimalSymbol;\n}\nfunction convertToMask(strNumber) {\n    return strNumber\n        .split(``)\n        .map(char => (TUI_DIGIT_REGEXP.test(char) ? TUI_DIGIT_REGEXP : char));\n}\nfunction addThousandsSeparator(strNumber, thousandSymbol) {\n    return strNumber.length > 3\n        ? // TODO: investigate to disallow potentially catastrophic exponential-time regular expressions.\n            // eslint-disable-next-line unicorn/no-unsafe-regex\n            strNumber.replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousandSymbol)\n        : strNumber;\n}\n\nfunction tuiEnableAutoCorrectDecimalSymbol({ thousandSeparator, }) {\n    return !TUI_DECIMAL_SYMBOLS.includes(thousandSeparator);\n}\n\nfunction tuiMaskedMoneyValueIsEmpty(value) {\n    switch (value) {\n        case ``:\n        case CHAR_HYPHEN:\n        case `,`:\n        case `${CHAR_HYPHEN},`:\n            return true;\n        default:\n            return false;\n    }\n}\n\nfunction tuiMaskedNumberStringToNumber(value, decimalsSymbol, thousandSymbol) {\n    return parseFloat(value.split(thousandSymbol).join(``).split(decimalsSymbol).join(`.`));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiCreateAutoCorrectedNumberPipe, tuiCreateCorrectionMask, tuiCreateNumberMask, tuiEnableAutoCorrectDecimalSymbol, tuiMaskedMoneyValueIsEmpty, tuiMaskedNumberStringToNumber };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}