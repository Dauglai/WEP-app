{"ast":null,"code":"import { tuiAssert } from '@taiga-ui/cdk/classes';\nimport { TuiPureException } from '@taiga-ui/cdk/exceptions';\nfunction tuiDebounce(timeout) {\n  let timeoutRef;\n  return function (_target, _key, descriptor) {\n    const {\n      value\n    } = descriptor;\n    descriptor.value = function (...args) {\n      clearTimeout(timeoutRef);\n      timeoutRef = setTimeout(() => value.apply(this, args), timeout);\n    };\n    return descriptor;\n  };\n}\n\n/**\n * Decorator for checking input values for undefined. You can also pass\n * optional assertion to check input against.\n *\n * CAUTION: This decorator overwrites other getters and setters.\n */\nfunction tuiDefaultProp(assertion, ...args) {\n  return (target, key) => {\n    const {\n      name\n    } = target.constructor;\n    const errorGetDefaultMessage = ngDevMode && errorGetDefault(key, name);\n    const errorSetDefaultMessage = ngDevMode && errorSetDefault(key, name);\n    Object.defineProperty(target, key, {\n      configurable: true,\n      get() {\n        ngDevMode && tuiAssert.assert(false, errorGetDefaultMessage);\n        return undefined;\n      },\n      set(initialValue) {\n        const isValid = initialValue !== undefined;\n        const errorMessage = ngDevMode && errorSetDefaultInitial(key, name);\n        let currentValue = initialValue;\n        ngDevMode && tuiAssert.assert(isValid, errorMessage);\n        if (ngDevMode && isValid && assertion && tuiAssert) {\n          tuiAssert.assert(assertion.call(this, initialValue), `${String(key)} in ${name} received:`, initialValue, ...args);\n        }\n        Object.defineProperty(this, key, {\n          configurable: true,\n          get() {\n            return currentValue;\n          },\n          set(value) {\n            const isValid = value !== undefined;\n            const backupValue = initialValue;\n            ngDevMode && tuiAssert.assert(isValid, errorSetDefaultMessage, String(backupValue));\n            if (ngDevMode && isValid && assertion && tuiAssert) {\n              tuiAssert.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);\n            }\n            currentValue = isValid ? value : backupValue;\n          }\n        });\n      }\n    });\n  };\n}\nfunction errorGetDefault(key, component) {\n  return `Default value for ${String(key)} was not provided in ${component}, error in Taiga UI Angular Kit`;\n}\nfunction errorSetDefault(key, component) {\n  return `Undefined was passed as ${String(key)} to ${component}, which is invalid input, using default value:`;\n}\nfunction errorSetDefaultInitial(key, component) {\n  return `Undefined was passed as default value for ${String(key)} to ${component}, error in Taiga UI Angular Kit`;\n}\n\n/**\n * Implements lazy initialization for getter or memoization of a function call similar to pure {@link: Pipe}.\n * Replaces getter with its calculated value upon first call or keeps track of last call arguments and returned\n * value for function, skipping calculation when arguments are strictly the same.\n *\n * @throws error if used not on getter or function\n *\n * CAUTION: `this` is not available inside such functions/getters, they must be pure.\n */\nfunction tuiPure(_target, propertyKey, {\n  get,\n  enumerable,\n  value\n}) {\n  if (get) {\n    return {\n      configurable: true,\n      enumerable,\n      get() {\n        const value = get.call(this);\n        Object.defineProperty(this, propertyKey, {\n          enumerable,\n          value\n        });\n        return value;\n      }\n    };\n  }\n  if (typeof value !== `function`) {\n    throw new TuiPureException();\n  }\n  const original = value;\n  return {\n    configurable: true,\n    enumerable,\n    get() {\n      let previousArgs = [];\n      let originalFnWasCalledLeastAtOnce = false;\n      let pureValue;\n      const patched = (...args) => {\n        const isPure = originalFnWasCalledLeastAtOnce && previousArgs.length === args.length && args.every((arg, index) => arg === previousArgs[index]);\n        if (isPure) {\n          return pureValue;\n        }\n        previousArgs = args;\n        pureValue = original.apply(this, args);\n        originalFnWasCalledLeastAtOnce = true;\n        return pureValue;\n      };\n      Object.defineProperty(this, propertyKey, {\n        configurable: true,\n        value: patched\n      });\n      return patched;\n    }\n  };\n}\n\n/**\n * Decorator for checking input setter values against a custom assertion which\n * takes value passed to input setter and component instance as arguments.\n * It specifically checks for undefined values and prevents calls to the\n * original setter in this case.\n */\nfunction tuiRequiredSetter(assertion, ...args) {\n  return (target, key, {\n    configurable,\n    enumerable,\n    get,\n    set\n  }) => {\n    const {\n      name\n    } = target.constructor;\n    return {\n      configurable,\n      enumerable,\n      get,\n      set(value) {\n        if (ngDevMode && value !== undefined && assertion && tuiAssert) {\n          tuiAssert.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);\n        }\n        if (!set || value === undefined) {\n          ngDevMode && tuiAssert.assert(value !== undefined, errorSet(key, name));\n          return;\n        }\n        set.call(this, value);\n      }\n    };\n  };\n}\nfunction errorSet(key, component) {\n  return `Undefined was passed as ${String(key)} to ${component}, setter will not be called`;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiDebounce, tuiDefaultProp, tuiPure, tuiRequiredSetter };","map":{"version":3,"names":["tuiAssert","TuiPureException","tuiDebounce","timeout","timeoutRef","_target","_key","descriptor","value","args","clearTimeout","setTimeout","apply","tuiDefaultProp","assertion","target","key","name","constructor","errorGetDefaultMessage","ngDevMode","errorGetDefault","errorSetDefaultMessage","errorSetDefault","Object","defineProperty","configurable","get","assert","undefined","set","initialValue","isValid","errorMessage","errorSetDefaultInitial","currentValue","call","String","backupValue","component","tuiPure","propertyKey","enumerable","original","previousArgs","originalFnWasCalledLeastAtOnce","pureValue","patched","isPure","length","every","arg","index","tuiRequiredSetter","errorSet"],"sources":["C:/Users/denis/PycharmProjects/example_project/frontend/node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-decorators.js"],"sourcesContent":["import { tuiAssert } from '@taiga-ui/cdk/classes';\nimport { TuiPureException } from '@taiga-ui/cdk/exceptions';\n\nfunction tuiDebounce(timeout) {\n    let timeoutRef;\n    return function (_target, _key, descriptor) {\n        const { value } = descriptor;\n        descriptor.value = function (...args) {\n            clearTimeout(timeoutRef);\n            timeoutRef = setTimeout(() => value.apply(this, args), timeout);\n        };\n        return descriptor;\n    };\n}\n\n/**\n * Decorator for checking input values for undefined. You can also pass\n * optional assertion to check input against.\n *\n * CAUTION: This decorator overwrites other getters and setters.\n */\nfunction tuiDefaultProp(assertion, ...args) {\n    return (target, key) => {\n        const { name } = target.constructor;\n        const errorGetDefaultMessage = ngDevMode && errorGetDefault(key, name);\n        const errorSetDefaultMessage = ngDevMode && errorSetDefault(key, name);\n        Object.defineProperty(target, key, {\n            configurable: true,\n            get() {\n                ngDevMode && tuiAssert.assert(false, errorGetDefaultMessage);\n                return undefined;\n            },\n            set(initialValue) {\n                const isValid = initialValue !== undefined;\n                const errorMessage = ngDevMode && errorSetDefaultInitial(key, name);\n                let currentValue = initialValue;\n                ngDevMode && tuiAssert.assert(isValid, errorMessage);\n                if (ngDevMode && isValid && assertion && tuiAssert) {\n                    tuiAssert.assert(assertion.call(this, initialValue), `${String(key)} in ${name} received:`, initialValue, ...args);\n                }\n                Object.defineProperty(this, key, {\n                    configurable: true,\n                    get() {\n                        return currentValue;\n                    },\n                    set(value) {\n                        const isValid = value !== undefined;\n                        const backupValue = initialValue;\n                        ngDevMode &&\n                            tuiAssert.assert(isValid, errorSetDefaultMessage, String(backupValue));\n                        if (ngDevMode && isValid && assertion && tuiAssert) {\n                            tuiAssert.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);\n                        }\n                        currentValue = isValid ? value : backupValue;\n                    },\n                });\n            },\n        });\n    };\n}\nfunction errorGetDefault(key, component) {\n    return `Default value for ${String(key)} was not provided in ${component}, error in Taiga UI Angular Kit`;\n}\nfunction errorSetDefault(key, component) {\n    return `Undefined was passed as ${String(key)} to ${component}, which is invalid input, using default value:`;\n}\nfunction errorSetDefaultInitial(key, component) {\n    return `Undefined was passed as default value for ${String(key)} to ${component}, error in Taiga UI Angular Kit`;\n}\n\n/**\n * Implements lazy initialization for getter or memoization of a function call similar to pure {@link: Pipe}.\n * Replaces getter with its calculated value upon first call or keeps track of last call arguments and returned\n * value for function, skipping calculation when arguments are strictly the same.\n *\n * @throws error if used not on getter or function\n *\n * CAUTION: `this` is not available inside such functions/getters, they must be pure.\n */\nfunction tuiPure(_target, propertyKey, { get, enumerable, value }) {\n    if (get) {\n        return {\n            configurable: true,\n            enumerable,\n            get() {\n                const value = get.call(this);\n                Object.defineProperty(this, propertyKey, { enumerable, value });\n                return value;\n            },\n        };\n    }\n    if (typeof value !== `function`) {\n        throw new TuiPureException();\n    }\n    const original = value;\n    return {\n        configurable: true,\n        enumerable,\n        get() {\n            let previousArgs = [];\n            let originalFnWasCalledLeastAtOnce = false;\n            let pureValue;\n            const patched = (...args) => {\n                const isPure = originalFnWasCalledLeastAtOnce &&\n                    previousArgs.length === args.length &&\n                    args.every((arg, index) => arg === previousArgs[index]);\n                if (isPure) {\n                    return pureValue;\n                }\n                previousArgs = args;\n                pureValue = original.apply(this, args);\n                originalFnWasCalledLeastAtOnce = true;\n                return pureValue;\n            };\n            Object.defineProperty(this, propertyKey, {\n                configurable: true,\n                value: patched,\n            });\n            return patched;\n        },\n    };\n}\n\n/**\n * Decorator for checking input setter values against a custom assertion which\n * takes value passed to input setter and component instance as arguments.\n * It specifically checks for undefined values and prevents calls to the\n * original setter in this case.\n */\nfunction tuiRequiredSetter(assertion, ...args) {\n    return (target, key, { configurable, enumerable, get, set }) => {\n        const { name } = target.constructor;\n        return {\n            configurable,\n            enumerable,\n            get,\n            set(value) {\n                if (ngDevMode && value !== undefined && assertion && tuiAssert) {\n                    tuiAssert.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);\n                }\n                if (!set || value === undefined) {\n                    ngDevMode &&\n                        tuiAssert.assert(value !== undefined, errorSet(key, name));\n                    return;\n                }\n                set.call(this, value);\n            },\n        };\n    };\n}\nfunction errorSet(key, component) {\n    return `Undefined was passed as ${String(key)} to ${component}, setter will not be called`;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiDebounce, tuiDefaultProp, tuiPure, tuiRequiredSetter };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}