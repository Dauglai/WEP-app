{"ast":null,"code":"import { tuiClamp } from '@taiga-ui/cdk/utils/math';\nimport { tuiIsPresent } from '@taiga-ui/cdk/utils/miscellaneous';\nimport { tuiAssert } from '@taiga-ui/cdk/classes';\nfunction tuiCanScroll(element, rootElement, vertical, scrollEnd) {\n  return vertical ? canScrollVertical(element, rootElement, scrollEnd) : canScrollHorizontal(element, rootElement, scrollEnd);\n}\nfunction canScrollVertical(element, rootElement, scrollEnd) {\n  let currentElement = element;\n  while (currentElement !== rootElement.parentElement) {\n    if (Math.floor(currentElement.scrollTop) > 0 && !scrollEnd || Math.ceil(currentElement.scrollTop + currentElement.clientHeight) < currentElement.scrollHeight && scrollEnd) {\n      return true;\n    }\n    if (currentElement.parentElement) {\n      currentElement = currentElement.parentElement;\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\nfunction canScrollHorizontal(element, rootElement, scrollEnd) {\n  let currentElement = element;\n  while (currentElement !== rootElement.parentElement) {\n    if (Math.floor(currentElement.scrollLeft) > 0 && !scrollEnd || Math.ceil(currentElement.scrollLeft + currentElement.clientWidth) < currentElement.scrollWidth && scrollEnd) {\n      return true;\n    }\n    if (currentElement.parentElement) {\n      currentElement = currentElement.parentElement;\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\nfunction tuiContainsOrAfter(current, node) {\n  try {\n    return current.contains(node) || !!(node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING);\n  } catch (_a) {\n    return false;\n  }\n}\nfunction tuiIsInput(element) {\n  return element.matches(`input`);\n}\nfunction tuiIsTextarea(element) {\n  return element.matches(`textarea`);\n}\nfunction tuiIsTextfield(element) {\n  return tuiIsInput(element) || tuiIsTextarea(element);\n}\nfunction tuiIsElement(node) {\n  return !!node && `nodeType` in node && node.nodeType === Node.ELEMENT_NODE;\n}\nfunction tuiIsHTMLElement(node) {\n  // TODO: iframe warning\n  return node instanceof HTMLElement;\n}\nfunction tuiIsTextNode(node) {\n  return node.nodeType === Node.TEXT_NODE;\n}\n\n/**\n * Gets actual target from open Shadow DOM if event happened within it\n */\nfunction tuiGetActualTarget(event) {\n  return event.composedPath()[0];\n}\nconst DEFAULT_FORMAT = `text/plain`;\n/**\n * Gets text from data of clipboardEvent, it also works in IE and Edge browsers\n */\nfunction tuiGetClipboardDataText(event, format = DEFAULT_FORMAT) {\n  return `clipboardData` in event && event.clipboardData !== null ? event.clipboardData.getData(format) || event.clipboardData.getData(DEFAULT_FORMAT) : event.target.ownerDocument.defaultView.clipboardData.getData(`text`);\n}\nfunction tuiGetDocumentOrShadowRoot(node) {\n  return `getRootNode` in node && node.isConnected ? node.getRootNode() : node.ownerDocument;\n}\n\n/**\n * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible\n *\n * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered\n * TODO: v4.0 change function signature to\n * ```ts\n * function tuiGetElementObscures(element: Element): readonly [Element, Element, Element, Element] | [] | null\n * ```\n */\nfunction tuiGetElementObscures(element) {\n  const {\n    ownerDocument\n  } = element;\n  if (!(ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.defaultView) || !element.getBoundingClientRect) {\n    return null;\n  }\n  const {\n    innerWidth,\n    innerHeight\n  } = ownerDocument.defaultView;\n  const doc = tuiGetDocumentOrShadowRoot(element);\n  const rect = element.getBoundingClientRect();\n  const left = tuiClamp(Math.round(rect.left) + 2, 0, innerWidth);\n  const top = tuiClamp(Math.round(rect.top) + 2, 0, innerHeight);\n  const right = tuiClamp(Math.round(rect.right) - 2, 0, innerWidth);\n  const bottom = tuiClamp(Math.round(rect.bottom) - 2, 0, innerHeight);\n  const horizontalMiddle = tuiClamp(Math.round(rect.left + rect.width / 2), 0, innerWidth);\n  const verticalMiddle = tuiClamp(Math.round(rect.top + rect.height / 2), 0, innerHeight);\n  const elements = [doc.elementFromPoint(horizontalMiddle, top), doc.elementFromPoint(horizontalMiddle, bottom), doc.elementFromPoint(left, verticalMiddle), doc.elementFromPoint(right, verticalMiddle)];\n  const nonNull = elements.filter(tuiIsPresent);\n  if (!nonNull.length) {\n    return nonNull;\n  }\n  const filtered = nonNull.filter(el => !element.contains(el));\n  return filtered.length === 4 ? filtered : null;\n}\n\n/**\n * Calculates offset for an element relative to it's parent several levels above\n *\n * @param host parent element\n * @param element\n * @return object with offsetTop and offsetLeft number properties\n */\nfunction tuiGetElementOffset(host, element) {\n  ngDevMode && tuiAssert.assert(host.contains(element), `Host must contain element`);\n  let {\n    offsetTop,\n    offsetLeft,\n    offsetParent\n  } = element;\n  while (tuiIsHTMLElement(offsetParent) && offsetParent !== host) {\n    offsetTop += offsetParent.offsetTop;\n    offsetLeft += offsetParent.offsetLeft;\n    offsetParent = offsetParent.offsetParent;\n  }\n  return {\n    offsetTop,\n    offsetLeft\n  };\n}\n\n/**\n * Finds the nearest parent with scroll in it\n *\n * @param element initial element\n * @param vertical flag for orientation of scroll\n */\nfunction tuiGetScrollParent(element, vertical = true) {\n  if (element === null) {\n    return null;\n  }\n  if (vertical && element.scrollHeight > element.clientHeight) {\n    return element;\n  }\n  if (!vertical && element.scrollWidth > element.clientWidth) {\n    return element;\n  }\n  return tuiGetScrollParent(element.parentElement, vertical);\n}\n\n/**\n * @description:\n * cross browser way to get selected text\n *\n * History:\n * BUG - window.getSelection() fails when text selected in a form field\n * https://bugzilla.mozilla.org/show_bug.cgi?id=85686\n */\nfunction tuiGetSelectedText({\n  getSelection,\n  document\n}) {\n  var _a;\n  return document.activeElement && tuiIsTextfield(document.activeElement) ? document.activeElement.value.slice(document.activeElement.selectionStart || 0, document.activeElement.selectionEnd || 0) : ((_a = getSelection()) === null || _a === void 0 ? void 0 : _a.toString()) || null;\n}\nfunction tuiIsCurrentTarget({\n  target,\n  currentTarget\n}) {\n  return target === currentTarget;\n}\nfunction tuiIsElementEditable(element) {\n  return tuiIsTextfield(element) && !element.readOnly || element.isContentEditable;\n}\n\n/**\n * Checks if an app is running inside <iframe /> tag\n */\nfunction tuiIsInsideIframe(win) {\n  return win.parent !== win;\n}\n\n/**\n * Checks if node is inside a specific selector\n *\n * @param node\n * @param selector\n * @return true if node is inside a particular selector\n */\nfunction tuiIsNodeIn(node, selector) {\n  var _a;\n  return tuiIsTextNode(node) ? !!((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.closest(selector)) : tuiIsElement(node) && !!node.closest(selector);\n}\nfunction tuiPointToClientRect(x = 0, y = 0) {\n  const rect = {\n    x,\n    y,\n    left: x,\n    right: x,\n    top: y,\n    bottom: y,\n    width: 0,\n    height: 0\n  };\n  return Object.assign(Object.assign({}, rect), {\n    toJSON() {\n      return rect;\n    }\n  });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiCanScroll, tuiContainsOrAfter, tuiGetActualTarget, tuiGetClipboardDataText, tuiGetDocumentOrShadowRoot, tuiGetElementObscures, tuiGetElementOffset, tuiGetScrollParent, tuiGetSelectedText, tuiIsCurrentTarget, tuiIsElement, tuiIsElementEditable, tuiIsHTMLElement, tuiIsInput, tuiIsInsideIframe, tuiIsNodeIn, tuiIsTextNode, tuiIsTextarea, tuiIsTextfield, tuiPointToClientRect };","map":{"version":3,"names":["tuiClamp","tuiIsPresent","tuiAssert","tuiCanScroll","element","rootElement","vertical","scrollEnd","canScrollVertical","canScrollHorizontal","currentElement","parentElement","Math","floor","scrollTop","ceil","clientHeight","scrollHeight","scrollLeft","clientWidth","scrollWidth","tuiContainsOrAfter","current","node","contains","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","_a","tuiIsInput","matches","tuiIsTextarea","tuiIsTextfield","tuiIsElement","nodeType","ELEMENT_NODE","tuiIsHTMLElement","HTMLElement","tuiIsTextNode","TEXT_NODE","tuiGetActualTarget","event","composedPath","DEFAULT_FORMAT","tuiGetClipboardDataText","format","clipboardData","getData","target","ownerDocument","defaultView","tuiGetDocumentOrShadowRoot","isConnected","getRootNode","tuiGetElementObscures","getBoundingClientRect","innerWidth","innerHeight","doc","rect","left","round","top","right","bottom","horizontalMiddle","width","verticalMiddle","height","elements","elementFromPoint","nonNull","filter","length","filtered","el","tuiGetElementOffset","host","ngDevMode","assert","offsetTop","offsetLeft","offsetParent","tuiGetScrollParent","tuiGetSelectedText","getSelection","document","activeElement","value","slice","selectionStart","selectionEnd","toString","tuiIsCurrentTarget","currentTarget","tuiIsElementEditable","readOnly","isContentEditable","tuiIsInsideIframe","win","parent","tuiIsNodeIn","selector","closest","tuiPointToClientRect","x","y","Object","assign","toJSON"],"sources":["C:/Users/denis/PycharmProjects/example_project/frontend/node_modules/@taiga-ui/cdk/fesm2015/taiga-ui-cdk-utils-dom.js"],"sourcesContent":["import { tuiClamp } from '@taiga-ui/cdk/utils/math';\nimport { tuiIsPresent } from '@taiga-ui/cdk/utils/miscellaneous';\nimport { tuiAssert } from '@taiga-ui/cdk/classes';\n\nfunction tuiCanScroll(element, rootElement, vertical, scrollEnd) {\n    return vertical\n        ? canScrollVertical(element, rootElement, scrollEnd)\n        : canScrollHorizontal(element, rootElement, scrollEnd);\n}\nfunction canScrollVertical(element, rootElement, scrollEnd) {\n    let currentElement = element;\n    while (currentElement !== rootElement.parentElement) {\n        if ((Math.floor(currentElement.scrollTop) > 0 && !scrollEnd) ||\n            (Math.ceil(currentElement.scrollTop + currentElement.clientHeight) <\n                currentElement.scrollHeight &&\n                scrollEnd)) {\n            return true;\n        }\n        if (currentElement.parentElement) {\n            currentElement = currentElement.parentElement;\n        }\n        else {\n            return false;\n        }\n    }\n    return false;\n}\nfunction canScrollHorizontal(element, rootElement, scrollEnd) {\n    let currentElement = element;\n    while (currentElement !== rootElement.parentElement) {\n        if ((Math.floor(currentElement.scrollLeft) > 0 && !scrollEnd) ||\n            (Math.ceil(currentElement.scrollLeft + currentElement.clientWidth) <\n                currentElement.scrollWidth &&\n                scrollEnd)) {\n            return true;\n        }\n        if (currentElement.parentElement) {\n            currentElement = currentElement.parentElement;\n        }\n        else {\n            return false;\n        }\n    }\n    return false;\n}\n\nfunction tuiContainsOrAfter(current, node) {\n    try {\n        return (current.contains(node) ||\n            !!(node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING));\n    }\n    catch (_a) {\n        return false;\n    }\n}\n\nfunction tuiIsInput(element) {\n    return element.matches(`input`);\n}\nfunction tuiIsTextarea(element) {\n    return element.matches(`textarea`);\n}\nfunction tuiIsTextfield(element) {\n    return tuiIsInput(element) || tuiIsTextarea(element);\n}\nfunction tuiIsElement(node) {\n    return !!node && `nodeType` in node && node.nodeType === Node.ELEMENT_NODE;\n}\nfunction tuiIsHTMLElement(node) {\n    // TODO: iframe warning\n    return node instanceof HTMLElement;\n}\nfunction tuiIsTextNode(node) {\n    return node.nodeType === Node.TEXT_NODE;\n}\n\n/**\n * Gets actual target from open Shadow DOM if event happened within it\n */\nfunction tuiGetActualTarget(event) {\n    return event.composedPath()[0];\n}\n\nconst DEFAULT_FORMAT = `text/plain`;\n/**\n * Gets text from data of clipboardEvent, it also works in IE and Edge browsers\n */\nfunction tuiGetClipboardDataText(event, format = DEFAULT_FORMAT) {\n    return `clipboardData` in event && event.clipboardData !== null\n        ? event.clipboardData.getData(format) ||\n            event.clipboardData.getData(DEFAULT_FORMAT)\n        : event.target.ownerDocument.defaultView.clipboardData.getData(`text`);\n}\n\nfunction tuiGetDocumentOrShadowRoot(node) {\n    return `getRootNode` in node && node.isConnected\n        ? node.getRootNode()\n        : node.ownerDocument;\n}\n\n/**\n * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible\n *\n * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered\n * TODO: v4.0 change function signature to\n * ```ts\n * function tuiGetElementObscures(element: Element): readonly [Element, Element, Element, Element] | [] | null\n * ```\n */\nfunction tuiGetElementObscures(element) {\n    const { ownerDocument } = element;\n    if (!(ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.defaultView) || !element.getBoundingClientRect) {\n        return null;\n    }\n    const { innerWidth, innerHeight } = ownerDocument.defaultView;\n    const doc = tuiGetDocumentOrShadowRoot(element);\n    const rect = element.getBoundingClientRect();\n    const left = tuiClamp(Math.round(rect.left) + 2, 0, innerWidth);\n    const top = tuiClamp(Math.round(rect.top) + 2, 0, innerHeight);\n    const right = tuiClamp(Math.round(rect.right) - 2, 0, innerWidth);\n    const bottom = tuiClamp(Math.round(rect.bottom) - 2, 0, innerHeight);\n    const horizontalMiddle = tuiClamp(Math.round(rect.left + rect.width / 2), 0, innerWidth);\n    const verticalMiddle = tuiClamp(Math.round(rect.top + rect.height / 2), 0, innerHeight);\n    const elements = [\n        doc.elementFromPoint(horizontalMiddle, top),\n        doc.elementFromPoint(horizontalMiddle, bottom),\n        doc.elementFromPoint(left, verticalMiddle),\n        doc.elementFromPoint(right, verticalMiddle),\n    ];\n    const nonNull = elements.filter(tuiIsPresent);\n    if (!nonNull.length) {\n        return nonNull;\n    }\n    const filtered = nonNull.filter(el => !element.contains(el));\n    return filtered.length === 4 ? filtered : null;\n}\n\n/**\n * Calculates offset for an element relative to it's parent several levels above\n *\n * @param host parent element\n * @param element\n * @return object with offsetTop and offsetLeft number properties\n */\nfunction tuiGetElementOffset(host, element) {\n    ngDevMode && tuiAssert.assert(host.contains(element), `Host must contain element`);\n    let { offsetTop, offsetLeft, offsetParent } = element;\n    while (tuiIsHTMLElement(offsetParent) && offsetParent !== host) {\n        offsetTop += offsetParent.offsetTop;\n        offsetLeft += offsetParent.offsetLeft;\n        offsetParent = offsetParent.offsetParent;\n    }\n    return { offsetTop, offsetLeft };\n}\n\n/**\n * Finds the nearest parent with scroll in it\n *\n * @param element initial element\n * @param vertical flag for orientation of scroll\n */\nfunction tuiGetScrollParent(element, vertical = true) {\n    if (element === null) {\n        return null;\n    }\n    if (vertical && element.scrollHeight > element.clientHeight) {\n        return element;\n    }\n    if (!vertical && element.scrollWidth > element.clientWidth) {\n        return element;\n    }\n    return tuiGetScrollParent(element.parentElement, vertical);\n}\n\n/**\n * @description:\n * cross browser way to get selected text\n *\n * History:\n * BUG - window.getSelection() fails when text selected in a form field\n * https://bugzilla.mozilla.org/show_bug.cgi?id=85686\n */\nfunction tuiGetSelectedText({ getSelection, document }) {\n    var _a;\n    return document.activeElement && tuiIsTextfield(document.activeElement)\n        ? document.activeElement.value.slice(document.activeElement.selectionStart || 0, document.activeElement.selectionEnd || 0)\n        : ((_a = getSelection()) === null || _a === void 0 ? void 0 : _a.toString()) || null;\n}\n\nfunction tuiIsCurrentTarget({ target, currentTarget }) {\n    return target === currentTarget;\n}\n\nfunction tuiIsElementEditable(element) {\n    return (tuiIsTextfield(element) && !element.readOnly) || element.isContentEditable;\n}\n\n/**\n * Checks if an app is running inside <iframe /> tag\n */\nfunction tuiIsInsideIframe(win) {\n    return win.parent !== win;\n}\n\n/**\n * Checks if node is inside a specific selector\n *\n * @param node\n * @param selector\n * @return true if node is inside a particular selector\n */\nfunction tuiIsNodeIn(node, selector) {\n    var _a;\n    return tuiIsTextNode(node)\n        ? !!((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.closest(selector))\n        : tuiIsElement(node) && !!node.closest(selector);\n}\n\nfunction tuiPointToClientRect(x = 0, y = 0) {\n    const rect = {\n        x,\n        y,\n        left: x,\n        right: x,\n        top: y,\n        bottom: y,\n        width: 0,\n        height: 0,\n    };\n    return Object.assign(Object.assign({}, rect), { toJSON() {\n            return rect;\n        } });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { tuiCanScroll, tuiContainsOrAfter, tuiGetActualTarget, tuiGetClipboardDataText, tuiGetDocumentOrShadowRoot, tuiGetElementObscures, tuiGetElementOffset, tuiGetScrollParent, tuiGetSelectedText, tuiIsCurrentTarget, tuiIsElement, tuiIsElementEditable, tuiIsHTMLElement, tuiIsInput, tuiIsInsideIframe, tuiIsNodeIn, tuiIsTextNode, tuiIsTextarea, tuiIsTextfield, tuiPointToClientRect };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}